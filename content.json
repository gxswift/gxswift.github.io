{"meta":{"title":"gx的博客","subtitle":"","description":"","author":"GX","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2024-12-26T06:55:31.906Z","updated":"2024-12-26T06:55:31.906Z","comments":true,"path":"me/index.html","permalink":"http://example.com/me/index.html","excerpt":"","text":"嵌入式"},{"title":"标签","date":"2024-12-26T06:55:05.440Z","updated":"2024-12-26T06:55:05.440Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-12-26T06:50:26.976Z","updated":"2024-12-26T06:50:26.976Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo 博客搭建","slug":"linux/blog","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:08:59.559Z","comments":true,"path":"2024/12/26/linux/blog/","permalink":"http://example.com/2024/12/26/linux/blog/","excerpt":"","text":"Hexo blog 搭建HEXO 安装 HEXO官网 12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 更换主题 主题 12345$ cd HEXO_PATH/themes$ git clone https://github.com/cocowool/wave.git$ npm install --save hexo-renderer-sass$ cd ..$ hexo s 推送 安装推送工具 1npm install hexo-deployer-git --save _congif.yml文件,找到 deploy 字段，把以下代码放进去，填写新建的仓库地址 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: &lt;你的仓库地址&gt;branch: master 静态文件生成 1hexo g 清除 1hexo clean 部署 1hexo deploy","categories":[{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"GCC lib","slug":"linux/lib","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:07:29.085Z","comments":true,"path":"2024/12/26/linux/lib/","permalink":"http://example.com/2024/12/26/linux/lib/","excerpt":"","text":"GCC库生成动态库和静态库编译使用main.c 12345678#include &lt;stdio.h&gt;#include &quot;max.h&quot;int main(int argc, char *argv[])&#123; int a = 10, b = -2, c = 100; printf(&quot;max among 10, -2 and 100 is %d.\\n&quot;, max(a, b, c)); return 0;&#125; max.c 123456789#include &quot;stdio.h&quot;int max(int n1, int n2, int n3)&#123; int max_num = n1; max_num = max_num &lt; n2? n2: max_num; max_num = max_num &lt; n3? n3: max_num; printf(&quot;\\nlib test makefile add path\\n&quot;); return max_num;&#125; max.h 1234#ifndef __MAX_H__#define __MAX_H__int max(int n1, int n2, int n3);#endif makefile 1234567891011121314151617.PHONY: build test cleanmax.o: max.c gcc -c -fPIC $&lt;#动态库build1: max.o gcc -o libmax.so -shared max.otest1: main.c build1 gcc -o dynamic $&lt; -L./ -Wl,-rpath=./ -lmax#静态库build2:max.o ar -rcs libmaxs.a max.otest2: main.c build2 gcc -o static $&lt; -L ./ -lmaxsclean: rm -f *.o *.so *.a gcc常用编译选项： 选项 含义 -static 链接静态库，禁止使用动态库 -shared 进行动态库编译，链接动态库 -Ldir 在库的搜索路径中增加dir目录 -lname 链接静态库(libname.a)或动态库(libname.so)的库文件 -fPIC(或fpic) 生成使用相对地址无关的目标代码 -Wl,-rpath&#x3D;dir 指定动态库文件位置","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"makefile","slug":"makefile","permalink":"http://example.com/tags/makefile/"},{"name":"gcc","slug":"gcc","permalink":"http://example.com/tags/gcc/"}]},{"title":"gitattributes","slug":"linux/gitattributes","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:00:56.018Z","comments":true,"path":"2024/12/26/linux/gitattributes/","permalink":"http://example.com/2024/12/26/linux/gitattributes/","excerpt":"","text":".gitattributes基本用法 1.设置行尾字符： 你可以设置文本文件在检出时应该使用哪种行尾字符(LF、CRLF 或 auto)。这对于跨平台项目特别有用，因为 Windows 通常使用 CRLF 行尾，而 Unix 和 Linux 通常使用 LF 行尾。text&#x3D;auto或者针对特定文件或目录： 12somefile.txt text eol=lfsubdir/ text eol=crlf 2.识别文本和二进制文件： Git 默认会尝试将文件识别为文本或二进制文件，但你可以通过 .gitattributes 文件来明确指定。 12*.png binary# 或者*.png -text 3.合并策略： 对于合并冲突，你可以为特定文件或目录设置不同的合并策略。使用自定义的合并工具 1*.c merge=mytool 4.差异算法： 你可以为某些文件指定特定的差异算法，以改进 Git 显示的差异。使用 word-diff 算法 1*.doc diff=word 5.导出过滤器： 当使用 git archive 命令创建归档时，你可以指定过滤器来修改导出的文件内容。 6.Smudge&#x2F;Clean 过滤器： 你可以设置 smudge 和 clean 过滤器，这些过滤器会在检出和提交时分别应用，用于修改文件内容。例如，你可以使用这些过滤器来加密和解密文件，或者在检出时自动转换文件格式。 7.语言识别： 通过 .gitattributes 文件,Git 可以更好地识别某些文件的语言，从而改进代码统计和语法高亮等功能。 为了使用 .gitattributes 文件，你需要将其放置在仓库的根目录或任何子目录中。如果文件位于子目录中，它只会影响该子目录及其子目录中的文件。还可以在 .gitattributes 文件中使用模式匹配来指定哪些文件或目录应该应用这些属性。 .gitattributes 文件的更改不会影响已经提交到 Git 仓库的文件内容。这些更改只会影响未来的检出和提交操作。 gitattributes文件示例：123456* text=auto*.txt text*.jpg -text*.vcproj text eol=crlf*.sh text eol=lf*.py eol=lf 说明： 第1行，对任何文件，设置text&#x3D;auto，表示文件的行尾自动转换。如果是文本文件，则在文件入Git库时，行尾自动转换为LF。如果已经在入Git库中的文件的行尾为CRLF，则该文件在入Git库时，不再转换为LF。 第2行，对于txt文件，标记为文本文件，并进行行尾规范化。 第3行，对于jpg文件，标记为非文本文件，不进行任何的行尾转换。 第4行，对于vcproj文件，标记为文本文件，在文件入Git库时进行规范化，即行尾为LF。但是在检出到工作目录时，行尾自动转换为CRLF。 第5行，对于sh文件，标记为文本文件，在文件入Git库时进行规范化，即行尾为LF。在检出到工作目录时，行尾也不会转换为CRLF（即保持LF）。 第6行，对于py文件，只针对工作目录中的文件，行尾为LF。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"lvgl仿真","slug":"linux/lvgl_linux","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:07:34.592Z","comments":true,"path":"2024/12/26/linux/lvgl_linux/","permalink":"http://example.com/2024/12/26/linux/lvgl_linux/","excerpt":"","text":"lvgl linux编译报错处修改 makefile lv_conf.h 123#define LV_USE_ASSERT_MEM_INTEGRITY 0#define LV_USE_LOTTIE 0#define LV_USE_VECTOR_GRAPHIC 0 添加触摸1#define LV_USE_EVDEV 1 1lv_indev_t *touch = lv_evdev_create(LV_INDEV_TYPE_POINTER, &quot;/dev/input/event1&quot;);","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"lvgl","slug":"lvgl","permalink":"http://example.com/tags/lvgl/"}]},{"title":"树莓派","slug":"linux/raspberrypi","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:07:41.087Z","comments":true,"path":"2024/12/26/linux/raspberrypi/","permalink":"http://example.com/2024/12/26/linux/raspberrypi/","excerpt":"","text":"开机 格式化SD卡 镜像烧录（如果失败需要覆盖格式化SD卡） boot文件夹下添加ssh空文件 ssh连接 ssh pi@ip 远程桌面sodu apt-get install xrdp wifi 编辑 wpa_supplicant.conf1sudo nano /etc/wpa_supplicant/wpa_supplicant.conf 添加以下内容（替换为你的 Wi-Fi 信息）：1network=&#123; ssid=&quot;你的Wi-Fi名称&quot; psk=&quot;你的Wi-Fi密码&quot; key_mgmt=WPA-PSK &#125; 重启网络服务1sudo wpa_cli -i wlan0 reconfigure 时区输入以下命令查看可用时区列表： 12timedatectl list-timezonestimedatectl list-timezones | grep Asia 找到您想要设置的时区，然后使用以下命令进行设置，将Europe&#x2F;Berlin替换为您的时区： 1sudo timedatectl set-timezone Asia/Shanghai 设置完成后，您可以使用以下命令确认时区已经更改： 1timedatectl 寻找主机名raspberrypi 1ping raspberrypi","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"raspberrypi","slug":"raspberrypi","permalink":"http://example.com/tags/raspberrypi/"}]},{"title":"Makefile","slug":"linux/makefile","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:07:37.461Z","comments":true,"path":"2024/12/26/linux/makefile/","permalink":"http://example.com/2024/12/26/linux/makefile/","excerpt":"","text":"Makefile语法参考 生成部分建文件夹12345678910OBJECTS += $(addprefix $(BUILD_DIR)/,$(ASM_SOURCES:.s=.o))vpath %.s $(sort $(dir $(ASM_SOURCES)))$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) @mkdir -p $(dir $@) $(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(&lt;:.c=.lst) $&lt; -o $@ @mkdir -p $(dir $(BUILD_DIR)/$&lt;) # $(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(&lt;:.c=.lst) $&lt; -o $(BUILD_DIR)/$(&lt;:.c=.o) 通配符 12C_SOURCES = \\$(wildcard Template/*.c) \\ 排除 1C_SOURCES := $(filter-out APP/glyc.c, $(C_SOURCES)) 反汇编 12$(TARGET_ASM): $(TARGET_AXF) arm-none-eabi-objdump -d $&lt; &gt; $@ 生成库 1ar -rc lib.a 1.o 2.o ... 条件 123456OS = 1ifeq ($(OS),1)###else###endif 关键字 123addprefix加前缀wildcard通配filter-out排除 增加用量显示 1-Wl,--print-memory-usage 命令合并 其他 12345678910111213141516171819202122232425262728all clean ocd_flash ocd_flash_softdevice: make -C $(DIR) $@openocd: openocd -f interface/ADAPTER.cfg -f board/MYBOARD.cfg# makefile添加debug: openocd -f openocd.cfg &amp; &quot;C:\\Program Files (x86)\\GNU Arm Embedded Toolchain\\9 2020-q2-update\\bin/arm-none-eabi-gdb&quot; ./_build/$(TARGETS).out -ex &quot;target remote localhost:3333&quot; exit: @taskkill -f -im openocd.exedownload: @echo &quot;h&quot; &gt; jlink.cfg @echo &quot;loadfile&quot; $(BUILD)/$(TARGET).hex &gt;&gt; jlink.cfg @echo &quot;r&quot; &gt;&gt; jlink.cfg @echo &quot;qc&quot; &gt;&gt; jlink.cfg @$(JLINKEXE) -device $(CHIP) -Speed 4000 -IF SWD -CommanderScript jlink.cfg @$(RM) jlink.cfg#系统判断：ifeq ($(OS),Windows_NT) RM = rmdir /s /qelse RM = rm -rfendif F303discovery123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247########################################################################################################################### File automatically-generated by tool: [projectgenerator] version: [3.11.2] date: [Fri Dec 03 14:33:59 CST 2021]########################################################################################################################### ------------------------------------------------# Generic Makefile (based on gcc)## ChangeLog :# 2017-02-10 - Several enhancements + project update mode# 2015-07-22 - first version# ------------------------------------------------####################################### target######################################TARGET = F303####################################### building variables####################################### debug build?DEBUG = 1# optimizationOPT = -Og######################################## paths######################################## Build pathBUILD_DIR = build####################################### source####################################### C sourcesC_SOURCES = \\startup_stm32.c \\Core/Src/main.c \\Core/Src/gpio.c \\Core/Src/i2c.c \\Core/Src/spi.c \\Core/Src/usb.c \\Core/Src/usart.c \\Core/Src/stm32f3xx_it.c \\Core/Src/stm32f3xx_hal_msp.c \\Core/Src/system_stm32f3xx.c \\STM32F3-Discovery/stm32f3_discovery.c \\STM32F3-Discovery/stm32f3_discovery_gyroscope.c \\STM32F3-Discovery/stm32f3_discovery_accelerometer.c# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_ll_usb.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_i2c.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_i2c_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_rcc.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_rcc_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_gpio.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_dma.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_cortex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pwr.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pwr_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_flash.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_flash_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_exti.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_spi.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_spi_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_tim.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_tim_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_uart.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_uart_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd_ex.cC_SOURCES+=$(wildcard components/commmon/*.c) \\$(wildcard components/i3g4250d/*.c) \\$(wildcard components/l3gd20/*.c) \\$(wildcard components/lsm303agr/*.c) \\$(wildcard components/lsm303dlhc/*.c) \\$(wildcard imu/*.c)# ASM sourcesASM_SOURCES = \\# startup_stm32f303xc.s######################################## binaries#######################################PREFIX = arm-none-eabi-# The gcc compiler bin path can be either defined in make command via GCC_PATH variable (&gt; make GCC_PATH=xxx)# either it can be added to the PATH environment variable.GCC_PATH = &quot;C:\\Program Files (x86)\\GNU Arm Embedded Toolchain\\9 2020-q2-update\\bin&quot;ifdef GCC_PATHCC = $(GCC_PATH)/$(PREFIX)gccAS = $(GCC_PATH)/$(PREFIX)gcc -x assembler-with-cppCP = $(GCC_PATH)/$(PREFIX)objcopySZ = $(GCC_PATH)/$(PREFIX)sizeAR = $(GCC_PATH)/$(PREFIX)arMP = $(GCC_PATH)/$(PREFIX)objdumpelseCC = $(PREFIX)gccAS = $(PREFIX)gcc -x assembler-with-cppCP = $(PREFIX)objcopySZ = $(PREFIX)sizeAR = $(PREFIX)arendifHEX = $(CP) -O ihexBIN = $(CP) -O binary -S ######################################## CFLAGS######################################## cpuCPU = -mcpu=cortex-m4# fpuFPU = -mfpu=fpv4-sp-d16# float-abiFLOAT-ABI = -mfloat-abi=hard# mcuMCU = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)# macros for gcc# AS definesAS_DEFS = # C definesC_DEFS = \\-DUSE_HAL_DRIVER \\-DSTM32F303xC# AS includesAS_INCLUDES = # C includesC_INCLUDES = \\-ICore/Inc \\-IDrivers/STM32F3xx_HAL_Driver/Inc \\-IDrivers/STM32F3xx_HAL_Driver/Inc/Legacy \\-IDrivers/CMSIS/Device/ST/STM32F3xx/Include \\-IDrivers/CMSIS/Include \\-ISTM32F3-Discovery \\-Icomponents/l3gd20 \\-Icomponents/lsm303agr \\-Icomponents/lsm303dlhc \\-Icomponents/i3g4250d \\-Iimu# compile gcc flagsASFLAGS = $(MCU) $(AS_DEFS) $(AS_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sectionsCFLAGS = $(MCU) $(C_DEFS) $(C_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sectionsifeq ($(DEBUG), 1)CFLAGS += -g -gdwarf-2endif# Generate dependency informationCFLAGS += -MMD -MP -MF&quot;$(@:%.o=%.d)&quot;######################################## LDFLAGS######################################## link scriptLDSCRIPT = STM32F303VCTx_FLASH.ld# librariesLIBS = -lc -lm -lnosys LIBS += Drivers/STM32F303VCTx.libLIBDIR =LDFLAGS = $(MCU) -specs=nano.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections# default action: build allall: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).binDrivers/STM32F303VCTx.lib: lib######################################## build the application######################################## list of objectsOBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(C_SOURCES:.c=.o)))vpath %.c $(sort $(dir $(C_SOURCES)))# list of ASM program objectsOBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES:.s=.o)))vpath %.s $(sort $(dir $(ASM_SOURCES)))$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) $(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(&lt;:.c=.lst)) $&lt; -o $@$(BUILD_DIR)/%.o: %.s Makefile | $(BUILD_DIR) $(AS) -c $(CFLAGS) $&lt; -o $@$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile $(CC) $(OBJECTS) $(LDFLAGS) -o $@ $(SZ) $@$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR) $(HEX) $&lt; $@ $(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR) $(BIN) $&lt; $@ $(BUILD_DIR): mkdir $@ ######################################## clean up#######################################clean: -rm -fR $(BUILD_DIR) ocd_flash: $(BUILD_DIR)/$(TARGET).hex openocd -f openocd.cfg -c &quot;program $^ verify reset exit&quot;debug: openocd -f openocd.cfg &amp; &quot;C:\\Program Files (x86)\\GNU Arm Embedded Toolchain\\9 2020-q2-update\\bin/arm-none-eabi-gdb&quot; $(BUILD_DIR)/$(TARGET).elf -ex &quot;target remote localhost:3333&quot; exit: @taskkill -f -im openocd.exedump: $(MP) -d $(BUILD_DIR)/$(TARGET).elf &gt; dump.txtexport CFLAGS CC AR BUILD_DIRlib libclean: make -C Drivers $@ ######################################## dependencies#######################################-include $(wildcard $(BUILD_DIR)/*.d)# *** EOF *** Drivers&#x2F;makefile1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#$(wildcard STM32F3xx_HAL_Driver/Src/*.c)LIB_SOURCES+= \\STM32F3xx_HAL_Driver/Src/stm32f3xx_ll_usb.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_i2c.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_i2c_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_rcc.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_rcc_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_gpio.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_dma.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_cortex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pwr.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pwr_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_flash.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_flash_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_exti.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_spi.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_spi_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_tim.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_tim_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_uart.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_uart_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd_ex.cC_INCLUDES = \\-I../Core/Inc \\-ISTM32F3xx_HAL_Driver/Inc \\-ISTM32F3xx_HAL_Driver/Inc/Legacy \\-ICMSIS/Device/ST/STM32F3xx/Include \\-ICMSIS/Include OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(LIB_SOURCES:.c=.o)))vpath %.c $(sort $(dir $(LIB_SOURCES)))# list of ASM program objects$(BUILD_DIR)/%.o: %.c $(BUILD_DIR) @$(CC) -c $(CFLAGS) $(C_INCLUDES) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(&lt;:.c=.lst)) $&lt; -o $@ @echo &quot;Compiled &quot;$&lt;&quot;\\n&quot;$(BUILD_DIR): mkdir $@ HALLIB = STM32F303VCTx.liblib: $(HALLIB)$(HALLIB):$(BUILD_DIR) $(OBJECTS) $(AR) -r $@ $(OBJECTS) libclean: rm -rf $(BUILD_DIR) rm STM32F303VCTx.lib 其他操作，打印输出输出颜色，显示命令，帮助123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150C_SRCS := C_OBJS := $(patsubst %.c,$(OBJ_FOLDER)%.o,$(notdir $(C_SRCS)))CPP_SRCS := CPP_OBJS := $(patsubst %.cpp,$(OBJ_FOLDER)%.o,$(notdir $(CPP_SRCS)))S_SRCS := S_OBJS = $(patsubst %.s,$(OBJ_FOLDER)%.o,$(filter %.s,$(notdir $(S_SRCS))))S_OBJS += $(patsubst %.S,$(OBJ_FOLDER)%.o,$(filter %.S,$(notdir $(S_SRCS))))#-------------------------------------------------------------------------------# Logging options#-------------------------------------------------------------------------------# Enable color output by default.USE_COLOR ?= 1# Normally, commands in recipes are prefixed with &#x27;@&#x27; so the command itself# is not echoed by make. But if VERBOSE is defined (set to anything non-empty),# then the &#x27;@&#x27; is removed from recipes. The &#x27;at&#x27; variable is used to control# this.ifeq &quot;$(VERBOSE)&quot; &quot;1&quot;at :=elseat := @endif# These colors must be printed with the printf command. echo won&#x27;t handle the# escape sequences.color_default = \\033[00mcolor_bold = \\033[01mcolor_red = \\033[31mcolor_green = \\033[32mcolor_yellow = \\033[33mcolor_blue = \\033[34mcolor_magenta = \\033[35mcolor_cyan = \\033[36mcolor_orange = \\033[38;5;172mcolor_light_blue = \\033[38;5;039mcolor_gray = \\033[38;5;008mcolor_purple = \\033[38;5;097mifeq &quot;$(USE_COLOR)&quot; &quot;1&quot;color_build := $(color_light_blue)color_c := $(color_green)color_cxx := $(color_green)color_cpp := $(color_orange)color_asm := $(color_magenta)color_ar := $(color_yellow)color_link := $(color_cyan)color_convert := $(color_gray)endif# Used in printmessage if the color args are not present.color_ :=# Use in recipes to print color messages if printing to a terminal. If# USE_COLOR is not set to 1, this reverts to a simple uncolorized printf.# A newline is added to the end of the printed message.## Arguments:# 1 - name of the color variable (see above), minus the &quot;color_&quot; prefix# 2 - first colorized part of the message# 3 - first uncolorized part of the message# 4 - color name for second colorized message# 5 - second colorized message# 6 - second uncolorized part of the message# 7 - uncolorized prefix on the whole line; this is last because it is expected to be used rarely## All arguments are optional.## Use like:# $(call printmessage,cyan,Building, remainder of the message...)ifeq &quot;$(USE_COLOR)&quot; &quot;1&quot;define printmessageif [ -t 1 ]; then printf &quot;$(7)$(color_$(1))$(2)$(color_default)$(3)$(color_$(4))$(5)$(color_default)$(6)\\n&quot; ; \\else printf &quot;$(7)$(2)$(3)$(5)$(6)\\n&quot; ; fiendefelsedefine printmessageprintf &quot;$(7)$(2)$(3)$(5)$(6)\\n&quot;endefendif#-------------------------------------------------------------------------------# Recipes#-------------------------------------------------------------------------------# Compile C sources.$(OBJ_FOLDER)%.o : %.c @$(call printmessage,c,Compiling, $&lt;) $(at)$(CC) $(CFLAGS) $(COMMON_FLAGS) $&lt; -o $@# Compile C++ sources.$(OBJ_FOLDER)%.o : %.cpp @$(call printmessage,cxx,Compiling, $&lt;) $(at)$(CXX) $(CXXFLAGS) $(COMMON_FLAGS) $&lt; -o $@# Preprocess and assemble .S sources.$(OBJ_FOLDER)%.o : %.S @$(call printmessage,asm,Assembling, $&lt;) $(at)$(AS) $(ASFLAGS) $(COMMON_FLAGS) $&lt; -o $@# Assemble .s sources.$(OBJ_FOLDER)%.o : %.s @$(call printmessage,asm,Assembling, $&lt;) $(at)$(AS) $(ASFLAGS) $(COMMON_FLAGS) $&lt; -o $@$(OUT_DIR):ifeq ($(OS),Windows_NT) $(at)-mkdir $(OUT_DIR)else $(at)$(shell mkdir $(OBJ_FOLDER) 2&gt;/dev/null)endif# Tool invocations$(LD_SCRIPT): $(LD_SCRIPT_IN) @$(call printmessage,cpp,Preprocessing, $&lt;) $(at)$(CPP) $(CPP_FLAGS) $(LD_CPP_FLAGS) $(INC_DIRS_F) $(CC_SYMBOLS) -MMD $&lt; -o $@$(TARGET_OUT): $(LD_SCRIPT) $(C_OBJS) $(CPP_OBJS) $(S_OBJS) @$(call printmessage,link,Linking, $@) $(at)$(LD) $(LIB_PATHS) -o $@ $(CPP_OBJS) $(C_OBJS) $(S_OBJS) $(O_OBJS) $(LIBS) $(LD_OPTIONS) $(at)$(SIZE) --totals $(TARGET_OUT) $(at)-$(NM) $(NMFLAGS) $(TARGET_OUT) &gt; $(OBJ_FOLDER)$(TARGET)-symbol-table.txt$(TARGET_HEX): $(TARGET_OUT) @$(call printmessage,convert,Converting, $@) $(at)@$(OBJCOPY) -O ihex $(TARGET_OUT) $(TARGET_HEX)$(TARGET_BIN): $(TARGET_OUT) @$(call printmessage,convert,Converting, $@) $(at)@$(OBJCOPY) -O binary $(TARGET_OUT) $(TARGET_BIN)help: @echo &quot;Useful targets:&quot; @echo &quot; - all (default)&quot; @echo &quot; - clean&quot; @echo &quot; - help&quot; @echo @echo &quot;Options:&quot; @echo &quot; - VERBOSE=&#123;0|1&#125; to show full command lines.&quot; @echo &quot; - USE_COLOR=&#123;0|1&#125; to override color output.&quot; lwip 文件生成 1234567891011TARGET=makefsdataC_INCLUDES = \\-I../../../include/ \\-I../../../../test/unit/#需要添加contrib下ports\\unix\\port\\include\\arch\\cc.hall: gcc $(C_INCLUDES) -o $(TARGET).exe makefsdata.cclean: -rm $(TARGET).exe","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"Makefile","slug":"Makefile","permalink":"http://example.com/tags/Makefile/"}]},{"title":"RTMP","slug":"linux/rtmp","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:07:45.331Z","comments":true,"path":"2024/12/26/linux/rtmp/","permalink":"http://example.com/2024/12/26/linux/rtmp/","excerpt":"","text":"Nginx RTMP推流编译选版本nginx-1.20.1,rtmp-module v1.2.0 下载123wget http://nginx.org/download/nginx-1.20.1.tar.gztar -zxvf nginx-1.20.1.tar.gzgit clone https://github.com/arut/nginx-rtmp-module.git 编译1./configure --add-module=../nginx-rtmp-module 配置1234567891011rtmp &#123; server &#123; listen 1935; # 默认的RTMP监听端口 chunk_size 4096; application live &#123; live on; record off; &#125; &#125;&#125; 推流12345ffmpeg -re -i 123.mp4 -vcodec copy -acodec copy -f flv rtmp://192.168.1.49:1935/live# 简易指令ffmpeg -i 123.mp4 -f flv rtmp://192.168.1.49:1935/live# 推流摄像头ffmpeg -f v4l2 -video_size 320x240 -framerate 15 -i /dev/video2 -q 10 -f flv rtmp://127.0.0.1/live/mytest -re 参数控制读取 AVpacket 的速度，按照帧率速度读取文件 AVpacket。如果有多个流，以最慢的帧率为准。 -vcodec copy 和 -acodec copy 用于指示 FFmpeg 在转换视频文件时不应重新编码视频和音频流，而是直接复制这些流。这可以提高转换速度，并保持原始质量。 拉流1ffplay rtmp://192.168.1.49:1935/live","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://example.com/tags/ffmpeg/"},{"name":"nginx","slug":"nginx","permalink":"http://example.com/tags/nginx/"}]},{"title":"sqlite","slug":"linux/sqlite","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:07:50.785Z","comments":true,"path":"2024/12/26/linux/sqlite/","permalink":"http://example.com/2024/12/26/linux/sqlite/","excerpt":"","text":"Sqlite下载链接SQLite3 C&#x2F;C++ 接口 API1sqlite3_open(const char *filename, sqlite3 **ppDb) 该例程打开一个指向 SQLite 数据库文件的连接，返回一个用于其他 SQLite 程序的数据库连接对象。如果 filename 参数是 NULL 或 ‘:memory:’，那么 sqlite3_open() 将会在 RAM 中创建一个内存数据库，这只会在 session 的有效时间内持续。如果文件名 filename 不为 NULL，那么 sqlite3_open() 将使用这个参数值尝试打开数据库文件。如果该名称的文件不存在，sqlite3_open() 将创建一个新的命名为该名称的数据库文件并打开。 1sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void *data, char **errmsg) 该例程提供了一个执行 SQL 命令的快捷方式，SQL 命令由 sql 参数提供，可以由多个 SQL 命令组成。在这里，第一个参数 sqlite3 是打开的数据库对象，sqlite_callback 是一个回调，data 作为其第一个参数，errmsg 将被返回用来获取程序生成的任何错误。sqlite3_exec() 程序解析并执行由 sql 参数所给的每个命令，直到字符串结束或者遇到错误为止。 1sqlite3_close(sqlite3*) 该例程关闭之前调用 sqlite3_open() 打开的数据库连接。所有与连接相关的语句都应在连接关闭之前完成。如果还有查询没有完成，sqlite3_close() 将返回 SQLITE_BUSY 禁止关闭的错误消息。 连接数据库下面的 C 代码段显示了如何连接到一个现有的数据库。如果数据库不存在，那么它就会被创建，最后将返回一个数据库对象。 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;sqlite3.h&gt;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; sqlite3_close(db);&#125; 现在，让我们来编译和运行上面的程序，在当前目录中创建我们的数据库 test.db。您可以根据需要改变路径。 $gcc test.c -l sqlite3 $./a.out Opened database successfully 如果要使用 C++ 源代码，可以按照下列所示编译代码： $g++ test.c -l sqlite3 在这里，把我们的程序链接上 sqlite3 库，以便向 C 程序提供必要的函数。这将在您的目录下创建一个数据库文件 test.db，您将得到如下结果： -rwxr-xr-x. 1 root root 7383 May 8 02:06 a.out -rw-r--r--. 1 root root 323 May 8 02:05 test.c -rw-r--r--. 1 root root 0 May 8 02:06 test.db 创建表下面的 C 代码段将用于在先前创建的数据库中创建一个表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt; static int callback(void *NotUsed, int argc, char **argv, char **azColName)&#123; int i; for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stdout, &quot;Opened database successfully\\n&quot;); &#125; /* Create SQL statement */ sql = &quot;CREATE TABLE COMPANY(&quot; \\ &quot;ID INT PRIMARY KEY NOT NULL,&quot; \\ &quot;NAME TEXT NOT NULL,&quot; \\ &quot;AGE INT NOT NULL,&quot; \\ &quot;ADDRESS CHAR(50),&quot; \\ &quot;SALARY REAL );&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, 0, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Table created successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会在 test.db 文件中创建 COMPANY 表，最终文件列表如下所示： -rwxr-xr-x. 1 root root 9567 May 8 02:31 a.out -rw-r--r--. 1 root root 1207 May 8 02:31 test.c -rw-r--r--. 1 root root 3072 May 8 02:31 test.db INSERT 操作下面的 C 代码段显示了如何在上面创建的 COMPANY 表中创建记录： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt;static int callback(void *NotUsed, int argc, char **argv, char **azColName)&#123; int i; for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create SQL statement */ sql = &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot; \\ &quot;VALUES (1, &#x27;Paul&#x27;, 32, &#x27;California&#x27;, 20000.00 ); &quot; \\ &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot; \\ &quot;VALUES (2, &#x27;Allen&#x27;, 25, &#x27;Texas&#x27;, 15000.00 ); &quot; \\ &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)&quot; \\ &quot;VALUES (3, &#x27;Teddy&#x27;, 23, &#x27;Norway&#x27;, 20000.00 );&quot; \\ &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)&quot; \\ &quot;VALUES (4, &#x27;Mark&#x27;, 25, &#x27;Rich-Mond &#x27;, 65000.00 );&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, 0, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Records created successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会在 COMPANY 表中创建给定记录，并会显示以下两行： Opened database successfully Records created successfully SELECT 操作在我们开始讲解获取记录的实例之前，让我们先了解下回调函数的一些细节，这将在我们的实例使用到。这个回调提供了一个从 SELECT 语句获得结果的方式。它声明如下： 123456typedef int (*sqlite3_callback)(void*, /* Data provided in the 4th argument of sqlite3_exec() */int, /* The number of columns in row */char**, /* An array of strings representing fields in the row */char** /* An array of strings representing column names */); 如果上面的回调在 sqlite_exec() 程序中作为第三个参数，那么 SQLite 将为 SQL 参数内执行的每个 SELECT 语句中处理的每个记录调用这个回调函数。 下面的 C 代码段显示了如何从前面创建的 COMPANY 表中获取并显示记录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt;static int callback(void *data, int argc, char **argv, char **azColName)&#123; int i; fprintf(stderr, &quot;%s: &quot;, (const char*)data); for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; const char* data = &quot;Callback function called&quot;; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create SQL statement */ sql = &quot;SELECT * from COMPANY&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, (void*)data, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Operation done successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会产生以下结果： Opened database successfully Callback function called: ID = 1 NAME = Paul AGE = 32 ADDRESS = California SALARY = 20000.0 Callback function called: ID = 2 NAME = Allen AGE = 25 ADDRESS = Texas SALARY = 15000.0 Callback function called: ID = 3 NAME = Teddy AGE = 23 ADDRESS = Norway SALARY = 20000.0 Callback function called: ID = 4 NAME = Mark AGE = 25 ADDRESS = Rich-Mond SALARY = 65000.0 Operation done successfully UPDATE 操作下面的 C 代码段显示了如何使用 UPDATE 语句来更新任何记录，然后从 COMPANY 表中获取并显示更新的记录： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt; static int callback(void *data, int argc, char **argv, char **azColName)&#123; int i; fprintf(stderr, &quot;%s: &quot;, (const char*)data); for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; const char* data = &quot;Callback function called&quot;; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create merged SQL statement */ sql = &quot;UPDATE COMPANY set SALARY = 25000.00 where ID=1; &quot; \\ &quot;SELECT * from COMPANY&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, (void*)data, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Operation done successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会产生以下结果： Opened database successfully Callback function called: ID = 1 NAME = Paul AGE = 32 ADDRESS = California SALARY = 25000.0 Callback function called: ID = 2 NAME = Allen AGE = 25 ADDRESS = Texas SALARY = 15000.0 Callback function called: ID = 3 NAME = Teddy AGE = 23 ADDRESS = Norway SALARY = 20000.0 Callback function called: ID = 4 NAME = Mark AGE = 25 ADDRESS = Rich-Mond SALARY = 65000.0 Operation done successfully DELETE 操作下面的 C 代码段显示了如何使用 DELETE 语句删除任何记录，然后从 COMPANY 表中获取并显示剩余的记录： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt; static int callback(void *data, int argc, char **argv, char **azColName)&#123; int i; fprintf(stderr, &quot;%s: &quot;, (const char*)data); for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; const char* data = &quot;Callback function called&quot;; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create merged SQL statement */ sql = &quot;DELETE from COMPANY where ID=2; &quot; \\ &quot;SELECT * from COMPANY&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, (void*)data, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Operation done successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会产生以下结果： Opened database successfully Callback function called: ID = 1 NAME = Paul AGE = 32 ADDRESS = California SALARY = 20000.0 Callback function called: ID = 3 NAME = Teddy AGE = 23 ADDRESS = Norway SALARY = 20000.0 Callback function called: ID = 4 NAME = Mark AGE = 25 ADDRESS = Rich-Mond SALARY = 65000.0 Operation done successfully 使用sqlite3指令SELECT * FROM COMPANY;可以查看数据列表 Select 语句SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。 语法SQLite 的 SELECT 语句的基本语法如下： SELECT column1, column2, columnN FROM table_name; SELECT * FROM table_name; Schema 信息因为所有的点命令只在 SQLite 提示符中可用，所以当您进行带有 SQLite 的编程时，您要使用下面的带有 sqlite_master 表的 SELECT 语句来列出所有在数据库中创建的表： 1sqlite&gt; SELECT tbl_name FROM sqlite_master WHERE type = &#x27;table&#x27;; 您可以列出关于 COMPANY 表的完整信息，如下所示： 1sqlite&gt; SELECT sql FROM sqlite_master WHERE type = &#x27;table&#x27; AND tbl_name = &#x27;COMPANY&#x27;; Like 子句SQLite 的 LIKE 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用： 百分号 （%） 下划线 （_） 百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。 Glob 子句SQLite 的 GLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。 星号 （*） 问号 （?） 星号（*）代表零个、一个或多个数字或字符。问号（?）代表一个单一的数字或字符。这些符号可以被组合使用。 Where 子句SQLite的 WHERE 子句用于指定从一个表或多个表中获取数据的条件。 如果满足给定的条件，即为真（true）时，则从表中返回特定的值。您可以使用 WHERE 子句来过滤记录，只获取需要的记录。 WHERE 子句不仅可用在 SELECT 语句中，它也可用在 UPDATE、DELETE 语句中，等等 Update 语句SQLite 的 UPDATE 查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。 Distinct 关键字SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。 有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。 事务控制使用下面的命令来控制事务： BEGIN ：开始事务处理。 COMMIT：保存更改，或者可以使用 END TRANSACTION 命令。 ROLLBACK：回滚所做的更改。 事务控制命令只与 DML 命令 INSERT、UPDATE 和 DELETE 一起使用。他们不能在创建表或删除表时使用，因为这些操作在数据库中是自动提交的。 BEGIN 命令事务（Transaction）可以使用BEGIN 命令来启动。此类事务通常会持续执行下去，直到遇到下一个 COMMIT 或 ROLLBACK 命令。不过在数据库关闭或发生错误时，事务处理也会回滚。 COMMIT 命令COMMIT 命令是用于把事务调用的更改保存到数据库中的事务命令。自上次 COMMIT 或 ROLLBACK 命令以外的所有事务保存到数据库。 ROLLBACK 命令ROLLBACK 命令是用于撤消尚未保存到数据库的事务的事务命令。 ROLLBACK 命令只能用于撤销自上次发出 COMMIT 或 ROLLBACK 命令以外的事务。 实例开始一个事务，并从表中删除 age &#x3D; 25 的记录，最后，我们使用 ROLLBACK 命令撤消所有的更改。 123sqlite&gt; BEGIN;sqlite&gt; DELETE FROM COMPANY WHERE AGE = 25;sqlite&gt; ROLLBACK; 检查 COMPANY 表，仍然有记录 开始另一个事务，从表中删除 age &#x3D; 25 的记录，最后我们使用 COMMIT 命令提交所有的更改。 123sqlite&gt; BEGIN;sqlite&gt; DELETE FROM COMPANY WHERE AGE = 25;sqlite&gt; COMMIT; 基础操做 显示表1.tables 显示概要1.schema sqlite_master 格式化显示123456789显示头sqlite&gt;.header on按列显示sqlite&gt;.mode column显示运行时间sqlite&gt;.timer on设置输出列的宽度sqlite&gt;.width 10, 20, 10sqlite&gt;SELECT * FROM COMPANY; 主键自动增加&#x2F;&#x2F;历史最大值增加1ID INTEGER PRIMARY KEY AUTOINCREMENT 删除表1drop table company; 增加列12alter table company add column DATE char(20);alter table company add column TIME char(10); 删除列1alter table company drop column test; 添加时间日期1insert into company values(6,&#x27;huang&#x27;,31,&#x27;guangzhou&#x27;,8999,date(&#x27;now&#x27;,&#x27;localtime&#x27;),time(&#x27;now&#x27;,&#x27;localtime&#x27;)); 自动时间123...DATE TIMESTAMP NOT NULL DEFAULT(date(&#x27;now&#x27;,&#x27;localtime&#x27;)),TIME TIMESTAMP NOT NULL DEFAULT(time(&#x27;now&#x27;,&#x27;localtime&#x27;)) 筛选时间1select * from company where time &gt;time(&#x27;12:00:00&#x27;); 修改内容1update company set name=&#x27;gcc&#x27; where id=18; 去重1SELECT DISTINCT name FROM COMPANY; 筛选计数1SELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2; 排序1SELECT * FROM COMPANY ORDER BY SALARY ASC; 字符加前缀1update work set date=&#x27;2024-&#x27;||date; 列求和1select sum(time) from work;","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"ssh和git","slug":"linux/ssh","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:07:54.195Z","comments":true,"path":"2024/12/26/linux/ssh/","permalink":"http://example.com/2024/12/26/linux/ssh/","excerpt":"","text":"ssh免密登录秘钥加入主机1ssh-copy-id 重启服务123sudo systemctl restart sshsudo server ssh restart 测试连接server 1/usr/sbin/sshd -d -p 2222 client 1ssh ... -p 2222 新用户ssh登录123456sudo useradd gitsudo passwd gitsudo chmod 700 .sshsudo chmod 600 authorized_keyssudo chmod 755 /home/username Git服务 新建仓库1git init --bare test 客户端1git clone git@192.168.1.10：/home/git/test 客户端现有文件夹1234git add --all .git commit -m &quot;test project init&quot;git remote add origin git@192.168.1.10：/home/git/testgit push origin master Gitlab参考 树莓派gitlab下载 安装依赖 1sudo apt-get install curl openssh-server ca-certificates postfix apt-transport-https 安装包 1sudo dpkg -i gitlab-ce_8.13.0-ce.0_armhf.deb 运行 1sudo gitlab-ctl reconfigure 修改服务端口默认使用80端口，如果需要修改，可以修改&#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb 常用维护指令 1234567891011121314151617181920#修改任何配置文件后都要输入如下命令使配置生效。sudo gitlab-ctl reconfigure #页面缓存清除：sudo gitlab-rake cache:clear RAILS_ENV=production #GitLab各组件启动：sudo gitlab-ctl start #GitLab各组件停止：sudo gitlab-ctl stop #GitLab各组件重启：sudo gitlab-ctl restart #禁用GitLab开机自启动：sudo systemctl disable gitlab-runsvdir #启用GitLab开机自启动：sudo systemctl enable gitlab-runsvdir Gitea轻量化，占用资源少,在树莓派上安装和运行Gitea，可以遵循以下步骤： 更新系统包并安装必要的依赖： 12sudo apt-get updatesudo apt-get install -y curl policycoreutils openssh-server 下载Gitea二进制文件： 1curl -L https://github.com/go-gitea/gitea/releases/download/v1.20.0/gitea-linux-arm64 -o gitea 使二进制文件可执行： 1chmod +x gitea 移动Gitea到&#x2F;usr&#x2F;local&#x2F;bin目录并创建一个systemd服务文件： 12sudo mv gitea /usr/local/bin/giteasudo nano /etc/systemd/system/gitea.service 在gitea.service文件中添加以下内容： 123456789101112131415[Unit]Description=Gitea (Git with a cup of tea)After=syslog.targetAfter=network.target [Service]RestartSec=2sType=simpleUser=rootExecStart=/usr/local/bin/gitea web --config /etc/gitea/app.iniRestart=alwaysEnvironment=USER=root [Install]WantedBy=multi-user.target 重新加载systemd守护进程，使其识别新的服务文件，并启动Gitea服务： 123sudo systemctl daemon-reloadsudo systemctl start giteasudo systemctl enable gitea 配置防火墙允许访问Gitea： 12sudo ufw allow &#x27;Nginx Full&#x27;sudo ufw enable 访问http:&#x2F;&#x2F;:3000来设置和运行Gitea。 修改配置初次修改，通过网页选择custom&#x2F;conf&#x2F;app.ini 文件夹大小 1du -sh Gitea 修改远程仓库 1git remote set-url origin https://gitee.com/gxswift/ctest.git","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"ssh","slug":"ssh","permalink":"http://example.com/tags/ssh/"}]},{"title":"思考","slug":"linux/think","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T10:50:55.891Z","comments":true,"path":"2024/12/26/linux/think/","permalink":"http://example.com/2024/12/26/linux/think/","excerpt":"题目农民把3000斤萝卜送到1000公里外去卖,骆驼最高载重1000斤,而骆驼每走一公里就要吃掉一斤萝卜,问农民最多可以卖掉多少斤萝卜?","text":"题目农民把3000斤萝卜送到1000公里外去卖,骆驼最高载重1000斤,而骆驼每走一公里就要吃掉一斤萝卜,问农民最多可以卖掉多少斤萝卜? 这道题一开始看上去好像是无解的，因为你的骆驼每一公里就要消耗一斤萝卜，而到目的地有1000公里，而骆驼最多只能装1000斤萝卜。如果你的骆驼可以全部装下，到目的地也会被全部吃光，一丁点也不剩。所以，很多人的第一反应都是觉得这个不太可能。 如果一开始就觉得不太可能的话，这是很正常的。我一开始也觉得不可能，思考下去，后来想到一个解法可以运送500斤萝卜到市场方法如下: 1、装1000斤萝卜，走250公里，扔下500斤回去 2、装1000斤萝卜，走250公里，拿起250斤萝卜，走到500公里处，扔下500斤回去 3、装1000斤萝卜，走到500公里处，装上500斤走到目的地**于是有了500斤运到市场 好像很不错了，不过还有更好的方法能运更多萝卜。 解答:抽象解答使用递推公式: 12345f(1) = 1 f(2) = f(1) + 1/3 f(3) = f(2) + 1/5 … f(n) = f(n-1) + 1/(2*n+1) 通项公式: f(n) = Σ(1/(2*i)+1) (1 &lt;= i &lt;=n) 题目对应是能走的最远距离减去已知的距离，即 (f(3) – 1) * 1000 &#x3D; 533 就是说最多可以运533斤萝卜具体如下： 1、装1000斤萝卜，走200公里，扔下600斤回去 2、装1000斤萝卜，走200公里，装200斤，再走333公里，扔下334斤，往回走 3、走到200公里处，装上200斤，回去，此时200公里处还剩200斤 4、装1000斤萝卜，走至200公里处，装200斤，走至533公里处，装334斤，走到终点，剩533斤 这是之前遇到的一个面试题","categories":[],"tags":[{"name":"思考","slug":"思考","permalink":"http://example.com/tags/%E6%80%9D%E8%80%83/"}]},{"title":"VIM","slug":"linux/vim","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:08:03.934Z","comments":true,"path":"2024/12/26/linux/vim/","permalink":"http://example.com/2024/12/26/linux/vim/","excerpt":"","text":"vim操作 移动追加删除复制粘贴查找多文件操作其他 指令 含义 例子 移动 l or 右箭头 向右移动一个字符 h or 左箭头 向左移动一个字符 j or 下箭头 向下移动一行 k or 上箭头 向上移动一行 0 (零按键) 移动到当前行的行首。 ^ 移动到当前行的第一个非空字符。 $ 移动到当前行的末尾。 w 移动到下一个单词或标点符号的开头。 W 移动到下一个单词的开头，忽略标点符号。 b 移动到上一个单词或标点符号的开头。 B 移动到上一个单词的开头，忽略标点符号。 Ctrl-f or Page Down 向下翻一页 Ctrl-b or Page Up 向上翻一页 Ctrl-d 向下翻半页 Ctrl-u 向上翻半页 numberG or number 移动到第number 行。 1(G) 移动到文件的第一行,命令前加数字，为命令执行次数 G 移动到文件末尾。 追加 i 光标前插入 I 行前插入 a 光标后插入 A 行后插入 o 当前行的下方打开一行。 O 当前行的上方打开一行。 删除 x 当前字符 3x当前字符及其后的两个字符。 dd 当前行。 5dd 当前行及随后的四行文本。 dW 从光标位置开始到下一个单词的开头。 d$ 从光标位置开始到当前行的行尾。 d0 从光标位置开始到当前行的行首。 d^ 从光标位置开始到文本行的第一个非空字符。 dG 从当前行到文件的末尾。 d20G 从当前行到文件的第20 行。 复制粘贴 yy 当前行。 5yy 当前行及随后的四行文本。 yW 从当前光标位置到下一个单词的开头。 y$ 从当前光标位置到当前行的末尾。 y0 从当前光标位置到行首。 y^ 从当前光标位置到文本行的第一个非空字符。 yG 从当前行到文件末尾。 y20G 从当前行到文件的第20 行。 p 粘贴到当前行的下面 查找和替换 &#x2F; 查找 &#x2F;foo查找foo，\\c表示大小写不敏感查找，\\C表示大小写敏感查找 n 下一个 N 前一个 s 替换{作用范围}s&#x2F;{目标}&#x2F;{替换}&#x2F;{替换标志} %s&#x2F;foo&#x2F;bar&#x2F;g会在全局范围(%)查找foo并替换为bar，所有出现都会被替换(g) s&#x2F;foo&#x2F;bar&#x2F;g替换当前行 %s&#x2F;foo&#x2F;bar&#x2F;i。i表示大小写不敏感查找，I表示大小写敏感，%表示第一行到最后一行，或者用1,5代替 多文件操作 n 下一个文件 N 前一个文件 buffers 查看文件列表 其他 J 删除当前行最后回车，连接下一行 w 写入 q 退出 ! 强制","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://example.com/tags/vim/"}]},{"title":"TFTP NFS","slug":"linux/tftp","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:07:56.991Z","comments":true,"path":"2024/12/26/linux/tftp/","permalink":"http://example.com/2024/12/26/linux/tftp/","excerpt":"","text":"NFS安装NFS软件包 12sudo apt-get install nfs-kernel-server #安装服务器sudo apt-get install nfs-common #安装客户端 添加共享目录 12sudo vi /etc/exports #打开文件/nfsroot *(rw,sync,no_root_squash)#将/nfsroot 目录设置为NFS共享目录 ，*代表允许任意IP访问 建立文件夹，设置权限 123sudo mkdir /nfsrootsudo chmod -R 777 /nfsrootsudo chown -R nobody /nfsroot 启动NFS服务 1sudo /etc/init.d/nfs-kernel-server start #重启restart 客户端挂载 1sudo mount -t nfs 192.168.123.123:/nfs /mnt -o nolock TFTPtftpd或xinetd 安装软件包1sudo apt-get install tftpd-hpa tftp-hpa #安装服务器和客户端 配置12345678910111213141516sudo vi /etc/default/tftp-hpa #打开文件sudo vi /etc/xinetd.d/tftpservice tftp&#123; socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s /tftpboot disable = no per_source = 11 cps = 100 2 flags = IPv4&#125; 建立文件夹，设置权限123sudo mkdir /tftpsudo chmod -R 777 /tftpsudo chown -R nobody /tftp 启动NFS服务123sudo service tftpd-hpa start #重启restartsudo service xinetd start 客户端挂载1234&gt;tftp ip#连接&gt;get file#下载&gt;put file#上传&gt;q#退出","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"TFTP","slug":"TFTP","permalink":"http://example.com/tags/TFTP/"},{"name":"NFS","slug":"NFS","permalink":"http://example.com/tags/NFS/"}]},{"title":"i.mx6ull开发板","slug":"linux/zdyz","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T11:08:08.896Z","comments":true,"path":"2024/12/26/linux/zdyz/","permalink":"http://example.com/2024/12/26/linux/zdyz/","excerpt":"","text":"正点原子i.mx6ull开发板练习WIFI开启网卡12ifconfig wlan0 up // 若默认没打开 wlan0 则需要执行此项。ifconfig 搜索12wpa_cli -i wlan0 scan_result // 此指令需要启动进入后再插 WIFI 才生效，需要 wpa_supplicant 在运行。 连接1source ./alientek_usb_wifi_setup.sh -m station -i ALIENTEK-YF -p 1590202**** -d wlan0 参数解释： -m station ：设置成 station 模式 -i ALIENTEK-YF ：无线网络名称(ssid)。 -p 1590202**** ：无线网络密码(psk)。 -d wlan0 ：USB WIFI 节点 例如: 1source ./shell/wifi/alientek_usb_wifi_setup.sh -m station -i senmun2022 -p senmun150@ -d wlan0 Ubuntu桥接,设置ip为同网段 1sudo mount -t nfs 192.168.1.100:/home/alientek/linux/nfs /mnt -o nolock 提示mount.nfs: an incorrect mount option was specified 1sudo mount -t nfs -o vers=4 192.168.1.100:/home/alientek/linux/nfs /mnt 描述1/home/alientek/linux/nfs *(rw,sync,no_root_squash) 编译环境 1source /opt/fsl-imx-x11/4.1.15-2.1.0/environment-setup-cortexa7hf-neon-poky-linux-gnueabi 编译文件路径 开机启动项&#x2F;etc&#x2F;rc.local 开机启动程序#注释 1/opt/QDesktop &gt;/dev/null 2&gt;&amp;1 设置IP1234PATH=/sbin:/bin:/usr/sbin:/usr/binifconfig eth0 192.168.1.115 netmask 255.255.255.0route add default gw 192.168.1.1echo &quot;nameserver 114.114.114.114&quot; &gt; /etc/resolv.conf QT摄像头人脸识别12345678910111213141516171819202122232425262728int main()&#123; //-------------------------------------------------- //添加人脸识别 cv::CascadeClassifier faceCascade; // 级联分类器 faceCascade.load(&quot;Resources/haarcascade_frontalface_default.xml&quot;); // 加载训练好的haar人脸正脸xml配置文件 if (faceCascade.empty()) &#123; printf( &quot;XML file not loaded\\n&quot;); &#125; else &#123; std::vector&lt;cv::Rect&gt; faces; // 人脸的矩形数组 faceCascade.detectMultiScale(frame, faces, 1.1, 3); // 比例因子 人脸大小 if(faces.size() &gt; 0) &#123; for (int i = 0; i &lt; faces.size(); i++) &#123; rectangle(frame, faces[i].tl(), faces[i].br(), cv::Scalar(255, 0, 255), 2); // 在原图上绘制人脸矩形区域，颜色为粉色，线条厚度为3像素 &#125; &#125; &#125; //--------------------------------------------------&#125;-lopencv_objdetect 文件颜色白色：表示普通文件 蓝色：表示目录（文件夹） 绿色：表示可执行文件 红色：表示压缩文件，文件包。 粉红色：图片；Socket文件 浅蓝色：链接文件（软链接，硬链接） 红色闪烁：表示链接的文件有问题 黄色：表示设备文件（ /dev目录下：物理块设备(b)、字符终端设备?） 灰色：表示其他文件 青黄色 ：管道文件 ( p) 网页禁止复制解除win: 在控制台F12页面Sources 快捷键 ctrl+shift+p 然后输入 javascript 找到 disabled javaScript.","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]}],"categories":[{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"makefile","slug":"makefile","permalink":"http://example.com/tags/makefile/"},{"name":"gcc","slug":"gcc","permalink":"http://example.com/tags/gcc/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"lvgl","slug":"lvgl","permalink":"http://example.com/tags/lvgl/"},{"name":"raspberrypi","slug":"raspberrypi","permalink":"http://example.com/tags/raspberrypi/"},{"name":"Makefile","slug":"Makefile","permalink":"http://example.com/tags/Makefile/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://example.com/tags/ffmpeg/"},{"name":"nginx","slug":"nginx","permalink":"http://example.com/tags/nginx/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"ssh","slug":"ssh","permalink":"http://example.com/tags/ssh/"},{"name":"思考","slug":"思考","permalink":"http://example.com/tags/%E6%80%9D%E8%80%83/"},{"name":"vim","slug":"vim","permalink":"http://example.com/tags/vim/"},{"name":"TFTP","slug":"TFTP","permalink":"http://example.com/tags/TFTP/"},{"name":"NFS","slug":"NFS","permalink":"http://example.com/tags/NFS/"}]}