{"meta":{"title":"gx的博客","subtitle":"","description":"","author":"GX","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2024-12-26T06:50:26.976Z","updated":"2024-12-26T06:50:26.976Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-12-26T06:55:05.440Z","updated":"2024-12-26T06:55:05.440Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-12-28T01:42:09.470Z","updated":"2024-12-28T01:42:09.470Z","comments":true,"path":"me/index.html","permalink":"http://example.com/me/index.html","excerpt":"","text":"简介嵌入式技术笔记 单片机，nrf51&#x2F;52蓝牙，esp8266&#x2F;32wifi 编译链gcc为主,调试工具openocd,pyocd,rtt，编译工具makefile,cmake,ninja,IDE keil GUI:lvgl，emwin lwip usb fat16&#x2F;32 opencv linux 其他 nodejs python"}],"posts":[{"title":"git命令","slug":"linux/git","date":"2222-12-22T01:43:25.000Z","updated":"2024-12-30T06:57:16.527Z","comments":true,"path":"2222/12/22/linux/git/","permalink":"http://example.com/2222/12/22/linux/git/","excerpt":"","text":"git命令仓库1234567891011# 在当前目录新建一个Git代码库$ git init # 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 远程仓库$ git init --bare &lt;directory&gt;# 下载一个项目和它的整个代码历史$ git clone [url] 配置123456789101112131415161718# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 输出、设置基本的全局变量$ git config --global user.email$ git config --global user.name$ git config --global user.email &quot;MyEmail@gmail.com&quot;$ git config --global user.name &quot;My Name&quot;# 定义当前用户所有提交使用的作者邮箱。$ git config --global alias.&lt;alias-name&gt; &lt;git-command&gt;# 为Git命令创建一个快捷方式（别名）。$ git config --system core.editor &lt;editor&gt; 增删文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录$ git add [dir] # 添加当前目录的所有文件到暂存区$ git add . # 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p # 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message] # 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a # 提交时显示所有diff信息$ git commit -v # 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch # 列出所有远程分支$ git branch -r # 列出所有本地分支和远程分支$ git branch -a # 新建一个分支，但依然停留在当前分支$ git branch [branch-name] # 新建一个分支，并切换到该分支$ git checkout -b [branch] # 新建一个分支，指向指定commit$ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区$ git checkout [branch-name] # 切换到上一个分支$ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支$ git merge [branch] # 选择一个commit，合并进当前分支$ git cherry-pick [commit] # 删除分支$ git branch -d [branch-name] # 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag # 新建一个tag在当前commit$ git tag [tag] # 新建一个tag在指定commit$ git tag [tag] [commit] # 删除本地tag$ git tag -d [tag] # 删除远程tag$ git push origin :refs/tags/[tagName] # 查看tag信息$ git show [tag] # 提交指定tag$ git push [remote] [tag] # 提交所有tag$ git push [remote] --tags # 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 日志123456789101112131415161718192021222324252627282930313233# 显示有变更的文件$ git status # 显示当前分支的版本历史$ git log # 显示commit历史，以及每次commit发生变更的文件$ git log --stat # 搜索提交历史，根据关键词$ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file] # 显示指定文件相关的每一次diff$ git log -p [file] # 显示过去5次提交$ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序$ git shortlog -sn # 显示指定文件是什么人在什么时间修改过$ git blame [file] 对比1234567891011121314151617181920212223242526# 显示暂存区和工作区的差异$ git diff # 显示暂存区和上一个commit的差异$ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异$ git diff HEAD # 显示两次提交之间的差异$ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; # 显示某次提交的元数据和内容变化$ git show [commit] # 显示某次提交发生变化的文件$ git show --name-only [commit] # 显示某次提交时，某个文件的内容$ git show [commit]:[filename] # 显示当前分支的最近几次提交$ git reflog 撤销123456789101112131415161718192021222324252627# 恢复暂存区的指定文件到工作区$ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区$ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit] # 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 暂存123456789101112131415161718192021# 暂存$ git stash# 暂存列表$ git stash list# 移恢复具体某一次的版本，如果不指定stash_id，则默认恢复最新的存储进度$ git stash pop$ git stash apply stash@&#123;1&#125;# 删除一个存储的进度$ git stash drop stash@&#123;5&#125;# 清除所有的存储进度$ git stash clear# 查看堆栈中最新保存的stash和当前目录的差异$ git stash show# 从最新的stash创建分支$ git stash branch 同步和推送1234567891011121314151617181920212223242526272829303132333435# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 查看远程服务器地址和仓库名称$ git remote -v# 添加远程仓库地址$ git remote add origin git@ github:xxx/xxx.git# 设置远程仓库地址(用于修改远程仓库地址)$ git remote set-url origin git@ github.com:xxx/xxx.git# 删除远程仓库$ git remote rm &lt;repository&gt;# 上传本地指定分支到远程仓库# 把本地的分支更新到远端origin的master分支上# git push &lt;远端&gt; &lt;分支&gt;# git push 相当于 git push origin master$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 导出12345678# 打包tag sha 分支等$ git archive --format=zip --output=output.zip HEAD# 打包排除log文件$ git archive -o archive.zip HEAD --exclude=&#x27;*.log&#x27;# 打包包含路径$ git archive --format=zip --prefix=myfolder/ -o a.zip HEAD:myfolder 搜索1$ git grep &#x27;http&#x27; 合并12345# 合并commit$ git cherry-pick [commit]# 合并分支$ git merge [branch] 子仓库123456789101112131415161718# 初始化git submodule init# 添加git submodule add &lt;repository-url&gt; &lt;path-to-submodule&gt;# 更新git submodule update --remote# 克隆git submodule update --init --recursive# 删除git submodule deinit &lt;path-to-submodule&gt;git rm --cached &lt;path-to-submodule&gt;rm -rf &lt;path-to-submodule&gt;git commit -m &quot;Removed submodule&quot;# 父项目拉取时同时更新子模块git pull --recurse-submodules []","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"Doxygen使用","slug":"blog/doxygen","date":"2024-12-27T01:43:25.000Z","updated":"2024-12-27T03:42:54.746Z","comments":true,"path":"2024/12/27/blog/doxygen/","permalink":"http://example.com/2024/12/27/blog/doxygen/","excerpt":"","text":"Doxygen使用生成配置文件1doxygen -g Doxygenfile 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 项目名称，将作为于所生成的程序文档首页标题PROJECT_NAME = &quot;Test&quot;# 文档版本号，可对应于项目版本号，譬如 svn、cvs 所生成的项目版本号PROJECT_NUMBER = &quot;1.0.0&quot;# 程序文档输出目录OUTPUT_DIRECTORY = doc # 程序文档输入目录 INPUT = User src inc Utilities # 程序文档语言环境OUTPUT_LANGUAGE = ChineseDOXYFILE_ENCODING = UTF-8# 只对头文件中的文档化信息生成程序文档 FILE_PATTERNS = # 递归遍历当前目录的子目录，寻找被文档化的程序源文件 RECURSIVE = YES # 如果是制作 C 程序文档，该选项必须设为 YES，否则默认生成 C++ 文档格式OPTIMIZE_OUTPUT_FOR_C = YES#提取信息，包含类的私有数据成员和静态成员EXTRACT_ALL = yesEXTRACT_PRIVATE = yesEXTRACT_STATIC = yes# 对于使用 typedef 定义的结构体、枚举、联合等数据类型，只按照 typedef 定义的类型名进行文档化TYPEDEF_HIDES_STRUCT = YES# 在 C++ 程序文档中，该值可以设置为 NO，而在 C 程序文档中，由于 C 语言没有所谓的域/名字空间这样的概念，所以此处设置为 YESHIDE_SCOPE_NAMES = YES# 让 doxygen 静悄悄地为你生成文档，只有出现警告或错误时，才在终端输出提示信息QUIET = YES# 递归遍历示例程序目录的子目录，寻找被文档化的程序源文件EXAMPLE_RECURSIVE = YES# 允许程序文档中显示本文档化的函数相互调用关系REFERENCED_BY_RELATION = YESREFERENCES_RELATION = YESREFERENCES_LINK_SOURCE = YES# 不生成 latex 格式的程序文档 PDFGENERATE_LATEX = NO# 在程序文档中允许以图例形式显示函数调用关系，前提是你已经安装了 graphviz 软件包# HAVE_DOT = YES# CALL_GRAPH = YES# CALLER_GRAPH = YES#在最后生成的文档中，把所有的源代码包含在其中SOURCE_BROWSER = YES# 这会在HTML文档中，添加一个侧边栏，并以树状结构显示包、类、接口等的关系GENERATE_TREEVIEW = ALL 生成注释1doxygen ./Doxygenfile Doxygen 注释规范123456789# 块注释/**......*/ # 行注释///&lt; ....../** ...... *//**&lt; ...... */ 12345678910111213141516171819202122注释命令 描述@brief 概要信息@details 详细描述@par 开始一个段落，段名自定义@param 标记参数意义@return 描述返回意义@retval 描述返回值意义@todo 对将要做的事情进行注释@bug 缺陷，链接到所有缺陷汇总的缺陷列表@since 通常用来说明从什么版本、时间写此部分代码@pre 用来说明代码项的前提条件@post 用来说明代码项之后的使用条件@code 在注释中开始说明一段代码，直到@endcode命令@endcode 注释中代码段的结束@fn 函数说明@include 包含文件@var 标注变量@enum 标注枚举@struct 标注结构体@class 标注类@note 描述一些注意事项@addtogroup 添加到一个组 自动注释模板（VSCode settings.json 配置）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; // Doxygen documentation generator set // 文件注释：版权信息模板 &quot;doxdocgen.file.copyrightTag&quot;: [ &quot;@copyright Copyright (c) &#123;year&#125; by 作者&quot; ], // 文件注释：自定义模块，这里我添加一个修改日志 &quot;doxdocgen.file.customTag&quot;: [ &quot;@par 修改日志:&quot;, &quot;&lt;table&gt;&quot;, &quot;&lt;tr&gt;&lt;th&gt;Date &lt;th&gt;Version &lt;th&gt;Author &lt;th&gt;Description&quot;, &quot;&lt;tr&gt;&lt;td&gt;&#123;date&#125; &lt;td&gt;1.0 &lt;td&gt;作者 &lt;td&gt;内容&quot;, &quot;&lt;/table&gt;&quot;, ], // 文件注释的组成及其排序 &quot;doxdocgen.file.fileOrder&quot;: [ &quot;file&quot;, // @file &quot;brief&quot;, // @brief 简介 &quot;author&quot;, // 作者 &quot;version&quot;, // 版本 &quot;date&quot;, // 日期 &quot;empty&quot;, // 空行 &quot;copyright&quot;,// 版权 &quot;empty&quot;, // 空行 &quot;custom&quot; // 自定义 ], // 下面时设置上面标签tag的具体信息 &quot;doxdocgen.file.fileTemplate&quot;: &quot;@file &#123;name&#125;&quot;, &quot;doxdocgen.file.versionTag&quot;: &quot;@version 1.0&quot;, &quot;doxdocgen.generic.authorEmail&quot;: &quot;邮箱@qq.com&quot;, &quot;doxdocgen.generic.authorName&quot;: &quot;作者&quot;, &quot;doxdocgen.generic.authorTag&quot;: &quot;@author &#123;author&#125; (&#123;email&#125;)&quot;, // 日期格式与模板 &quot;doxdocgen.generic.dateFormat&quot;: &quot;YYYY-MM-DD&quot;, &quot;doxdocgen.generic.dateTemplate&quot;: &quot;@date &#123;date&#125;&quot;, // 根据自动生成的注释模板（目前主要体现在函数注释上） &quot;doxdocgen.generic.order&quot;: [ &quot;brief&quot;, &quot;tparam&quot;, &quot;param&quot;, &quot;return&quot; ], &quot;doxdocgen.generic.paramTemplate&quot;: &quot;@param&#123;indent:8&#125;&#123;param&#125;&#123;indent:25&#125;MyParamDoc&quot;, &quot;doxdocgen.generic.returnTemplate&quot;: &quot;@return &#123;type&#125; &quot;, &quot;doxdocgen.generic.splitCasingSmartText&quot;: true, &quot;[json]&quot;: &#123; &quot;editor.quickSuggestions&quot;: &#123; &quot;strings&quot;: true &#125;, &quot;editor.suggest.insertMode&quot;: &quot;replace&quot; &#125;,&#125; 手动注释模板文件注释模板123456789101112131415/** * @file 文件名 * @brief 文件概要信息描述 * @author 作者 * @version 版本 * @date 日期 * * @copyright 版权信息 * * @par 修改日志: * &lt;table&gt; * &lt;tr&gt;&lt;th&gt;Date &lt;th&gt;Version &lt;th&gt;Author &lt;th&gt;Description * &lt;tr&gt;&lt;td&gt;日期 &lt;td&gt;版本 &lt;td&gt;作者 &lt;td&gt;说明 * &lt;/table&gt; */ 函数注释模板1234567/** * @brief 函数功能概要信息 * @param[in] 输入参数 输入参数描述信息 * @param[out] 输出参数 输出参数描述信息 * @return 返回类型 * @retval 返回值 返回值意义描述信息 */","categories":[{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"Doxygen","slug":"博客/Doxygen","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/Doxygen/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Doxygen","slug":"Doxygen","permalink":"http://example.com/tags/Doxygen/"}]},{"title":"CMake","slug":"stm32/cmake","date":"2024-12-25T01:43:25.000Z","updated":"2024-12-27T07:15:00.600Z","comments":true,"path":"2024/12/25/stm32/cmake/","permalink":"http://example.com/2024/12/25/stm32/cmake/","excerpt":"","text":"CMake 构建下载链接CMake Ninja 环境构建cmake -G 查看构建环境 使用Make CMake 构建makefile 目录build下 1cmake -B build -G &quot;Unix Makefiles&quot; make 编译 1make -C build 或 1cmake --build build 使用Ninja CMake 构建Ninja 目录build下 1cmake -B build -G &quot;Ninja&quot; Ninja编译 1ninja -C build 或 1cmake --build build 清理构建1rm -r build 指定构建cmake -G 指定构建3.15版本后，支持设定构建器变量CMAKE_GENERATOR 1set(CMAKE_GENERATOR &quot;Unix Makefiles&quot;) ? 不生效 全编译1rm -r build;cmake -B build -G &quot;Unix Makefiles&quot;;cmake --build build 1rm -r build;cmake -B build -G &quot;Ninja&quot;;cmake --build build 指令时间12Measure-Command &#123;rm -r build;cmake -B build -G &quot;Ninja&quot;;ninja -C build&#125;Measure-Command &#123;rm -r build;make&#125; 指令执行 powershell 使用;将指令分隔开 linux &amp;：同时运行 &amp;&amp;：先后执行,执行成功后执行下一个 ||：执行失败后，执行下一个 STM32CubeMX v6.11 开始增加cmake编译，此版本makefile中的文件路径变化，导致编译不错，需要修改文件路径 v6.12 cmake编译不过，链接出错","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"CMake","slug":"CMake","permalink":"http://example.com/tags/CMake/"}]},{"title":"nRF DFU","slug":"NRF52/DFU","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.325Z","comments":true,"path":"2024/12/24/NRF52/DFU/","permalink":"http://example.com/2024/12/24/NRF52/DFU/","excerpt":"","text":"NRF52 DFUmicrc-ecc Nordic的DFU采用了micro-ecc实现ECDSA算法,需要用到micro-ecc源码编译 pc-nrfutil 生成加密密钥 1.编译micro-ecc库 1.将micro-ecc源码放在SDK\\external\\micro-ecc下2.选择对应编译项编译，生成对应的库 2.安装pc-nrfutil python setup.py install 3.生成private_key和public_key12nrfutil keys generate private.pemnrfutil keys display --key pk --format code private.pem --out_file dfu_public_key.c 4.编译bootloader1.使用生成的dfu_public_key.c替换examples\\dfu下的文件2.编译对应的bootloader，烧录运行后，手机打开nRF Connect，可扫描到DfuTarg 5.打包升级文件1.对应工程examples\\ble_app_buttonless_dfu编译2.将编译后的hex文件和private.pem放入一个文件夹中3.输入命令打包例如： 1nrfutil pkg generate --hw-version 52 --application-version 1 --application nrf52832_xxaa.hex --sd-req 0xAF --key-file private.pem dfufile.zip hardware version：硬件版本nRF52832设置为52softdevice firmware ID：协议栈ID,输入对应版本的IDapplication-version 程序版本号nrfutil pkg generate –help 可查询命令使用说明可在SDK\\components\\softdevice\\s132\\doc\\s132_nrf52_7.2.0_release-notes.pdf 查看获取The Firmware ID of this SoftDevice7.2.0 对应0x0101 6.代码的烧写和合并预先烧好协议栈和bootloader，然后通过DFU，可以正常运行。如果直接烧写协议栈bootloader和应用程序，是无法正常运行的，因为bootloader会检查settings页面的CRC,如果settings页面不存在，程序会继续停留在bootloader不会跳转 1.生成settings文件的方法1nrfutil settings generate --family NRF52 app.hex --application-version 1 --bootloader-version 1 --bl-settings-version 1 settings.hex 2.mergehex合并烧写mergehex在command line tools中命令格式 1mergehex -m file1.hex file2.hex file3.hex -o output output_file.hex","categories":[{"name":"nrf","slug":"nrf","permalink":"http://example.com/categories/nrf/"},{"name":"DFU","slug":"nrf/DFU","permalink":"http://example.com/categories/nrf/DFU/"}],"tags":[{"name":"nrf","slug":"nrf","permalink":"http://example.com/tags/nrf/"},{"name":"DFU","slug":"DFU","permalink":"http://example.com/tags/DFU/"}]},{"title":"nRF52832环境","slug":"NRF52/nrf52","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:28:18.020Z","comments":true,"path":"2024/12/24/NRF52/nrf52/","permalink":"http://example.com/2024/12/24/NRF52/nrf52/","excerpt":"","text":"nRF52832环境gcc 和 keilkeil管理稍大的工程操作繁杂，添加文件，修改文件路径令人崩溃 gcc加makefile比较简洁方便 windows: toolchain:arm-none-eabi-gcc make 修改\\components\\toolchain\\gcc\\Makefile.windows linux:arm-none-eabi-gcc和libnewlib-arm-none-eabi 12sudo apt install gcc-arm-none-eabi sudo apt install libnewlib-arm-none-eabi 修改\\components\\toolchain\\gcc\\Makefile.posix 工程：makefile路径，如: 12SDK_ROOT := ../../nRF5_SDK_17.0.2_d674ddePROJ_DIR := ../ armgcc和config文件夹同一级,或修改config路径SDK_CONFIG_FILE makefile中看具体指令 SDK结构和应用参考 Debug串口log，局限性较大 1234#define NRF_LOG_BACKEND_UART_ENABLED 1#define NRF_LOG_BACKEND_UART_TX_PIN 13NRF_LOG_PROCESS();//一次打印一条","categories":[{"name":"nrf","slug":"nrf","permalink":"http://example.com/categories/nrf/"}],"tags":[{"name":"nrf","slug":"nrf","permalink":"http://example.com/tags/nrf/"}]},{"title":"思考","slug":"doc/think","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.332Z","comments":true,"path":"2024/12/24/doc/think/","permalink":"http://example.com/2024/12/24/doc/think/","excerpt":"题目农民把3000斤萝卜送到1000公里外去卖,骆驼最高载重1000斤,而骆驼每走一公里就要吃掉一斤萝卜,问农民最多可以卖掉多少斤萝卜?","text":"题目农民把3000斤萝卜送到1000公里外去卖,骆驼最高载重1000斤,而骆驼每走一公里就要吃掉一斤萝卜,问农民最多可以卖掉多少斤萝卜? 这道题一开始看上去好像是无解的，因为你的骆驼每一公里就要消耗一斤萝卜，而到目的地有1000公里，而骆驼最多只能装1000斤萝卜。如果你的骆驼可以全部装下，到目的地也会被全部吃光，一丁点也不剩。所以，很多人的第一反应都是觉得这个不太可能。 如果一开始就觉得不太可能的话，这是很正常的。我一开始也觉得不可能，思考下去，后来想到一个解法可以运送500斤萝卜到市场方法如下: 1、装1000斤萝卜，走250公里，扔下500斤回去 2、装1000斤萝卜，走250公里，拿起250斤萝卜，走到500公里处，扔下500斤回去 3、装1000斤萝卜，走到500公里处，装上500斤走到目的地**于是有了500斤运到市场 好像很不错了，不过还有更好的方法能运更多萝卜。 解答:抽象解答使用递推公式: 12345f(1) = 1 f(2) = f(1) + 1/3 f(3) = f(2) + 1/5 … f(n) = f(n-1) + 1/(2*n+1) 通项公式: f(n) = Σ(1/(2*i)+1) (1 &lt;= i &lt;=n) 题目对应是能走的最远距离减去已知的距离，即 (f(3) – 1) * 1000 &#x3D; 533 就是说最多可以运533斤萝卜具体如下： 1、装1000斤萝卜，走200公里，扔下600斤回去 2、装1000斤萝卜，走200公里，装200斤，再走333公里，扔下334斤，往回走 3、走到200公里处，装上200斤，回去，此时200公里处还剩200斤 4、装1000斤萝卜，走至200公里处，装200斤，走至533公里处，装334斤，走到终点，剩533斤 这是之前遇到的一个面试题","categories":[{"name":"思考","slug":"思考","permalink":"http://example.com/categories/%E6%80%9D%E8%80%83/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://example.com/tags/%E6%80%9D%E8%80%83/"}]},{"title":"Hexo 博客搭建","slug":"blog/blog","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.330Z","comments":true,"path":"2024/12/24/blog/blog/","permalink":"http://example.com/2024/12/24/blog/blog/","excerpt":"","text":"Hexo blog 搭建HEXO 安装 HEXO官网 12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 更换主题 主题 12345$ cd HEXO_PATH/themes$ git clone https://github.com/cocowool/wave.git$ npm install --save hexo-renderer-sass$ cd ..$ hexo s 推送 安装推送工具 12npm install hexo-deployer-git --save# 搜索功能需要安装`hexo-generator-searchdb` _congif.yml文件,找到 deploy 字段，把以下代码放进去，填写新建的仓库地址 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: &lt;你的仓库地址&gt;branch: master 静态文件生成 1hexo g 清除 1hexo clean 部署 1hexo deploy","categories":[{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"博客/hexo","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"ESP8266编译环境","slug":"esp8266/environment","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.337Z","comments":true,"path":"2024/12/24/esp8266/environment/","permalink":"http://example.com/2024/12/24/esp8266/environment/","excerpt":"","text":"esp8266环境编译速度 linux windows make real 0m47.489s real 6m33.019s user 0m36.469s user 0m23.129s sys 0m10.939s sys 0m46.835s make -j4 real 0m18.424s real 2m8.387s user 0m50.240s user 0m19.590s sys 0m14.509s sys 0m44.509s linux编译速度比windows快8倍左右 编译环境参考 环境下载（附带SDK Toolchain）esp32_win32_msys2_environment_and_toolchain-20180110.zip win11修改用户名win+r 运行 netplwiz SDKESP8266_RTOS_SDK ToolchainToolchain xtensa-lx106-elf 1python -m pip install --user -r $IDF_PATH/requirements.txt 新建工程编译新建export_path.sh 123#!/bin/bashexport IDF_PATH=~/esp/ESP8266_RTOS_SDKexport PATH=$PATH:~/esp/toolchain/xtensa-lx106-elf/bin 执行. export_path.sh加入环境变量 修改配置 1make menuconfig 下载 1make flash monitor 环境参考 工程自定义文件夹参考 如腾讯IoT工程","categories":[{"name":"esp","slug":"esp","permalink":"http://example.com/categories/esp/"}],"tags":[{"name":"esp","slug":"esp","permalink":"http://example.com/tags/esp/"}]},{"title":"ESP-IDF","slug":"esp8266/espidf","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.337Z","comments":true,"path":"2024/12/24/esp8266/espidf/","permalink":"http://example.com/2024/12/24/esp8266/espidf/","excerpt":"","text":"ESP-IDF安装esp-idf esp-gitee-tools 使用esp-gitee-tools加速环境搭建，详情看install使用 cmd环境下在esp-idf文件夹下运行export.bat&#x2F;export.sh加入环境变量，然后运行idf.py build编译 组件配置相关文件 文件 位置 作用 概括 Kconfig 组件目录【手动创建】 用于生成menuconfig中的菜单于Component Configuration子菜单 菜单模板 Kconfig.projbuild 组件目录【手动创建】 用于生成menuconfig中的菜单于顶层菜单 菜单模板 sdkconfig 项目根目录【自动生成】 用于以键值对的形式保存Kconfig设置手动改动无效 保存设置 sdkconfig.h 工程编译生成文件build&#x2F;config&#x2F;【自动生成】 C语言访问Kconfig配置的方式手动改动无效 C语言接口 sdkconfig.default 项目根目录【手动创建】 自定义sdkconfig的默认值，与sdkconfig文件格式相同，不会被构建系统更改。构建系统自动使用此文件的配置填充sdkconfig中未设置的值 缺省值清单 sdkconfig.old 项目根目录【自动生成】 当保存旧的menuconfig设置时，构建系统自动备份一个原来的sdkconfig文件 备份 sdkconfig.ci 该文件是 CI（持续集成）测试框架的一部分，在正常构建过程中会被忽略。 单元测试时 sdkconfig.remane 用于重命名弃用的配置名，方便旧配置文件快速用于新配置 向前兼容 新建工程 方法一通过idf.py指令1idf.py create-project projName 方法二在esp-idf的example-&gt;’get-started’里面是有一个sample_project的样板文件，可以复制修改 文件内容以及作用分析ProjDir&#x2F;CMakeLists.txt文件这是工程目录下的给CMake使用的文件，我们可以在里面指定我们需要用的componnent路径。 1234567891011# For more information about build system see# https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/build-system.html# The following five lines of boilerplate have to be in your project&#x27;s# CMakeLists in this exact order for cmake to work correctlycmake_minimum_required(VERSION 3.5)set(EXTRA_COMPONENT_DIRS $ENV&#123;IDF_PATH&#125;/examples/common_components/led_strip)#这一行就是指定项目用到的componnent路径include($ENV&#123;IDF_PATH&#125;/tools/cmake/project.cmake)project(ws2812_master) ProjDir&#x2F;Makefile文件这个文件就是给CMake的编译文件，这里面的信息还是比较有用的。同样，我们也需要在这里面声明用到的componnent路径，给CMake指路。要注意需改PROJECT_NAME :&#x3D;为你的项目名称。 12345678910## This is a project Makefile. It is assumed the directory this Makefile resides in is a# project subdirectory.#PROJECT_NAME := ws2812_masterEXTRA_COMPONENT_DIRS = $(IDF_PATH)/examples/common_components/led_stripinclude $(IDF_PATH)/make/project.mk ProjDir&#x2F;main&#x2F;CMakeLists.txt文件这个文件用来个CMake指路，告诉它main文件的位置，注意修改main文件的名称。 12idf_component_register(SRCS &quot;ws2812_master_main.c&quot; INCLUDE_DIRS &quot;.&quot;) ProjDir&#x2F;main&#x2F;Kconfig.projbuild文件这不是一个必须的文件，它的作用就是把一些常量放进idf.config menuconfig里面，可以方便针对情况修改工程，而不需要进入到代码里面。它的格式请参考下面的格式，或者示例工程里面也有这个文件。在代码中使用需要注意：WS2812_RMT_GPIO 这个配置项在使用的时候应该为CONFIG_WS2812_RMT_GPIO 12345678910111213menu &quot;WS2812 RMT Configuration&quot; config WS2812_RMT_GPIO int &quot;RMT TX GPIO&quot; default 48 help Set the GPIO numbers used for transmitting the RMT single. config WS2812_STRIP_LED_NUMBER int &quot;Number of LEDs in strip&quot; default 25 help A single RGB strip contains serveral LEDs.endmenu","categories":[{"name":"esp","slug":"esp","permalink":"http://example.com/categories/esp/"}],"tags":[{"name":"esp","slug":"esp","permalink":"http://example.com/tags/esp/"}]},{"title":"FFMPEG录屏","slug":"linux/ffmpeg录屏","date":"2024-12-24T01:43:25.000Z","updated":"2025-01-03T07:08:54.633Z","comments":true,"path":"2024/12/24/linux/ffmpeg录屏/","permalink":"http://example.com/2024/12/24/linux/ffmpeg%E5%BD%95%E5%B1%8F/","excerpt":"","text":"FFMPEG录屏使用 FFMpeg录屏通常有两种方式： 基于 gdigrab (使用CPU录制) 基于 DirectShow （使用显卡录制） gdigrab方式实现更简单，更轻量，兼容性也更好。DirectShow方案需要额外下载 screen-capture-recorder 基于该方法，主要核心就是 ffmpeg的命令编写，具体命令如下： 1ffmpeg -f gdigrab -framerate 30 -offset_x 0 -offset_y 0 -video_size 1920x1080 -i desktop -r 30 -vcodec libx264 -pix_fmt yuv420p -y &quot;output.mp4&quot; 12345678910111213//注意：ffmpeg 的命令输入，也需要考虑输入顺序的。先指定输入参数，再指定输出参数。 // -f 表示指定文件格式或采集数据的设备，如果是 DirectShow 方案，就需要指定为 screen-capture-recorder。 //对于输入，如果不指定-f,ffmpeg 会根据输入数据，来判断数据的封装格式. //对于输出，如果不指定-f,ffmpeg 也可以通过输出文件名进行推导. //ffmpeg -formats 可以列出所有的formats// -framerate 指定录制的视频帧率// -offset_x -offset_y 指定录制的区域左上角坐标// -video_size 指定录制的视频尺寸// -i 指定从哪儿采集数据，它是一个文件索引号。这里是指定输入的视频源。（i 表示input，不一定是表示视频文件，表示输入。如也可以是音频文件输入等）// -r 指定帧率// -vcodec 指定编码格式。libx264 这种格式录制出来的视频，清晰度更清晰，占用的文件大小更小，推荐使用。// -pix_fmt 像素格式，常规使用yuv420p// -y 表示强制覆盖，如果输出文件已经存在，就覆盖输出文件路径。这里需要注意下：输出文件路径带上 双引号 ，防止不合法路径将命令拆分了。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"ffmpeg","slug":"linux/ffmpeg","permalink":"http://example.com/categories/linux/ffmpeg/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://example.com/tags/ffmpeg/"},{"name":"录屏","slug":"录屏","permalink":"http://example.com/tags/%E5%BD%95%E5%B1%8F/"}]},{"title":"强制网络门户","slug":"esp8266/cap","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.337Z","comments":true,"path":"2024/12/24/esp8266/cap/","permalink":"http://example.com/2024/12/24/esp8266/cap/","excerpt":"","text":"强制网络门户强制网络门户（captive portal）就是手机在连接上某个wifi的时候，自动弹出一个页面，这个页面通常是要我们输入账号密码才能连接网络。wifi还没有大面积普及的时候，在商场或餐厅提供的wifi常常使用这个功能。现在wifi设备多了，这个功能逐渐被遗忘了，但是仍然有一定的用处，比如手机连上wifi自动后弹出配网页面。 原理手机连上wifi后，但不能保证能连接到互联网，所以手机连上某个wifi的第一件事就是检查下这个wifi是否有网。不同品牌的手机检查网络方式略有不同，但基本上大同小异。一般是向某个固定的地址发起一个HTTP请求，如果请求到正确的数据，则证明这个wifi可以正常连接互联网，如果请求不到数据，或者请求到了错误的数据，则说明这个wifi不能正常连接互联网。上述检查网络的过程可分为三种情况： 1.请求到正常的数据(该wifi可直接上网) 2.没有请求到数据(该wifi无法连接网络) 3.请求到错误(非手机期待)的数据(可能需要认证才能连接网络) 如果遇到上述第三种情况，那么手机就会打开相应的页面，就是所谓的自动弹出页面。HTTP请求的过程，首先通过DNS获取服务器的IP地址，然后再向服务器发起HTTP请求。以苹果手机为例，连上某个wifi后会访问如下页面http://captive.apple.com/hotspot-detect.html访问过程如下，先向DNS服务器发起DNS请求，获得captive.apple.com对应的IP地址，然后再向刚刚获取到的地址发送HTTP请求，如果DNS请求失败，则不会（也不能）发起Http请求。 示例手机连上ESP8266后，默认的DNS地址就是模块的地址（192.168.4.1），所以我们要在模块上建立一个DNS服务器，响应手机发来的DNS请求，将所有的域名都解析到模块本身的IP地址上，那么手机访问http://captive.apple.com/hotspot-detect.html就相当于访问http://192.168.4.1/hotspot-detect.html，我们的模组就能成功的捕获到手机发来的HTTP请求了。（这种做法通常叫做DNS拦截）。捕获到HTTP请求后，还要做相应的HTTP响应，才能让手机弹出页面。所以模组还需要建立一个HTTP服务器，相应手机发来的HTTP请求。HTTP底层协议是TCP，默认使用的是80端口，我们只需要建立一个TCP服务器，监听80端口，收到数据后做相应的回复即可。 实现代码123456789101112131415161718192021222324252627282930313233static void initialise_wifi(void)&#123; tcpip_adapter_init(); wifi_event_group = xEventGroupCreate(); ESP_ERROR_CHECK( esp_event_loop_init(event_handler, NULL) ); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK( esp_wifi_init(&amp;cfg) ); wifi_config_t wifi_ap_config = &#123; .ap = &#123; .ssid = &quot;Free Wifi&quot;, .ssid_len = strlen(&quot;Free Wifi&quot;), .authmode = WIFI_AUTH_OPEN, .max_connection = 3, &#125;, &#125;; ESP_ERROR_CHECK( esp_wifi_set_mode(WIFI_MODE_AP) ); ESP_LOGI(TAG, &quot;Setting WiFi softAP SSID %s...&quot;, wifi_ap_config.ap.ssid); ESP_ERROR_CHECK( esp_wifi_set_config(ESP_IF_WIFI_AP, &amp;wifi_ap_config) ); ESP_ERROR_CHECK( esp_wifi_start() );&#125;void app_main()&#123; ESP_ERROR_CHECK( nvs_flash_init() ); initialise_wifi(); //初始化wifi dns_server_start(); //开启DNS服务 web_server_start(); //开启http服务&#125; DNS报文解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129static void my_dns_server(void *pvParameters)&#123; uint8_t data[128]; int len = 0; struct sockaddr_in client = &#123; 0 &#125;; socklen_t client_len=sizeof(struct sockaddr_in); uint32_t i = 0; ESP_LOGI(TAG,&quot;DNS server start ...&quot;); int sock = create_udp_socket(53); if (sock &lt; 0) &#123; ESP_LOGE(TAG,&quot;Failed to create IPv4 multicast socket&quot;); &#125; while(1) &#123; len=recvfrom(sock,data,100,0,(struct sockaddr *)&amp;client,&amp;client_len); //阻塞式 if((len &lt; 0) || ( len &gt; 100)) &#123; ESP_LOGE(TAG,&quot;recvfrom error\\n&quot;); continue; &#125; //过滤掉一些杂乱的域名 if( strstr((const char *)data+0xc,&quot;taobao&quot;)|| strstr((const char *)data+0xc,&quot;qq&quot;) || strstr((const char *)data+0xc,&quot;sogou&quot;) || strstr((const char *)data+0xc,&quot;amap&quot;) || strstr((const char *)data+0xc,&quot;alipay&quot;)|| strstr((const char *)data+0xc,&quot;youku&quot;) || strstr((const char *)data+0xc,&quot;iqiyi&quot;) || strstr((const char *)data+0xc,&quot;baidu&quot;)) &#123; continue; &#125; data[2] |= 0x80; data[3] |= 0x80; data[7] =1; data[len++] =0xc0; data[len++] =0x0c; data[len++] =0x00; data[len++] =0x01; data[len++] =0x00; data[len++] =0x01; data[len++] =0x00; data[len++] =0x00; data[len++] =0x00; data[len++] =0x0A; data[len++] =0x00; data[len++] =0x04; data[len++] =192; data[len++] =168; data[len++] =4; data[len++] =1; sendto(sock,data,len,0,(struct sockaddr*)&amp;client,client_len); vTaskDelay(10); &#125; ESP_LOGE(TAG,&quot;DNS server stop ...&quot;); shutdown(sock, 0); close(sock); vTaskDelete(NULL);&#125;void webserver(void *pvParameters)&#123; int sockfd,new_fd;/*socket句柄和建立连接后的句柄*/ struct sockaddr_in my_addr;/*本方地址信息结构体，下面有具体的属性赋值*/ struct sockaddr_in their_addr;/*对方地址信息*/ socklen_t sin_size; struct timeval tv;//发送接收超时时间 tv.tv_sec = 10; tv.tv_usec = 0; sin_size=sizeof(struct sockaddr_in); sockfd=socket(AF_INET,SOCK_STREAM,0);//建立socket if(sockfd==-1) &#123; ESP_LOGE(TAG, &quot;socket failed:%d&quot;,errno); vTaskDelete(NULL); return; &#125; my_addr.sin_family=AF_INET;/*该属性表示接收本机或其他机器传输*/ my_addr.sin_port=htons(80);/*端口号*/ my_addr.sin_addr.s_addr=htonl(INADDR_ANY);/*IP，括号内容表示本机IP*/ bzero(&amp;(my_addr.sin_zero),8);/*将其他属性置0*/ if(bind(sockfd,(struct sockaddr*)&amp;my_addr,sizeof(struct sockaddr))&lt;0)//绑定地址结构体和socket &#123; ESP_LOGE(TAG,&quot;bind error&quot;); vTaskDelete(NULL); return; &#125; listen(sockfd,8);//开启监听 ，第二个参数是最大监听数 ESP_LOGI(TAG, &quot;webserver start...&quot;); while(1) &#123; new_fd=accept(sockfd,(struct sockaddr*)&amp;their_addr,&amp;sin_size);//在这里阻塞知道接收到消息，参数分别是socket句柄，接收到的地址信息以及大小 if(new_fd==-1) &#123; ESP_LOGE(TAG,&quot;accept failed&quot;); &#125; else &#123; ESP_LOGI(TAG,&quot;Accept new socket: %d&quot;,new_fd); setsockopt(new_fd, SOL_SOCKET, SO_RCVTIMEO, (const char*)&amp;tv, sizeof(tv)); int *para_fd = malloc(sizeof(int)); *para_fd = new_fd; xTaskCreate(&amp;handle_http_request, &quot;socket_task&quot;, 1024*3, para_fd, 6, NULL); &#125; vTaskDelay(10); &#125; vTaskDelete(NULL);&#125;","categories":[{"name":"esp","slug":"esp","permalink":"http://example.com/categories/esp/"}],"tags":[{"name":"esp","slug":"esp","permalink":"http://example.com/tags/esp/"}]},{"title":"gitattributes","slug":"linux/gitattributes","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.322Z","comments":true,"path":"2024/12/24/linux/gitattributes/","permalink":"http://example.com/2024/12/24/linux/gitattributes/","excerpt":"","text":".gitattributes基本用法 1.设置行尾字符： 你可以设置文本文件在检出时应该使用哪种行尾字符(LF、CRLF 或 auto)。这对于跨平台项目特别有用，因为 Windows 通常使用 CRLF 行尾，而 Unix 和 Linux 通常使用 LF 行尾。text&#x3D;auto或者针对特定文件或目录： 12somefile.txt text eol=lfsubdir/ text eol=crlf 2.识别文本和二进制文件： Git 默认会尝试将文件识别为文本或二进制文件，但你可以通过 .gitattributes 文件来明确指定。 12*.png binary# 或者*.png -text 3.合并策略： 对于合并冲突，你可以为特定文件或目录设置不同的合并策略。使用自定义的合并工具 1*.c merge=mytool 4.差异算法： 你可以为某些文件指定特定的差异算法，以改进 Git 显示的差异。使用 word-diff 算法 1*.doc diff=word 5.导出过滤器： 当使用 git archive 命令创建归档时，你可以指定过滤器来修改导出的文件内容。 6.Smudge&#x2F;Clean 过滤器： 你可以设置 smudge 和 clean 过滤器，这些过滤器会在检出和提交时分别应用，用于修改文件内容。例如，你可以使用这些过滤器来加密和解密文件，或者在检出时自动转换文件格式。 7.语言识别： 通过 .gitattributes 文件,Git 可以更好地识别某些文件的语言，从而改进代码统计和语法高亮等功能。 为了使用 .gitattributes 文件，你需要将其放置在仓库的根目录或任何子目录中。如果文件位于子目录中，它只会影响该子目录及其子目录中的文件。还可以在 .gitattributes 文件中使用模式匹配来指定哪些文件或目录应该应用这些属性。 .gitattributes 文件的更改不会影响已经提交到 Git 仓库的文件内容。这些更改只会影响未来的检出和提交操作。 gitattributes文件示例：123456* text=auto*.txt text*.jpg -text*.vcproj text eol=crlf*.sh text eol=lf*.py eol=lf 说明： 第1行，对任何文件，设置text&#x3D;auto，表示文件的行尾自动转换。如果是文本文件，则在文件入Git库时，行尾自动转换为LF。如果已经在入Git库中的文件的行尾为CRLF，则该文件在入Git库时，不再转换为LF。 第2行，对于txt文件，标记为文本文件，并进行行尾规范化。 第3行，对于jpg文件，标记为非文本文件，不进行任何的行尾转换。 第4行，对于vcproj文件，标记为文本文件，在文件入Git库时进行规范化，即行尾为LF。但是在检出到工作目录时，行尾自动转换为CRLF。 第5行，对于sh文件，标记为文本文件，在文件入Git库时进行规范化，即行尾为LF。在检出到工作目录时，行尾也不会转换为CRLF（即保持LF）。 第6行，对于py文件，只针对工作目录中的文件，行尾为LF。","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"FFMPEG常用命令","slug":"linux/ffmpeg","date":"2024-12-24T01:43:25.000Z","updated":"2025-01-03T07:01:08.767Z","comments":true,"path":"2024/12/24/linux/ffmpeg/","permalink":"http://example.com/2024/12/24/linux/ffmpeg/","excerpt":"","text":"FFMPEG常用命令 ‌转码‌：将MP4视频转码为AVI格式，命令为123ffmpeg -i input.mp4 output.aviffmpeg -i input_test.mp4 -vn -acodec copy output_test.flvffmpeg -i input_test.aac -vn -acodec copy output_test.mp3 ‌裁剪‌：从音视频文件中裁剪特定部分，命令为1ffmpeg -ss 00:00:10 -i input.mp4 -t 00:00:20 output.mp4 ‌+ 合并‌：将两个MP4视频文件合并为一个文件，命令为1ffmpeg -i input1.mp4 -i input2.mp4 -c:v copy -c:a copy output.mp4 ‌音频提取‌：从MP4视频中提取音频并保存为MP3格式，命令为1ffmpeg -i input.mp4 -vn output.mp3 ‌截图‌：从视频的第5秒截取一张图片并保存为JPG格式，命令为1ffmpeg -i input.mp4 -ss 00:00:05 -vframes 1 output.jpg ‌视频拼接‌：根据文件列表拼接多个视频文件为一个MP4视频，命令为1ffmpeg -f concat -i input.txt -c copy output.mp4 ‌视频旋转‌：将视频逆时针旋转90度，命令为1ffmpeg -i input.mp4 -vf &quot;transpose=1&quot; output.mp4 ‌调整大小‌：将视频大小调整为1280×720像素，命令为1ffmpeg -i input.mp4 -vf &quot;scale=w=1280:h=720&quot; output.mp4 ‌添加水印‌：在视频的右下角添加水印，命令为1ffmpeg -i input.mp4 -i watermark.png -filter_complex &quot;overlay=W-w-10:H-h-10&quot; output.mp4 ‌修改帧率‌：将视频的帧率修改为30帧&#x2F;秒，命令为1ffmpeg -i input.mp4 -r 30 output.mp4 网络资源下载12ffmpeg -i https://xxx.xxx.xxxxxx -c copy -f mp3 output_test.mp3ffmpeg -i https://xxx.com/xx.m3u8 -c copy save.mp4 常用参数基本参数-i：指定输入文件。 -f：指定输出格式。 -y：自动覆盖输出文件而不提示。 -t：指定输出的持续时间。 -ss：设置开始时间（用于截取片段）。 -to：设置结束时间（用于截取片段）。 -r：设置帧率。 -s：设置分辨率，例如 -s 1280x720。 -an：禁用音频。 -vn：禁用视频。 视频参数-vcodec：指定视频编码器，例如 -vcodec libx264。 -b:v：设置视频比特率，例如 -b:v 1000k。 -r：设置帧率，例如 -r 30。 -vf：设置视频过滤器，例如 -vf &quot;scale=1280:720&quot;。 -aspect：设置显示比例，例如 -aspect 16:9。 -q:v：设置视频质量（较低的值表示较高的质量）。 音频参数-acodec：指定音频编码器，例如 -acodec aac。 -b:a：设置音频比特率，例如 -b:a 192k。 -ar：设置音频采样率，例如 -ar 44100。 -ac：设置音频声道数，例如 -ac 2。 -q:a：设置音频质量（较低的值表示较高的质量）。 -filter:a：设置音频过滤器，例如 -filter:a &quot;volume=0.5&quot;。 格式参数-f：指定输出格式，例如 -f mp4。 -c：指定编码器，可以用于音频或视频，例如 -c:v libx264 或 -c:a aac。 -c:v 和 -c:a：分别指定视频和音频编码器。 流操作-map：选择流，例如 -map 0:v 选择第一个输入文件的视频流。 -map_channel：选择音频通道。 -codec copy：直接复制流而不进行重新编码。 其他参数-threads：设置使用的线程数。 -preset：设置编码速度与质量的平衡，例如 -preset fast。 -crf：设置恒定质量模式的质量参数（适用于 x264 和 x265 编码器），值范围为 0-51，较低的值表示较高的质量。 -maxrate 和 -bufsize：设置最大比特率和缓冲区大小，用于控制比特率。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"ffmpeg","slug":"linux/ffmpeg","permalink":"http://example.com/categories/linux/ffmpeg/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://example.com/tags/ffmpeg/"}]},{"title":"gcc库","slug":"linux/lib","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.322Z","comments":true,"path":"2024/12/24/linux/lib/","permalink":"http://example.com/2024/12/24/linux/lib/","excerpt":"","text":"GCC库生成动态库和静态库编译使用main.c 12345678#include &lt;stdio.h&gt;#include &quot;max.h&quot;int main(int argc, char *argv[])&#123; int a = 10, b = -2, c = 100; printf(&quot;max among 10, -2 and 100 is %d.\\n&quot;, max(a, b, c)); return 0;&#125; max.c 123456789#include &quot;stdio.h&quot;int max(int n1, int n2, int n3)&#123; int max_num = n1; max_num = max_num &lt; n2? n2: max_num; max_num = max_num &lt; n3? n3: max_num; printf(&quot;\\nlib test makefile add path\\n&quot;); return max_num;&#125; max.h 1234#ifndef __MAX_H__#define __MAX_H__int max(int n1, int n2, int n3);#endif makefile 1234567891011121314151617.PHONY: build test cleanmax.o: max.c gcc -c -fPIC $&lt;#动态库build1: max.o gcc -o libmax.so -shared max.otest1: main.c build1 gcc -o dynamic $&lt; -L./ -Wl,-rpath=./ -lmax#静态库build2:max.o ar -rcs libmaxs.a max.otest2: main.c build2 gcc -o static $&lt; -L ./ -lmaxsclean: rm -f *.o *.so *.a gcc常用编译选项： 选项 含义 -static 链接静态库，禁止使用动态库 -shared 进行动态库编译，链接动态库 -Ldir 在库的搜索路径中增加dir目录 -lname 链接静态库(libname.a)或动态库(libname.so)的库文件 -fPIC(或fpic) 生成使用相对地址无关的目标代码 -Wl,-rpath&#x3D;dir 指定动态库文件位置","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"gcc","slug":"linux/gcc","permalink":"http://example.com/categories/linux/gcc/"},{"name":"lib","slug":"linux/gcc/lib","permalink":"http://example.com/categories/linux/gcc/lib/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"makefile","slug":"makefile","permalink":"http://example.com/tags/makefile/"},{"name":"gcc","slug":"gcc","permalink":"http://example.com/tags/gcc/"}]},{"title":"lvgl仿真","slug":"linux/lvgl_linux","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.325Z","comments":true,"path":"2024/12/24/linux/lvgl_linux/","permalink":"http://example.com/2024/12/24/linux/lvgl_linux/","excerpt":"","text":"lvgl linux编译报错处修改 makefile lv_conf.h 123#define LV_USE_ASSERT_MEM_INTEGRITY 0#define LV_USE_LOTTIE 0#define LV_USE_VECTOR_GRAPHIC 0 添加触摸1#define LV_USE_EVDEV 1 1lv_indev_t *touch = lv_evdev_create(LV_INDEV_TYPE_POINTER, &quot;/dev/input/event1&quot;);","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"lvgl","slug":"lvgl","permalink":"http://example.com/tags/lvgl/"}]},{"title":"树莓派","slug":"linux/raspberrypi","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-28T01:38:03.207Z","comments":true,"path":"2024/12/24/linux/raspberrypi/","permalink":"http://example.com/2024/12/24/linux/raspberrypi/","excerpt":"","text":"开机 格式化SD卡 镜像烧录（如果失败需要覆盖格式化SD卡） boot文件夹下添加ssh空文件 ssh连接 ssh pi@ip 远程桌面sodu apt-get install xrdp wifi 编辑 wpa_supplicant.conf1sudo nano /etc/wpa_supplicant/wpa_supplicant.conf 添加以下内容（替换为你的 Wi-Fi 信息）：1network=&#123; ssid=&quot;你的Wi-Fi名称&quot; psk=&quot;你的Wi-Fi密码&quot; key_mgmt=WPA-PSK &#125; 重启网络服务1sudo wpa_cli -i wlan0 reconfigure 1234# 修改ipsudo ifconfig wlan0 192.168.50.16# 重启网络服务的命令可能因系统而异。在某些系统上，可以使用以下命令来重启dhcpcd服务sudo systemctl restart dhcpcd 时区输入以下命令查看可用时区列表： 12timedatectl list-timezonestimedatectl list-timezones | grep Asia 找到您想要设置的时区，然后使用以下命令进行设置，将Europe&#x2F;Berlin替换为您的时区： 1sudo timedatectl set-timezone Asia/Shanghai 设置完成后，您可以使用以下命令确认时区已经更改： 1timedatectl 寻找主机名raspberrypi 1ping raspberrypi","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"树莓派","slug":"linux/树莓派","permalink":"http://example.com/categories/linux/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"树莓派","slug":"树莓派","permalink":"http://example.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"RTMP","slug":"linux/rtmp","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.322Z","comments":true,"path":"2024/12/24/linux/rtmp/","permalink":"http://example.com/2024/12/24/linux/rtmp/","excerpt":"","text":"Nginx RTMP推流编译选版本nginx-1.20.1,rtmp-module v1.2.0 下载123wget http://nginx.org/download/nginx-1.20.1.tar.gztar -zxvf nginx-1.20.1.tar.gzgit clone https://github.com/arut/nginx-rtmp-module.git 编译1./configure --add-module=../nginx-rtmp-module 配置1234567891011rtmp &#123; server &#123; listen 1935; # 默认的RTMP监听端口 chunk_size 4096; application live &#123; live on; record off; &#125; &#125;&#125; 推流12345ffmpeg -re -i 123.mp4 -vcodec copy -acodec copy -f flv rtmp://192.168.1.49:1935/live# 简易指令ffmpeg -i 123.mp4 -f flv rtmp://192.168.1.49:1935/live# 推流摄像头ffmpeg -f v4l2 -video_size 320x240 -framerate 15 -i /dev/video2 -q 10 -f flv rtmp://127.0.0.1/live/mytest -re 参数控制读取 AVpacket 的速度，按照帧率速度读取文件 AVpacket。如果有多个流，以最慢的帧率为准。 -vcodec copy 和 -acodec copy 用于指示 FFmpeg 在转换视频文件时不应重新编码视频和音频流，而是直接复制这些流。这可以提高转换速度，并保持原始质量。 拉流1ffplay rtmp://192.168.1.49:1935/live web服务器1234567891011121314151617181920212223242526272829# 设置http服务器http &#123; # 设置日志格式 access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; # 设置服务器名和文件根目录 server &#123; listen 80; # 服务器名，可不要 server_name localhost; # 定义请求的根目录 location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; # 处理404页面 error_page 404 /404.html; location = /40x.html &#123; &#125; # 处理500页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"nginx","slug":"linux/nginx","permalink":"http://example.com/categories/linux/nginx/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://example.com/tags/ffmpeg/"},{"name":"nginx","slug":"nginx","permalink":"http://example.com/tags/nginx/"}]},{"title":"sqlite","slug":"linux/sqlite","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.323Z","comments":true,"path":"2024/12/24/linux/sqlite/","permalink":"http://example.com/2024/12/24/linux/sqlite/","excerpt":"","text":"Sqlite下载链接SQLite3 C&#x2F;C++ 接口 API1sqlite3_open(const char *filename, sqlite3 **ppDb) 该例程打开一个指向 SQLite 数据库文件的连接，返回一个用于其他 SQLite 程序的数据库连接对象。如果 filename 参数是 NULL 或 ‘:memory:’，那么 sqlite3_open() 将会在 RAM 中创建一个内存数据库，这只会在 session 的有效时间内持续。如果文件名 filename 不为 NULL，那么 sqlite3_open() 将使用这个参数值尝试打开数据库文件。如果该名称的文件不存在，sqlite3_open() 将创建一个新的命名为该名称的数据库文件并打开。 1sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void *data, char **errmsg) 该例程提供了一个执行 SQL 命令的快捷方式，SQL 命令由 sql 参数提供，可以由多个 SQL 命令组成。在这里，第一个参数 sqlite3 是打开的数据库对象，sqlite_callback 是一个回调，data 作为其第一个参数，errmsg 将被返回用来获取程序生成的任何错误。sqlite3_exec() 程序解析并执行由 sql 参数所给的每个命令，直到字符串结束或者遇到错误为止。 1sqlite3_close(sqlite3*) 该例程关闭之前调用 sqlite3_open() 打开的数据库连接。所有与连接相关的语句都应在连接关闭之前完成。如果还有查询没有完成，sqlite3_close() 将返回 SQLITE_BUSY 禁止关闭的错误消息。 连接数据库下面的 C 代码段显示了如何连接到一个现有的数据库。如果数据库不存在，那么它就会被创建，最后将返回一个数据库对象。 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;sqlite3.h&gt;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; sqlite3_close(db);&#125; 现在，让我们来编译和运行上面的程序，在当前目录中创建我们的数据库 test.db。您可以根据需要改变路径。 $gcc test.c -l sqlite3 $./a.out Opened database successfully 如果要使用 C++ 源代码，可以按照下列所示编译代码： $g++ test.c -l sqlite3 在这里，把我们的程序链接上 sqlite3 库，以便向 C 程序提供必要的函数。这将在您的目录下创建一个数据库文件 test.db，您将得到如下结果： -rwxr-xr-x. 1 root root 7383 May 8 02:06 a.out -rw-r--r--. 1 root root 323 May 8 02:05 test.c -rw-r--r--. 1 root root 0 May 8 02:06 test.db 创建表下面的 C 代码段将用于在先前创建的数据库中创建一个表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt; static int callback(void *NotUsed, int argc, char **argv, char **azColName)&#123; int i; for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stdout, &quot;Opened database successfully\\n&quot;); &#125; /* Create SQL statement */ sql = &quot;CREATE TABLE COMPANY(&quot; \\ &quot;ID INT PRIMARY KEY NOT NULL,&quot; \\ &quot;NAME TEXT NOT NULL,&quot; \\ &quot;AGE INT NOT NULL,&quot; \\ &quot;ADDRESS CHAR(50),&quot; \\ &quot;SALARY REAL );&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, 0, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Table created successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会在 test.db 文件中创建 COMPANY 表，最终文件列表如下所示： -rwxr-xr-x. 1 root root 9567 May 8 02:31 a.out -rw-r--r--. 1 root root 1207 May 8 02:31 test.c -rw-r--r--. 1 root root 3072 May 8 02:31 test.db INSERT 操作下面的 C 代码段显示了如何在上面创建的 COMPANY 表中创建记录： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt;static int callback(void *NotUsed, int argc, char **argv, char **azColName)&#123; int i; for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create SQL statement */ sql = &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot; \\ &quot;VALUES (1, &#x27;Paul&#x27;, 32, &#x27;California&#x27;, 20000.00 ); &quot; \\ &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot; \\ &quot;VALUES (2, &#x27;Allen&#x27;, 25, &#x27;Texas&#x27;, 15000.00 ); &quot; \\ &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)&quot; \\ &quot;VALUES (3, &#x27;Teddy&#x27;, 23, &#x27;Norway&#x27;, 20000.00 );&quot; \\ &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)&quot; \\ &quot;VALUES (4, &#x27;Mark&#x27;, 25, &#x27;Rich-Mond &#x27;, 65000.00 );&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, 0, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Records created successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会在 COMPANY 表中创建给定记录，并会显示以下两行： Opened database successfully Records created successfully SELECT 操作在我们开始讲解获取记录的实例之前，让我们先了解下回调函数的一些细节，这将在我们的实例使用到。这个回调提供了一个从 SELECT 语句获得结果的方式。它声明如下： 123456typedef int (*sqlite3_callback)(void*, /* Data provided in the 4th argument of sqlite3_exec() */int, /* The number of columns in row */char**, /* An array of strings representing fields in the row */char** /* An array of strings representing column names */); 如果上面的回调在 sqlite_exec() 程序中作为第三个参数，那么 SQLite 将为 SQL 参数内执行的每个 SELECT 语句中处理的每个记录调用这个回调函数。 下面的 C 代码段显示了如何从前面创建的 COMPANY 表中获取并显示记录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt;static int callback(void *data, int argc, char **argv, char **azColName)&#123; int i; fprintf(stderr, &quot;%s: &quot;, (const char*)data); for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; const char* data = &quot;Callback function called&quot;; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create SQL statement */ sql = &quot;SELECT * from COMPANY&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, (void*)data, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Operation done successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会产生以下结果： Opened database successfully Callback function called: ID = 1 NAME = Paul AGE = 32 ADDRESS = California SALARY = 20000.0 Callback function called: ID = 2 NAME = Allen AGE = 25 ADDRESS = Texas SALARY = 15000.0 Callback function called: ID = 3 NAME = Teddy AGE = 23 ADDRESS = Norway SALARY = 20000.0 Callback function called: ID = 4 NAME = Mark AGE = 25 ADDRESS = Rich-Mond SALARY = 65000.0 Operation done successfully UPDATE 操作下面的 C 代码段显示了如何使用 UPDATE 语句来更新任何记录，然后从 COMPANY 表中获取并显示更新的记录： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt; static int callback(void *data, int argc, char **argv, char **azColName)&#123; int i; fprintf(stderr, &quot;%s: &quot;, (const char*)data); for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; const char* data = &quot;Callback function called&quot;; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create merged SQL statement */ sql = &quot;UPDATE COMPANY set SALARY = 25000.00 where ID=1; &quot; \\ &quot;SELECT * from COMPANY&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, (void*)data, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Operation done successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会产生以下结果： Opened database successfully Callback function called: ID = 1 NAME = Paul AGE = 32 ADDRESS = California SALARY = 25000.0 Callback function called: ID = 2 NAME = Allen AGE = 25 ADDRESS = Texas SALARY = 15000.0 Callback function called: ID = 3 NAME = Teddy AGE = 23 ADDRESS = Norway SALARY = 20000.0 Callback function called: ID = 4 NAME = Mark AGE = 25 ADDRESS = Rich-Mond SALARY = 65000.0 Operation done successfully DELETE 操作下面的 C 代码段显示了如何使用 DELETE 语句删除任何记录，然后从 COMPANY 表中获取并显示剩余的记录： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt; static int callback(void *data, int argc, char **argv, char **azColName)&#123; int i; fprintf(stderr, &quot;%s: &quot;, (const char*)data); for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; const char* data = &quot;Callback function called&quot;; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create merged SQL statement */ sql = &quot;DELETE from COMPANY where ID=2; &quot; \\ &quot;SELECT * from COMPANY&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, (void*)data, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Operation done successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会产生以下结果： Opened database successfully Callback function called: ID = 1 NAME = Paul AGE = 32 ADDRESS = California SALARY = 20000.0 Callback function called: ID = 3 NAME = Teddy AGE = 23 ADDRESS = Norway SALARY = 20000.0 Callback function called: ID = 4 NAME = Mark AGE = 25 ADDRESS = Rich-Mond SALARY = 65000.0 Operation done successfully 使用sqlite3指令SELECT * FROM COMPANY;可以查看数据列表 Select 语句SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。 语法SQLite 的 SELECT 语句的基本语法如下： SELECT column1, column2, columnN FROM table_name; SELECT * FROM table_name; Schema 信息因为所有的点命令只在 SQLite 提示符中可用，所以当您进行带有 SQLite 的编程时，您要使用下面的带有 sqlite_master 表的 SELECT 语句来列出所有在数据库中创建的表： 1sqlite&gt; SELECT tbl_name FROM sqlite_master WHERE type = &#x27;table&#x27;; 您可以列出关于 COMPANY 表的完整信息，如下所示： 1sqlite&gt; SELECT sql FROM sqlite_master WHERE type = &#x27;table&#x27; AND tbl_name = &#x27;COMPANY&#x27;; Like 子句SQLite 的 LIKE 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用： 百分号 （%） 下划线 （_） 百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。 Glob 子句SQLite 的 GLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。 星号 （*） 问号 （?） 星号（*）代表零个、一个或多个数字或字符。问号（?）代表一个单一的数字或字符。这些符号可以被组合使用。 Where 子句SQLite的 WHERE 子句用于指定从一个表或多个表中获取数据的条件。 如果满足给定的条件，即为真（true）时，则从表中返回特定的值。您可以使用 WHERE 子句来过滤记录，只获取需要的记录。 WHERE 子句不仅可用在 SELECT 语句中，它也可用在 UPDATE、DELETE 语句中，等等 Update 语句SQLite 的 UPDATE 查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。 Distinct 关键字SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。 有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。 事务控制使用下面的命令来控制事务： BEGIN ：开始事务处理。 COMMIT：保存更改，或者可以使用 END TRANSACTION 命令。 ROLLBACK：回滚所做的更改。 事务控制命令只与 DML 命令 INSERT、UPDATE 和 DELETE 一起使用。他们不能在创建表或删除表时使用，因为这些操作在数据库中是自动提交的。 BEGIN 命令事务（Transaction）可以使用BEGIN 命令来启动。此类事务通常会持续执行下去，直到遇到下一个 COMMIT 或 ROLLBACK 命令。不过在数据库关闭或发生错误时，事务处理也会回滚。 COMMIT 命令COMMIT 命令是用于把事务调用的更改保存到数据库中的事务命令。自上次 COMMIT 或 ROLLBACK 命令以外的所有事务保存到数据库。 ROLLBACK 命令ROLLBACK 命令是用于撤消尚未保存到数据库的事务的事务命令。 ROLLBACK 命令只能用于撤销自上次发出 COMMIT 或 ROLLBACK 命令以外的事务。 实例开始一个事务，并从表中删除 age &#x3D; 25 的记录，最后，我们使用 ROLLBACK 命令撤消所有的更改。 123sqlite&gt; BEGIN;sqlite&gt; DELETE FROM COMPANY WHERE AGE = 25;sqlite&gt; ROLLBACK; 检查 COMPANY 表，仍然有记录 开始另一个事务，从表中删除 age &#x3D; 25 的记录，最后我们使用 COMMIT 命令提交所有的更改。 123sqlite&gt; BEGIN;sqlite&gt; DELETE FROM COMPANY WHERE AGE = 25;sqlite&gt; COMMIT; 基础操做 显示表1.tables 显示概要1.schema sqlite_master 格式化显示123456789显示头sqlite&gt;.header on按列显示sqlite&gt;.mode column显示运行时间sqlite&gt;.timer on设置输出列的宽度sqlite&gt;.width 10, 20, 10sqlite&gt;SELECT * FROM COMPANY; 主键自动增加&#x2F;&#x2F;历史最大值增加1ID INTEGER PRIMARY KEY AUTOINCREMENT 删除表1drop table company; 增加列12alter table company add column DATE char(20);alter table company add column TIME char(10); 删除列1alter table company drop column test; 添加时间日期1insert into company values(6,&#x27;huang&#x27;,31,&#x27;guangzhou&#x27;,8999,date(&#x27;now&#x27;,&#x27;localtime&#x27;),time(&#x27;now&#x27;,&#x27;localtime&#x27;)); 自动时间123...DATE TIMESTAMP NOT NULL DEFAULT(date(&#x27;now&#x27;,&#x27;localtime&#x27;)),TIME TIMESTAMP NOT NULL DEFAULT(time(&#x27;now&#x27;,&#x27;localtime&#x27;)) 筛选时间1select * from company where time &gt;time(&#x27;12:00:00&#x27;); 修改内容1update company set name=&#x27;gcc&#x27; where id=18; 去重1SELECT DISTINCT name FROM COMPANY; 筛选计数1SELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2; 排序1SELECT * FROM COMPANY ORDER BY SALARY ASC; 字符加前缀1update work set date=&#x27;2024-&#x27;||date; 列求和1select sum(time) from work;","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"数据库","slug":"linux/数据库","permalink":"http://example.com/categories/linux/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"ssh和git","slug":"linux/ssh","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.323Z","comments":true,"path":"2024/12/24/linux/ssh/","permalink":"http://example.com/2024/12/24/linux/ssh/","excerpt":"","text":"ssh免密登录秘钥加入主机1ssh-copy-id 重启服务123sudo systemctl restart sshsudo server ssh restart 测试连接server 1/usr/sbin/sshd -d -p 2222 client 1ssh ... -p 2222 新用户ssh登录123456sudo useradd gitsudo passwd gitsudo chmod 700 .sshsudo chmod 600 authorized_keyssudo chmod 755 /home/username Git服务 新建仓库1git init --bare test 客户端1git clone git@192.168.1.10：/home/git/test 客户端现有文件夹1234git add --all .git commit -m &quot;test project init&quot;git remote add origin git@192.168.1.10：/home/git/testgit push origin master Gitlab参考 树莓派gitlab下载 安装依赖 1sudo apt-get install curl openssh-server ca-certificates postfix apt-transport-https 安装包 1sudo dpkg -i gitlab-ce_8.13.0-ce.0_armhf.deb 运行 1sudo gitlab-ctl reconfigure 修改服务端口默认使用80端口，如果需要修改，可以修改&#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb 常用维护指令 1234567891011121314151617181920#修改任何配置文件后都要输入如下命令使配置生效。sudo gitlab-ctl reconfigure #页面缓存清除：sudo gitlab-rake cache:clear RAILS_ENV=production #GitLab各组件启动：sudo gitlab-ctl start #GitLab各组件停止：sudo gitlab-ctl stop #GitLab各组件重启：sudo gitlab-ctl restart #禁用GitLab开机自启动：sudo systemctl disable gitlab-runsvdir #启用GitLab开机自启动：sudo systemctl enable gitlab-runsvdir Gitea轻量化，占用资源少,在树莓派上安装和运行Gitea，可以遵循以下步骤： 更新系统包并安装必要的依赖： 12sudo apt-get updatesudo apt-get install -y curl policycoreutils openssh-server 下载Gitea二进制文件： 1curl -L https://github.com/go-gitea/gitea/releases/download/v1.20.0/gitea-linux-arm64 -o gitea 使二进制文件可执行： 1chmod +x gitea 移动Gitea到&#x2F;usr&#x2F;local&#x2F;bin目录并创建一个systemd服务文件： 12sudo mv gitea /usr/local/bin/giteasudo nano /etc/systemd/system/gitea.service 在gitea.service文件中添加以下内容： 123456789101112131415[Unit]Description=Gitea (Git with a cup of tea)After=syslog.targetAfter=network.target [Service]RestartSec=2sType=simpleUser=rootExecStart=/usr/local/bin/gitea web --config /etc/gitea/app.iniRestart=alwaysEnvironment=USER=root [Install]WantedBy=multi-user.target 重新加载systemd守护进程，使其识别新的服务文件，并启动Gitea服务： 123sudo systemctl daemon-reloadsudo systemctl start giteasudo systemctl enable gitea 配置防火墙允许访问Gitea： 12sudo ufw allow &#x27;Nginx Full&#x27;sudo ufw enable 访问http:&#x2F;&#x2F;:3000来设置和运行Gitea。 修改配置初次修改，通过网页选择custom&#x2F;conf&#x2F;app.ini 文件夹大小 1du -sh Gitea 修改远程仓库 1git remote set-url origin https://gitee.com/gxswift/ctest.git","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"ssh","slug":"linux/ssh","permalink":"http://example.com/categories/linux/ssh/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"ssh","slug":"ssh","permalink":"http://example.com/tags/ssh/"}]},{"title":"TFTP NFS","slug":"linux/tftp","date":"2024-12-24T01:43:25.000Z","updated":"2025-01-02T05:32:05.581Z","comments":true,"path":"2024/12/24/linux/tftp/","permalink":"http://example.com/2024/12/24/linux/tftp/","excerpt":"","text":"NFS 安装NFS软件包12sudo apt-get install nfs-kernel-server #安装服务器sudo apt-get install nfs-common #安装客户端 添加共享目录12sudo vi /etc/exports #打开文件/nfsroot *(rw,sync,no_root_squash)#将/nfsroot 目录设置为NFS共享目录 ，*代表允许任意IP访问 建立文件夹，设置权限123sudo mkdir /nfsrootsudo chmod -R 777 /nfsrootsudo chown -R nobody /nfsroot 启动NFS服务1sudo /etc/init.d/nfs-kernel-server start #重启restart 客户端挂载1sudo mount -t nfs -o vers=4 192.168.123.123:/nfs /mnt -o nolock 卸载1sudo umount /mnt TFTPtftpd或xinetd 安装软件包1sudo apt-get install tftpd-hpa tftp-hpa #安装服务器和客户端 配置12345678910111213141516sudo vi /etc/default/tftp-hpa #打开文件sudo vi /etc/xinetd.d/tftpservice tftp&#123; socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s /tftpboot disable = no per_source = 11 cps = 100 2 flags = IPv4&#125; 建立文件夹，设置权限123sudo mkdir /tftpsudo chmod -R 777 /tftpsudo chown -R nobody /tftp 启动NFS服务123sudo service tftpd-hpa start #重启restartsudo service xinetd start 客户端挂载1234&gt;tftp ip#连接&gt;get file#下载&gt;put file#上传&gt;q#退出 SAMBAwindows常用的共享文件夹服务 安装服务 1sudo apt-get install samba 如果不小心删除了配置文件，可以通过： 12sudo apt purge samba-common sambasudo apt install samba 创建samba用户samba使用Linux的用户和权限系统，但是有自己的认证机制。samba用户首先要是一个Linux用户，不然是创建不成功的。创建一个Linux用户 1sudo useradd -s /bin/bash -m username -m 是在home目录自动创建一个username目录创建一个smb用户sudo smbpasswd -a username手动输入两遍密码即可,其他操作可以通过smbpass -h查看创建共享目录 使用username用户在家目录创建一个共享目录mkdir samba 修改配置 vim &#x2F;etc&#x2F;samba&#x2F;smb.conf保证 server role 是 standalone server（默认情况下就是如此）server role &#x3D; standalone server添加共享配置 123456789101112131415[samba] path = /home/username/samba browseable = yes read only = no# force create mode = 0660# force directory mode = 2770 valid users = username# 下面是一个匿名只读配置[share] path = /mnt/samba browsable =yes writable = no guest ok = yes read only = yes 全局设置 workgroup：此选项设置了Samba服务器所属的工作组或域名，如workgroup = WORKGROUP。 server string：这是Samba服务器的简短描述，例如server string = %h server (Samba,Ubuntu)。 security：设置安全模式，常见的模式有share、user、server、domain和ads。例如security = user指定需要用户名和密码才能访问共享资源。 passdb backend：定义用户密码数据库的后端类型，如passdb backend = tdbsam表示使用TDB数据库来存储用户验证信息。 encrypt passwords：此选项控制是否对密码进行加密，为了与现代Windows系统兼容通常设置为yes。 共享定义 comment：为共享资源添加描述性注释，如comment = Public Share。 path：指定共享资源的完整路径，如path = /home/public。 browseable：此选项设置共享是否可以在网络邻居中被浏览，如browseable = yes。通过设置为no，其他用户将看不到共享。 guest ok：设置是否允许匿名访问共享，如guest ok = no表示禁止匿名访问。 valid users：指定允许访问共享资源的用户或组，如valid users = @tech, manager。 read only：控制共享资源是否为只读，如read only = yes表示共享目录只能读取不可写入。 重新启动Samba服务 1sudo systemctl restart smbd.service windows删除远程连接弹窗不允许一个用户使用一个以上用户名与服务器 1net use * /del /y","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"TFTP","slug":"TFTP","permalink":"http://example.com/tags/TFTP/"},{"name":"NFS","slug":"NFS","permalink":"http://example.com/tags/NFS/"}]},{"title":"VIM","slug":"linux/vim","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.323Z","comments":true,"path":"2024/12/24/linux/vim/","permalink":"http://example.com/2024/12/24/linux/vim/","excerpt":"","text":"vim操作 移动追加删除复制粘贴查找多文件操作其他 指令 含义 例子 移动 l or 右箭头 向右移动一个字符 h or 左箭头 向左移动一个字符 j or 下箭头 向下移动一行 k or 上箭头 向上移动一行 0 (零按键) 移动到当前行的行首。 ^ 移动到当前行的第一个非空字符。 $ 移动到当前行的末尾。 w 移动到下一个单词或标点符号的开头。 W 移动到下一个单词的开头，忽略标点符号。 b 移动到上一个单词或标点符号的开头。 B 移动到上一个单词的开头，忽略标点符号。 Ctrl-f or Page Down 向下翻一页 Ctrl-b or Page Up 向上翻一页 Ctrl-d 向下翻半页 Ctrl-u 向上翻半页 numberG or number 移动到第number 行。 1(G) 移动到文件的第一行,命令前加数字，为命令执行次数 G 移动到文件末尾。 追加 i 光标前插入 I 行前插入 a 光标后插入 A 行后插入 o 当前行的下方打开一行。 O 当前行的上方打开一行。 删除 x 当前字符 3x当前字符及其后的两个字符。 dd 当前行。 5dd 当前行及随后的四行文本。 dW 从光标位置开始到下一个单词的开头。 d$ 从光标位置开始到当前行的行尾。 d0 从光标位置开始到当前行的行首。 d^ 从光标位置开始到文本行的第一个非空字符。 dG 从当前行到文件的末尾。 d20G 从当前行到文件的第20 行。 复制粘贴 yy 当前行。 5yy 当前行及随后的四行文本。 yW 从当前光标位置到下一个单词的开头。 y$ 从当前光标位置到当前行的末尾。 y0 从当前光标位置到行首。 y^ 从当前光标位置到文本行的第一个非空字符。 yG 从当前行到文件末尾。 y20G 从当前行到文件的第20 行。 p 粘贴到当前行的下面 查找和替换 &#x2F; 查找 &#x2F;foo查找foo，\\c表示大小写不敏感查找，\\C表示大小写敏感查找 n 下一个 N 前一个 s 替换{作用范围}s&#x2F;{目标}&#x2F;{替换}&#x2F;{替换标志} %s&#x2F;foo&#x2F;bar&#x2F;g会在全局范围(%)查找foo并替换为bar，所有出现都会被替换(g) s&#x2F;foo&#x2F;bar&#x2F;g替换当前行 %s&#x2F;foo&#x2F;bar&#x2F;i。i表示大小写不敏感查找，I表示大小写敏感，%表示第一行到最后一行，或者用1,5代替 多文件操作 n 下一个文件 N 前一个文件 buffers 查看文件列表 其他 J 删除当前行最后回车，连接下一行 w 写入 q 退出 ! 强制","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"vim","slug":"linux/vim","permalink":"http://example.com/categories/linux/vim/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://example.com/tags/vim/"}]},{"title":"i.mx6ull开发板","slug":"linux/zdyz","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-30T08:06:31.473Z","comments":true,"path":"2024/12/24/linux/zdyz/","permalink":"http://example.com/2024/12/24/linux/zdyz/","excerpt":"","text":"正点原子i.mx6ull开发板练习WIFI开启网卡12ifconfig wlan0 up // 若默认没打开 wlan0 则需要执行此项。ifconfig 搜索12wpa_cli -i wlan0 scan_result // 此指令需要启动进入后再插 WIFI 才生效，需要 wpa_supplicant 在运行。 连接1source ./alientek_usb_wifi_setup.sh -m station -i ALIENTEK-YF -p 1590202**** -d wlan0 参数解释： -m station ：设置成 station 模式 -i ALIENTEK-YF ：无线网络名称(ssid)。 -p 1590202**** ：无线网络密码(psk)。 -d wlan0 ：USB WIFI 节点 例如: 1source ./shell/wifi/alientek_usb_wifi_setup.sh -m station -i senmun2022 -p senmun150@ -d wlan0 Ubuntu桥接,设置ip为同网段 1sudo mount -t nfs 192.168.1.100:/home/alientek/linux/nfs /mnt -o nolock 提示mount.nfs: an incorrect mount option was specified 1sudo mount -t nfs -o vers=4 192.168.1.100:/home/alientek/linux/nfs /mnt 描述1/home/alientek/linux/nfs *(rw,sync,no_root_squash) 编译环境 1source /opt/fsl-imx-x11/4.1.15-2.1.0/environment-setup-cortexa7hf-neon-poky-linux-gnueabi 编译文件路径 开机启动项&#x2F;etc&#x2F;rc.local 开机启动程序#注释 1/opt/QDesktop &gt;/dev/null 2&gt;&amp;1 设置IP1234PATH=/sbin:/bin:/usr/sbin:/usr/binifconfig eth0 192.168.1.115 netmask 255.255.255.0route add default gw 192.168.1.1echo &quot;nameserver 114.114.114.114&quot; &gt; /etc/resolv.conf QT摄像头人脸识别12345678910111213141516171819202122232425262728int main()&#123; //-------------------------------------------------- //添加人脸识别 cv::CascadeClassifier faceCascade; // 级联分类器 faceCascade.load(&quot;Resources/haarcascade_frontalface_default.xml&quot;); // 加载训练好的haar人脸正脸xml配置文件 if (faceCascade.empty()) &#123; printf( &quot;XML file not loaded\\n&quot;); &#125; else &#123; std::vector&lt;cv::Rect&gt; faces; // 人脸的矩形数组 faceCascade.detectMultiScale(frame, faces, 1.1, 3); // 比例因子 人脸大小 if(faces.size() &gt; 0) &#123; for (int i = 0; i &lt; faces.size(); i++) &#123; rectangle(frame, faces[i].tl(), faces[i].br(), cv::Scalar(255, 0, 255), 2); // 在原图上绘制人脸矩形区域，颜色为粉色，线条厚度为3像素 &#125; &#125; &#125; //--------------------------------------------------&#125;-lopencv_objdetect 文件颜色白色：表示普通文件 蓝色：表示目录（文件夹） 绿色：表示可执行文件 红色：表示压缩文件，文件包。 粉红色：图片；Socket文件 浅蓝色：链接文件（软链接，硬链接） 红色闪烁：表示链接的文件有问题 黄色：表示设备文件（ /dev目录下：物理块设备(b)、字符终端设备?） 灰色：表示其他文件 青黄色 ：管道文件 ( p) 挂载U盘1234567891011# 识别u盘lsblk# 挂载sudo mount /dev/sdb1 /mnt/usb# 验证结果df -h# 卸载sudo umount /mnt/usb","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"开发板","slug":"linux/开发板","permalink":"http://example.com/categories/linux/%E5%BC%80%E5%8F%91%E6%9D%BF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"开发板","slug":"开发板","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"}]},{"title":"linux压缩","slug":"linux/zip","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.325Z","comments":true,"path":"2024/12/24/linux/zip/","permalink":"http://example.com/2024/12/24/linux/zip/","excerpt":"","text":"linux tar命令 压缩、打包、解压 详解1、常用压缩命令tar -czvf 压缩后的文件.tar.gz 要压缩的文件 2、常用解压命令tar -xzvf 解压后的文件.tar.gz 【要解压的目录】 3、参数意义-c: 建立压缩档案 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 -j: 有bz2属性的 -O: 将文件解开到标准输出 -r: 向压缩归档文件末尾追加文件 -t: 查看内容 -u: 更新原压缩包中的文件 -v: 显示所有过程 -x: 解压 -z: 有gzip属性的 -Z: 有compress属性的 4、总结*.tar 用 tar -xvf 解压 *.gz 用 gzip -d或者gunzip 解压 .tar.gz和.tgz 用 tar -xzf 解压 *.bz2 用 bzip2 -d或者用bunzip2 解压 *.tar.bz2用tar -xjf 解压 *.Z 用 uncompress 解压 *.tar.Z 用tar -xZf 解压 *.rar 用 unrar e解压 *.zip 用 unzip 解压","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"压缩","slug":"linux/压缩","permalink":"http://example.com/categories/linux/%E5%8E%8B%E7%BC%A9/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"压缩","slug":"压缩","permalink":"http://example.com/tags/%E5%8E%8B%E7%BC%A9/"}]},{"title":"lvgl仿真","slug":"lvgl/lvglsim","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.325Z","comments":true,"path":"2024/12/24/lvgl/lvglsim/","permalink":"http://example.com/2024/12/24/lvgl/lvglsim/","excerpt":"","text":"LVGL仿真Linux一、基于SDL2 SDL2安装 安装地址URL1234url：http://www.libsdl.org/download-2.0.php./configure make sudo make install 或者1sudo apt-get update &amp;&amp; sudo apt-get install -y build-essential libsdl2-dev 下载基于SDL2编译的包1git clone --recursive https://github.com/lvgl/lv_sim_vscode_sdl 编译运行1./bulid/bin/demo 提示error while loading shared libraries libSDL-1.2.so.0没找到库，需重新安装1sudo apt-get install --reinstall libsdl1.2debian 旧的仿真环境删除，由lv_port_pc_eclipse替换1https://github.com/lvgl/lv_port_pc_eclipse.git 12CFLAGS ?= -O3 -I$(LVGL_DIR)/ $(WARNINGS) -I../SDL2-2.0.14/_instal/includeLDFLAGS ?= -L../SDL2-2.0.14/_instal/lib -lSDL2 -lm -lpthread 运行1./demo 二、基于framebuffer 下载源码 1git clone --recursive https://github.com/lvgl/lv_port_linux_frame_buffer 编译后 打开命令行终端 1ctrl+alt+F2 #(1234)退出F7 Windows同linux基于SDL2 下载windows SDL2 mingw32安装SDL2 i686-w64-mingw32复制到环境路径 1where g++ 若提示_beginthreadex _endthreadex错误,则因为mingw32版本不够，需改动main.c 123#include &lt;windows.h&gt;// SDL_CreateThread(tick_thread, &quot;tick&quot;, NULL);CreateThread(NULL,0,tick_thread,0,0,0); 使用lv_port_pc_eclipse lib&#x2F;libSDL2.dll.a和include&#x2F;SDL2放入对应文件夹，删除makefile多余规则 WSL最简洁 安装SDL2库1sudo apt install libsdl2-dev 使用lv_port_pc_vscode1git clone --recursive https://github.com/lvgl/lv_port_pc_vscode 编译运行1cmake -B build 字体仿真修改取字库文件 12345678910111213141516171819static uint8_t *__user_font_getdata(int offset, int size)&#123; //如字模保存在SPI FLASH, SPIFLASH_Read(__g_font_buf,offset,size); //如字模已加载到SDRAM,直接返回偏移地址即可(sdram_fontddr+offset); FILE *fp; fp=fopen(&quot;/d/myFont2.bin&quot;,&quot;rb&quot;); if (fp == 0) &#123; LV_LOG_WARN(&quot;open error&quot;); &#125; else &#123; // LV_LOG_WARN(&quot;open OK&quot;); fseek(fp,offset,SEEK_SET); fread(__g_font_buf,size,1,fp); fclose(fp); &#125; return __g_font_buf;&#125;","categories":[{"name":"lvgl","slug":"lvgl","permalink":"http://example.com/categories/lvgl/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"lvgl","slug":"lvgl","permalink":"http://example.com/tags/lvgl/"}]},{"title":"lvgl移植","slug":"lvgl/lvgluse","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.325Z","comments":true,"path":"2024/12/24/lvgl/lvgluse/","permalink":"http://example.com/2024/12/24/lvgl/lvgluse/","excerpt":"","text":"LVGL移植初始化需要1234lv_init();lv_port_disp_init(); // 显示器初始化lv_port_indev_init(); // 输入设备初始化（如果没有实现就注释掉）lv_port_fs_init(); // 文件系统设备初始化（如果没有实现就注释掉） 修改lvgl&#x2F;src&#x2F;examples&#x2F;porting下接口显示接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;lv_port_disp.h&quot;#include &quot;lvgl/lvgl.h&quot;#include &quot;lcd.h&quot;static void disp_init(void);static void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p);#define MY_DISP_HOR_RES (320)void lv_port_disp_init(void)&#123; /*------------------------- * Initialize your display * -----------------------*/ disp_init(); static lv_disp_draw_buf_t draw_buf_dsc_1; static lv_color_t buf_1[MY_DISP_HOR_RES * 10]; /*A buffer for 10 rows*/ lv_disp_draw_buf_init(&amp;draw_buf_dsc_1, buf_1, NULL, MY_DISP_HOR_RES * 10); /*Initialize the display buffer*/ static lv_disp_drv_t disp_drv; /*Descriptor of a display driver*/ lv_disp_drv_init(&amp;disp_drv); /*Basic initialization*/ /*Set up the functions to access to your display*/ /*Set the resolution of the display*/ disp_drv.hor_res = 320; disp_drv.ver_res = 480; /*Used to copy the buffer&#x27;s content to the display*/ disp_drv.flush_cb = disp_flush; /*Set a display buffer*/ disp_drv.draw_buf = &amp;draw_buf_dsc_1; lv_disp_drv_register(&amp;disp_drv);&#125;static void disp_init(void)&#123; /*You code here*/ LCD_Init();&#125;static void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p)&#123; /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/ int32_t x; int32_t y; LCD_SetWindow(area-&gt;x1, area-&gt;y1, area-&gt;x2, area-&gt;y2); for(y = area-&gt;y1; y &lt;= area-&gt;y2; y++) &#123; for(x = area-&gt;x1; x &lt;= area-&gt;x2; x++) &#123; /*Put a pixel to the display. For example:*/ /*put_px(x, y, *color_p)*/ LCD_WRITE_DATA(*(uint16_t*)color_p); color_p++; &#125; &#125; // LCD_Draw(area-&gt;x1,area-&gt;y1,area-&gt;x2,area-&gt;y2,(uint16_t *)color_p); /*IMPORTANT!!! *Inform the graphics library that you are ready with the flushing*/ lv_disp_flush_ready(disp_drv);&#125; 输入设备 1234567891011121314151617181920212223242526272829303132333435363738static void touchpad_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data)&#123; static lv_coord_t last_x = 0; static lv_coord_t last_y = 0; /*Save the pressed coordinates and the state*/ /*Save the pressed coordinates and the state*/ if(!XPT2046_EXTI_Read()) &#123; touchpad_get_xy(&amp;last_x, &amp;last_y); data-&gt;state = LV_INDEV_STATE_PR; printf(&quot;x=%d,y=%d\\r\\n&quot;,last_x,last_y); &#125; else &#123; data-&gt;state = LV_INDEV_STATE_REL; &#125; /*Set the last pressed coordinates*/ data-&gt;point.x = last_x; data-&gt;point.y = last_y;&#125;/*Return true is the touchpad is pressed*/static bool touchpad_is_pressed(void)&#123; /*Your code comes here*/ return false;&#125;/*Get the x and y coordinates if the touchpad is pressed*/static void touchpad_get_xy(lv_coord_t * x, lv_coord_t * y)&#123; /*Your code comes here*/ (*x) = 319-XPT2046_ReadAdc_Fliter(XPT2046_CHANNEL_Y)*320/4095; (*y) = 479-XPT2046_ReadAdc_Fliter(XPT2046_CHANNEL_X)*480/4095;//4095-&#125; 文件系统 心跳1~10，一般取51234lv_tick_inc( tick );lv_task_handler();lv_conf.h GUI Guider","categories":[{"name":"lvgl","slug":"lvgl","permalink":"http://example.com/categories/lvgl/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"lvgl","slug":"lvgl","permalink":"http://example.com/tags/lvgl/"}]},{"title":"express","slug":"nodejs/express","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.337Z","comments":true,"path":"2024/12/24/nodejs/express/","permalink":"http://example.com/2024/12/24/nodejs/express/","excerpt":"","text":"一、安装Node.js进入Node.js官网下载并安装，选exe,添加环境变量 在使用npm命令时，如果直接从国外的仓库下载依赖，有时候下载速度很慢，甚至会下载不下来。这时我们可以更换npm的仓库源，提高下载速度。 查看npm源地址： 1npm config get registry 更换npm源为淘宝镜像： 1npm config set registry https://registry.npm.taobao.org/ 如果设置了npm为淘宝镜像，需要恢复为默认源时： 1npm config set registry https://registry.npmjs.org/ 设置好之后，记得通过 npm config get registry 查看源是否设置成功。 注意：如果只是想临时更换源地址，可以进行如下操作: 1npm install packagname -g --registry=https://registry.npm.taobao.org 国内npm源地址 12345678npm 官方原始镜像：https://registry.npmjs.org/淘宝 NPM 镜像：https://registry.npm.taobao.org阿里云 NPM 镜像：https://npm.aliyun.com腾讯云 NPM 镜像：https://mirrors.cloud.tencent.com/npm/华为云 NPM 镜像：https://mirrors.huaweicloud.com/repository/npm/网易 NPM 镜像：https://mirrors.163.com/npm/中科院大学开源镜像站：http://mirrors.ustc.edu.cn/清华大学开源镜像站：https://mirrors.tuna.tsinghua.edu.cn/ 二、安装express和express-generator12npm install -g expressnpm install -g express-generator 三、生成项目在项目名称的后面添加 -e 那么创建出来的模板文件就是.ejs类型，语法是与html相同 1express APP_NAME -e 四、使用框架index.ejs内容修改，跳转html 12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; window.location.replace(&quot;index.html&quot;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模板web网页全部放入public文件夹下 其他将ejs文件改为html若希望模板文件的后缀为.html(通常只是为了看着更舒服)，那么在手动将.ejs换成.html后，还需要对app.js文件进行设置 123// view engine setupapp.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;); 12345app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.engine(&#x27;.html&#x27;, require(&#x27;ejs&#x27;).__express);app.set(&#x27;view engine&#x27;, &#x27;html&#x27;); //app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;); 渲染将需要渲染的文件放入views文件，静态文件放入public文件夹放入views的文件，需要在index.js中添加路由，类似 1234567891011router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.render(&#x27;index&#x27;, &#123; title: &#x27;Express /&#x27; &#125;);&#125;);router.get(&#x27;/index.html&#x27;, function(req, res, next) &#123; res.render(&#x27;index&#x27;, &#123; title: &#x27;Express index&#x27; &#125;);&#125;);router.get(&#x27;/services.html&#x27;, function(req, res, next) &#123; res.render(&#x27;services&#x27;, &#123; title: &#x27;Express2&#x27; &#125;);&#125;); 显示所有图片示例123&lt;% for(let i = 0 ; i&lt;image.length ; i++)&#123; %&gt;&lt;img loading=&quot;lazy&quot; src=&lt;%= image[i] %&gt; alt=&quot;Smiley face&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;% &#125; %&gt; 12345678910111213/* GET home page. */router.get(&#x27;/&#x27;, function (req, res, next) &#123; res.render(&#x27;index&#x27;, &#123; title: &#x27;Express&#x27;, display: &quot;image&quot;, image: function () &#123; var re = fs.readdirSync(&#x27;public/images&#x27;) for (i = 0; i &lt; re.length; i++) re[i] = &#x27;images/&#x27; + re[i]; return re; &#125;(), &#125;);&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/tags/nodejs/"},{"name":"express","slug":"express","permalink":"http://example.com/tags/express/"}]},{"title":"nodejs传文件","slug":"nodejs/sendfile","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.337Z","comments":true,"path":"2024/12/24/nodejs/sendfile/","permalink":"http://example.com/2024/12/24/nodejs/sendfile/","excerpt":"","text":"nodejs传文件1234567891011121314151617181920212223242526272829303132333435const fs = require(&#x27;fs&#x27;)const pathLib = require(&#x27;path&#x27;)var objMulter = multer(&#123;dest: &#x27;./upload/&#x27;&#125;)// 基于express框架的node服务器var server = express()// 允许所有类型的文件传递过来server.use(objMulter.any())server.post(&#x27;/&#x27;, function(req,res)&#123; // 因为上传过来的文件名称比较复杂,我们需要给文件重新命名 var newName = req.files[0].path+pathLib.parse(req.files[0].originalname).ext // 利用fs模块的文件重命名 // req.files[0].path这个是文件的在传递中被修改的名字，newName是文件原名称,function回调函数 fs.rename(req.files[0].path, newName, function(err)&#123; if(err)&#123; res.send(&#x27;失败&#x27;) &#125;else&#123; res.send(&#x27;成功&#x27;) &#125; &#125;)&#125;)server.get(&#x27;/&#x27;, function (req, res) &#123; /*res.send(&quot;./upload.html&quot;);*/ console.log(&quot;connect&quot;); res.sendFile(&quot;index.html&quot;,&#123;root:__dirname&#125;);&#125;) // 监听端口var app = server.listen(8081,&#x27;192.168.168.238&#x27;,function()&#123; var host = app.address().address var port = app.address().port console.log(&quot;地址为 http://%s:%s&quot;, host, port) &#125;); 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 文件：&lt;input type=&quot;file&quot; name=&quot;f1&quot; /&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/tags/nodejs/"},{"name":"express","slug":"express","permalink":"http://example.com/tags/express/"}]},{"title":"RTT Viewer","slug":"openocd/RTT_Viewer","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.327Z","comments":true,"path":"2024/12/24/openocd/RTT_Viewer/","permalink":"http://example.com/2024/12/24/openocd/RTT_Viewer/","excerpt":"","text":"pyOCD显示目标 1pyocd list --target RTT连接 1pyocd rtt -t STM32H750VBTx 如果不能显示，需要加地址(.bss段) 1.bss 0x20000838 Section 1208 segger_rtt.o(.bss) 1pyocd rtt -t target -a `address` 搜索包 1pyocd pack find STM32H750VB 安装包 1pyocd pack install STM32H750VB 烧录 1pyocd flash -t nrf52 xx.hex 擦除 1pyocd erase -t nrf52","categories":[{"name":"OCD","slug":"OCD","permalink":"http://example.com/categories/OCD/"},{"name":"pyocd","slug":"OCD/pyocd","permalink":"http://example.com/categories/OCD/pyocd/"}],"tags":[{"name":"OCD","slug":"OCD","permalink":"http://example.com/tags/OCD/"},{"name":"pyocd","slug":"pyocd","permalink":"http://example.com/tags/pyocd/"}]},{"title":"gdb","slug":"openocd/arm-none-eabi-gdb","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.327Z","comments":true,"path":"2024/12/24/openocd/arm-none-eabi-gdb/","permalink":"http://example.com/2024/12/24/openocd/arm-none-eabi-gdb/","excerpt":"","text":"arm-none-eabi-gdb使用说明文档1C:\\Program Files (x86)\\GNU Arm Embedded Toolchain\\9 2020-q2-update\\share\\doc\\gcc-arm-none-eabi\\pdf\\gdb.pdf 使用12345#-ex使用外部指令arm-none-eabi-gdb *.elf -ex &quot;target remote localhost:3333&quot;#也可指令分开arm-none-eabi-gdb *.elftarget remote localhost:3333 常用指令 指令 含义 例子 备注 monitor cmd 执行指令 reset halt load c continue 继续执行 s step 单步执行 b break 断点 b main.c:111 main.c 111行 b test 函数test b if a == 1 条件 b if a = 1 赋值 n next 下一断点 u until 到达指定位置 f frame 当前断点 finish 退出函数 i info 显示信息 d delete 删除显示 断点 display 显示变量，每次停顿都显示 p print 打印变量 q quit 退出 where 位置 list 显示代码","categories":[{"name":"OCD","slug":"OCD","permalink":"http://example.com/categories/OCD/"},{"name":"gdb","slug":"OCD/gdb","permalink":"http://example.com/categories/OCD/gdb/"}],"tags":[{"name":"OpenOCD","slug":"OpenOCD","permalink":"http://example.com/tags/OpenOCD/"},{"name":"gdb","slug":"gdb","permalink":"http://example.com/tags/gdb/"}]},{"title":"OpenOCD","slug":"openocd/openocd","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.327Z","comments":true,"path":"2024/12/24/openocd/openocd/","permalink":"http://example.com/2024/12/24/openocd/openocd/","excerpt":"","text":"OpenOCD返回主页 参考1 参考2 参考3 openocd与dap连接测试1openocd -f interface/cmsis-dap.cfg 使用1openocd -f &lt;接口配置文件&gt; -f &lt;芯片配置文件&gt; -c &lt;执行命令&gt; openocd -f openocd.cfg 1234567#openocd.cfg#选择调试器source [find interface/cmsis-dap.cfg]# 选择接口为SWDtransport select swd# 选择目标芯片source [find target/stm32f4x.cfg] openocd运行测试 连接本机端口 1telnet localhost 4444 指令reset，halt，flash write_image,exitopenocd运行后，shell被占用，另开终端 1flash write_image *.hex 启动GDB 1arm-none-eabi-gdb *.elf GDB连接openocd 1target remote localhost:3333 monitor reset,halt,load开始GDB调试123456openocd -f openocd.cfg -c init -c halt -c &quot;flash write_image erase E:/MCU/STM32L431RC-BearPi/usart1-fpu-test/build/usart1-fpu-test.bin 0x08000000&quot;//或openocd -f board/stm32f3discovery.cfg -c &quot;program filename.elf verify reset exit&quot;openocd -f interface/stlink.cfg -f target/stm32f2x.cfg -c init -c halt -c &quot;program $^ verify reset exit&quot; 12345678910111213141516171819PREFIX = arm-none-eabi-CC = $(GCC_PATH)/$(PREFIX)gccAS = $(GCC_PATH)/$(PREFIX)gcc -x assembler-with-cppCP = $(GCC_PATH)/$(PREFIX)objcopySZ = $(GCC_PATH)/$(PREFIX)sizeDB = $(GCC_PATH)/$(PREFIX)gdbflash: $(BUILD_DIR)/$(TARGET).hex openocd -f openocd.cfg -c init -c halt -c &quot;program $^ verify reset exit&quot;# &quot;flash write_image erase build/F407.hex&quot; -c reset -c exit# &quot;flash write_image erase E:/MCU/STM32L431RC-BearPi/usart1-fpu-test/build/usart1-fpu-test.bin&quot;#&quot;*.bin 0x08000000&quot;debug: #$(BUILD_DIR)/$(TARGET).hex openocd -f interface/cmsis-dap.cfg -f target/stm32f4x.cfg -c &quot;transport select swd&quot; &amp; $(DB) $(BUILD_DIR)/$(TARGET).elf -ex &quot;target remote localhost:3333&quot;exit: taskkill -f -im openocd.exe openocd program telnet功能打开：windows功能-&gt;telnet client1telnet localhost 4444 SVD文件：芯片寄存器描述 SVD 文件下载 GDB使用 RTT viewer b打断点12b if a = 10#强行赋值a=10b if a == 10#等到a=10时停止 可用作条件，如a%5 == 0，局部变量需要运行到函数内部 linux下安装 libtool hidapi安装12sudo apt-get install libtool-binsudo apt-get install hidapi-dev VScode仿真launch.jsoncortex-debug 1234567891011121314151617181920212223&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Cortex Debug&quot;, &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, &quot;executable&quot;: &quot;$&#123;workspaceRoot&#125;/build/F407.elf&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;type&quot;: &quot;cortex-debug&quot;, &quot;device&quot;:&quot;STM32F407VE&quot;, //使用J-link GDB Server时必须；其他GBD Server时可选（有可能帮助自动选择SVD文件）。支持的设备见 https://www.segger.com/downloads/supported-devices.php &quot;svdFile&quot;: &quot;./STM32F407.svd&quot;, //svd文件，有这个文件才能查看寄存器的值，每个单片机都不同。可以在以下地址找到 https://github.com/posborne/cmsis-svd &quot;servertype&quot;: &quot;openocd&quot;, //使用的GDB Server &quot;configFiles&quot;: [ &quot;$&#123;workspaceRoot&#125;/openocd.cfg&quot; ], //&quot;preLaunchTask&quot;: &quot;build&quot; &#125; ]&#125; gdb &#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;ARM Debug&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/F407.elf&quot;, // 要调试的程序（在下面的参数中指定了，这里的没有意义） &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, // 调试时是否显示控制台窗口 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:\\\\Program Files (x86)\\\\GNU Arm Embedded Toolchain\\\\9 2020-q2-update\\\\bin\\\\arm-none-eabi-gdb.exe&quot;, //调试工具原始路径 &quot;targetArchitecture&quot;: &quot;arm&quot;, //目标架构，此参数必须要有 &quot;setupCommands&quot;: [ // 进入GDB以后，自动执行的一些配置 &#123; &quot;description&quot;: &quot;选择调试文件(.elf)到gdb&quot;, &quot;text&quot;: &quot;file D:/practise/F407_Disc/build/F407.elf&quot;, //此处不能使用$&#123;workspaceFolder&#125;，因为windows下分隔符是&#39;\\\\&#39;，gdb识别不出来 &quot;ignoreFailures&quot;: false &#125;, &#123; &quot;description&quot;: &quot;连接GDB Server&quot;, &quot;text&quot;: &quot;target remote localhost:3333&quot;, &quot;ignoreFailures&quot;: false &#125;, &#123; &quot;description&quot;: &quot;Reset MCU&quot;, &quot;text&quot;: &quot;monitor reset&quot;, &quot;ignoreFailures&quot;: false &#125;, &#123; &quot;description&quot;: &quot;Halt&quot;, &quot;text&quot;: &quot;monitor halt&quot;, &quot;ignoreFailures&quot;: false &#125;, &#123; &quot;description&quot;:&quot;下载代码到MCU&quot;, &quot;text&quot;: &quot;load&quot; , &quot;ignoreFailures&quot;: false &#125; ], //&quot;preLaunchTask&quot;: &quot;build&quot;, // 在调试前预先执行的任务，此处是tasks.json中的 &#125; ] &#125; `","categories":[{"name":"OCD","slug":"OCD","permalink":"http://example.com/categories/OCD/"},{"name":"OpenOCD","slug":"OCD/OpenOCD","permalink":"http://example.com/categories/OCD/OpenOCD/"}],"tags":[{"name":"OCD","slug":"OCD","permalink":"http://example.com/tags/OCD/"},{"name":"OpenOCD","slug":"OpenOCD","permalink":"http://example.com/tags/OpenOCD/"}]},{"title":"pyocd","slug":"openocd/pyocd","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.327Z","comments":true,"path":"2024/12/24/openocd/pyocd/","permalink":"http://example.com/2024/12/24/openocd/pyocd/","excerpt":"","text":"pyocd返回主页 列表 指令 列出可用的探针 pyocd list –probes 列出所有支持的目标板 pyocd list –targets 列出所有支持的开发板 pyocd list –boards json列出可用的探针 pyocd json –probes json列出所有支持的目标板 pyocd json –targets json列出所有支持的开发板 pyocd json –boards 烧录pyocd cmd –command load template.hex –target stm32f103rc 连接pyocd cmd –connect halt –target stm32f103rc 设置断点pyocd cmd –command break 0x0800029e –target stm32f103rc 指令 功能 go 运行 reset 复位 halt 暂停 reg 查看寄存器 status 状态 step 单步 break 断点 lsbreak 查看断点 rmbreak 删除断点 load 下载 erase 擦除","categories":[{"name":"OCD","slug":"OCD","permalink":"http://example.com/categories/OCD/"},{"name":"pyocd","slug":"OCD/pyocd","permalink":"http://example.com/categories/OCD/pyocd/"}],"tags":[{"name":"OCD","slug":"OCD","permalink":"http://example.com/tags/OCD/"},{"name":"pyocd","slug":"pyocd","permalink":"http://example.com/tags/pyocd/"}]},{"title":"vscode配置","slug":"openocd/vscode","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.327Z","comments":true,"path":"2024/12/24/openocd/vscode/","permalink":"http://example.com/2024/12/24/openocd/vscode/","excerpt":"","text":"vscode配置配置用户任务（下拉菜单）1-tasks.json在这里（ Tasks in Visual Studio Code）了解关于tasks.json的作用，简单来说，就是vscode设计的专门配置如何调用外部功能的接口，因为这些外部的功能如make, lint等是开发环节中的重要部分，而且大部分是命令行式的。这一段所描述的所有内容都可以在这个链接里找到，建议认真阅读原文，要查看具体字段如”group”使用说明可以直接在网页里搜索。再简单来说，有了tasks.json就可以配置用户自己的下接菜单。 2-创建tasks.json有两个方法，一、手动自己创建.vscode&#x2F;tasks.json, 因为文件内容比较简单所以完全可以自己创建，省得记忆下面提到创建方法路径， 二、菜单的Terminal-&gt;configure tasks… 或者用CTRL+P 弹出输入框，输入‘&gt;Task’列表显示一堆，选择“Tasks:Config Task”继续选择Creat tasks.json file from template 。 这里差别不大，因为我们只是要一个文件，然后里面内容删掉重写。 3-tasks.json的文件编辑针对stm32开发的用到的功能只是tasks.json中很简单的一块，这里一共定义了6个task，分别说明如下， 调用make指令执行编译，实际执行的命令行是‘make all -j4’调用4核全力执行 调用make指令执行清理工程，实际执行‘make clean’,删除build目录及内容 jlink的下载，实际执行的是‘make -j4 jflash’ jlink的擦除，实际执行的是‘make jerase’ stlink的下载，实际执行的是 ‘make -j4 stflash’ stlink的擦除，实际执行的是‘st-flash –freq&#x3D;4000 erase’ 这里注意，第6个task没有通过makefile执行，而是直接调用st-flash指令，当然也可以从makefile里执行，调用’make sterase’即可。这表明tasks.json可以让vscode调用任意外部功能，如make.exe和st-flash.exe。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ // MAKE(BUILD + CLEAN) &#123; &quot;label&quot;: &quot;task-build&quot;, &quot;group&quot;: &quot;build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;make&quot;, &quot;args&quot;: [ &quot;all&quot;, &quot;-j4&quot; ] &#125;, &#123; &quot;label&quot;: &quot;task-clean&quot;, &quot;group&quot;: &quot;build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;make&quot;, &quot;args&quot;: [&quot;clean&quot;] &#125;, // JLINK (FLASH + ERASE) &#123; &quot;label&quot;: &quot;task-jflash&quot;, &quot;group&quot;: &quot;build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;make&quot;, &quot;args&quot;: [ &quot;-j4&quot;, &quot;jflash&quot; ] &#125;, &#123; &quot;label&quot;: &quot;task-jerase&quot;, &quot;group&quot;: &quot;build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;make&quot;, &quot;args&quot;: [&quot;jerase&quot;] &#125;, // STLINK (FLASH+ERASE) &#123; &quot;label&quot;: &quot;task-stflash&quot;, &quot;group&quot;: &quot;build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;make&quot;, &quot;args&quot;: [&quot;-j4&quot;, &quot;stflash&quot;] &#125;, &#123; &quot;label&quot;: &quot;task-sterase&quot;, &quot;group&quot;: &quot;build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;st-flash&quot;, &quot;args&quot;: [&quot;--freq=4000&quot;,&quot;erase&quot;] &#125;, ]&#125; 4-tasks的使用方法CTRL+SHIFT+B 或 Terminal-&gt;Run Build Task… 即可调出‘下拉菜单’，通过方向键选择并按回车执行。‘下拉菜单’中各项名称就是tasks.json中对应的”label”参数配置的。‘下拉菜单’的执行效果等同于键入对应的命令行。 自定义vscode命令快捷键打开 VS Code 并进入命令面板。你可以按下 F1 或 Ctrl+Shift+P（Windows 和 Linux）&#x2F; Cmd+Shift+P（Mac）打开命令面板。 在命令面板中输入“Preferences: Open Keyboard Shortcuts（JSON）”，然后选择打开。这将打开一个名为 keybindings.json 的文件，其中包含你的自定义键绑定。 点击Define Keybinding输入自定义键 12345678910111213141516// Place your key bindings in this file to override the defaults[&#123; &quot;key&quot;: &quot;ctrl+l&quot;, &quot;command&quot;: &quot;workbench.action.terminal.sendSequence&quot;, &quot;args&quot;: &#123; &quot;text&quot;: &quot;make\\n&quot; &#125;, &quot;when&quot;: &quot;editorTextFocus&quot;&#125;, &#123; &quot;key&quot;: &quot;ctrl+f7&quot;, &quot;command&quot;: &quot;workbench.action.tasks.runTask&quot;, &quot;args&quot;: &quot;task-jerase&quot; &#125;] 解释：按键ctrl+l在终端下输入make换行，即输入执行make指令按键ctrl+f7在上述任务重运行task-jerase vscode debugadd configuration 123456789101112&#123; &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, &quot;executable&quot;: &quot;./bin/executable.elf&quot;, &quot;name&quot;: &quot;Debug with OpenOCD&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;type&quot;: &quot;cortex-debug&quot;, &quot;servertype&quot;: &quot;openocd&quot;, &quot;configFiles&quot;: [], &quot;searchDir&quot;: [], &quot;runToEntryPoint&quot;: &quot;main&quot;, &quot;showDevDebugOutput&quot;: &quot;none&quot;&#125;, 修改executable,configFilesexecutable:编译结果，elf文件comfigFiles:openocd配置文件，可以多个 排除搜索settings.json12345678910&#123; &quot;search.exclude&quot;: &#123; &quot;**/modules&quot;:true, &#125;, &quot;files.exclude&quot;: &#123; &quot;*/.git&quot;:true, &#125;&#125;","categories":[{"name":"vscode","slug":"vscode","permalink":"http://example.com/categories/vscode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"}]},{"title":"Matplotlib","slug":"python/Matplotlib","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.332Z","comments":true,"path":"2024/12/24/python/Matplotlib/","permalink":"http://example.com/2024/12/24/python/Matplotlib/","excerpt":"","text":"Matplotlib 是一款用于数据可视化的 Python 软件包，支持跨平台运行安装说明链接 1pip install matplotlib 使用Agg无法显示，使用12print (matplotlib.get_backend())matplotlib.use(&#x27;TkAgg&#x27;) 绘图类型 函数名称 描述 Bar 绘制条形图 Barh 绘制水平条形图 Boxplot 绘制箱型图 Hist 绘制直方图 his2d 绘制2D直方图 Pie 绘制饼状图 Plot 在坐标轴上画线或者标记 Polar 绘制极坐标图 Scatter 绘制x与y的散点图 Stackplot 绘制堆叠图 Stem 用来绘制二维离散数据绘制（又称为“火柴图”） Step 绘制阶梯图 Quiver 绘制一个二维按箭头 Image函数 函数名称 描述 Imread 从文件中读取图像的数据并形成数组。 Imsave 将数组另存为图像文件。 Imshow 在数轴区域内显示图像。 Axis函数 函数名称 描述 Axes 在画布(Figure)中添加轴 Text 向轴添加文本 Title 设置当前轴的标题 Xlabel 设置x轴标签 Xlim 获取或者设置x轴区间大小 Xscale 设置x轴缩放比例 Xticks 获取或设置x轴刻标和相应标签 Ylabel 设置y轴的标签 Ylim 获取或设置y轴的区间大小 Yscale 设置y轴的缩放比例 Yticks 获取或设置y轴的刻标和相应标签 Figure函数 函数名称 描述 Figtext 在画布上添加文本 Figure 创建一个新画布 Show 显示数字 Savefig 保存当前画布 Close 关闭画布窗口 中文123import matplotlib.pyplot as pltplt.rcParams[&quot;font.sans-serif&quot;]=[&quot;SimHei&quot;] #设置字体plt.rcParams[&quot;axes.unicode_minus&quot;]=False #该语句解决图像中的“-”负号的乱码问题 1234567891011121314151617#绘制折线图import matplotlib.pyplot as pltplt.rcParams[&quot;font.sans-serif&quot;]=[&quot;SimHei&quot;] #设置字体plt.rcParams[&quot;axes.unicode_minus&quot;]=False #正常显示负号year = [2017, 2018, 2019, 2020]people = [20, 40, 60, 70]#生成图表plt.plot(year, people)plt.xlabel(&#x27;年份&#x27;)plt.ylabel(&#x27;人口&#x27;)plt.title(&#x27;人口增长&#x27;)#设置纵坐标刻度plt.yticks([0, 20, 40, 60, 80])#设置填充选项：参数分别对应横坐标，纵坐标，纵坐标填充起始值，填充颜色plt.fill_between(year, people, 20, color = &#x27;green&#x27;)#显示图表plt.show() 设置刻度12345678910111213141516171819import matplotlib.pyplot as pltimport numpy as npimport mathx = np.arange(0, math.pi*2, 0.05)#生成画布对象fig = plt.figure()#添加绘图区域ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])y = np.sin(x)ax.plot(x, y)#设置x轴标签ax.set_xlabel(&#x27;angle&#x27;)ax.set_title(&#x27;sine&#x27;)ax.set_xticks([0,2,4,6])#设置x轴刻度标签ax.set_xticklabels([&#x27;zero&#x27;,&#x27;two&#x27;,&#x27;four&#x27;,&#x27;six&#x27;])#设置y轴刻度ax.set_yticks([-1,0,1])plt.show() 坐标轴在一个函数图像中，有时自变量 x 与因变量 y 是指数对应关系，这时需要将坐标轴刻度设置为对数刻度。Matplotlib 通过 axes 对象的xscale或yscale属性来实现对坐标轴的格式设置。 12345678910111213141516171819import matplotlib.pyplot as pltimport numpy as npimport mathx = np.arange(0, math.pi*2, 0.05)#生成画布对象fig = plt.figure()#添加绘图区域ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])y = np.sin(x)ax.plot(x, y)#设置x轴标签ax.set_xlabel(&#x27;angle&#x27;)ax.set_title(&#x27;sine&#x27;)ax.set_xticks([0,2,4,6])#设置x轴刻度标签ax.set_xticklabels([&#x27;zero&#x27;,&#x27;two&#x27;,&#x27;four&#x27;,&#x27;six&#x27;])#设置y轴刻度ax.set_yticks([-1,0,1])plt.show() csv数据显示例子 12345678910111213141516171819202122232425262728import matplotlibimport csvimport matplotlib.pyplot as plt# import pandas_profilingmatplotlib.use(&#x27;TkAgg&#x27;)# print (matplotlib.get_backend())datafile = open(&quot;./data.csv&quot;)dataread = csv.reader(datafile)datalist = list(dataread)dataline = len(datalist)datarow = len(datalist[0])x = list()y = list()z = list()for i in range(0,dataline): x.append(float(datalist[i][0])) y.append(float(datalist[i][1])) z.append(float(datalist[i][2]))# squares = [1, 4, 9, 16, 25]# x = [1,3,4,5,6]# 它是用来创建 总画布/figure“窗口”的，有figure就可以在上边（或其中一个子网格/subplot上）作图了，（fig：是figure的缩写）fig,ax = plt.subplots()ax.plot(x,y,&#x27;r.-&#x27;)ax.plot(x,z,&#x27;b.-&#x27;)plt.show()","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"python文件","slug":"python/file","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.337Z","comments":true,"path":"2024/12/24/python/file/","permalink":"http://example.com/2024/12/24/python/file/","excerpt":"","text":"文件操作123with open(fileName,&#x27;wb&#x27;) as f: for chunk in resp.iter_content(128): f.write(chunk) 相关参数： r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 file对象的属性 file.read([size]) 将文件数据作为字符串返回，可选参数size控制读取的字节数 file.readlines([size]) 返回文件中行内容的列表，size参数可选 file.write(str) 将字符串写入文件 file.writelines(strings) 将字符串序列写入文件 file.close() 关闭文件 file.closed 表示文件已经被关闭，否则为False file.mode Access文件打开时使用的访问模式 file.encoding 文件所使用的编码 file.name 文件名 file.newlines 未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，则为一个包含所有当前所遇到的行结束的列表 file.softspace 为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般程序员用不着，由程序内部使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950onelogosize = 500*375*2+24f=open (&quot;SOURCE00.bf5&quot;,&quot;rb&quot;)head = f.read(16)logo1 = f.read(onelogosize)logo2 = f.read(onelogosize)logo3 = f.read(onelogosize)logo4 = f.read(onelogosize)logo5 = f.read(onelogosize)logo6 = f.read(onelogosize)logo7 = f.read(onelogosize)f.closenum = bytearray(head)print(num)print(&quot;原资源文件有%s个logo&quot;%num[6])# arr[6] = arr[6]+1print(&quot;logo1 = %.18s&quot;%(logo1))print(&quot;logo2 = %.18s&quot;%(logo2))print(&quot;logo3 = %.18s&quot;%(logo3))print(&quot;logo4 = %.18s&quot;%(logo4))print(&quot;logo5 = %.18s&quot;%(logo5))print(&quot;logo6 = %.18s&quot;%(logo6))print(&quot;logo7 = %.18s&quot;%(logo7))# 头部长度headsize = 72# #logo读取 内容375K# #方法1：取上下翻转 红蓝对换的bmp文件# #方法2：取原图转换后的dta文件bmp=open (&quot;LOGO-2021.12.06_1.bmp&quot;,&quot;rb&quot;)bmp.seek(headsize)bmparr = bmp.read(onelogosize)# logosize = bmp.tell()bmp.close# print(bmparr)print(&quot;读取logo&quot;)# #写入新文件nf=open(&quot;SOURCE00_new.bf5&quot;,&quot;wb+&quot;)nf.write(head+logo1+logo2+logo3+logo5+logo6+logo7)nf.write(b&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;)logoname = b&quot;FALCON\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;nf.write(logoname)nf.write(bmparr)size = nf.tell()nf.closeprint(&quot;创建新的BF5资源文件,大小 = %s字节&quot;%size) head logo1 bytes(0) logo2 bytes(0) logo3 … 16 375016 8 375016 8 375016 … logoname logodata 375000 16","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"python html","slug":"python/headers","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.332Z","comments":true,"path":"2024/12/24/python/headers/","permalink":"http://example.com/2024/12/24/python/headers/","excerpt":"","text":"HTML headers浏览器查看HTTP headers 1、打开浏览器，F12打开控制台2、输入访问URL3、点击Network 点击请求 点击Headers HTTP header 常用属性(1) Host：请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，例如我们在浏览器中输入：https://www.baidu.com，浏览器发送的请求消息中，就会包含Host请求报头域，如下： Host：www.baidu.com(此处使用缺省端口号443，若指定了端口号，则变成：Host：指定端口号 (2)Referer当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该请求是从哪个页面链接过来的，服务器借此可以获得一些信息用于处理。比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。 (3)User-Agent这个对于爬虫比较重要 因为一班都需要添加该属性，否则稍微处理过的网站，都无法爬取。 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。 我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。 例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E) 应用程序版本“Mozilla/4.0”表bai示：你使用Maxthon 2.0 浏览du器使用 IE8 内核； 版本标识“zhiMSIE 8.0” 平台自身的dao识别信息“Windows NT 5.1”表示“操作系统为zhuan Windows XP” Trident内核版本“Trident/4.0”，浏览器的一种内核，还有一种就是WebKit内核 （4）Content-type表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 常见的媒体格式类型如下： text&#x2F;html HTML格式 text&#x2F;plain 纯文本格式 text&#x2F;xml XML格式 image&#x2F;gif gif图片格式 image&#x2F;jpeg jpg图片格式 image&#x2F;png png图片格式 以application开头的媒体格式类型： application&#x2F;xhtml+xml XHTML格式 application&#x2F;xml XML数据格式 application&#x2F;atom+xml Atom XML聚合格式 application&#x2F;json JSON数据格式 application&#x2F;pdf pdf格式 application&#x2F;msword Word文档格式 application&#x2F;octet-stream 二进制流数据（如常见的文件下载） application&#x2F;x-www-form-urlencoded 中默认的encType，form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的： multipart&#x2F;form-data 需要在表单中进行文件上传时，就需要使用该格式。 （5）Accept-LanguageAccept-Langeuage：指出浏览器可以接受的语言种类，如en或en-us指英语，zh或者zh-cn指中文，当服务器能够提供一种以上的语言版本时要用到。 （6）CookieCookie：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。 防反爬 user-agent 必须 referer 防盗链，看网站机制 cookie 用户登陆数据 其他 看具体回复 123456789101112headers = &#123;&#x27;accept&#x27;:&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;,&#x27;cookie&#x27;: &#x27;_ntes_nnid=34d30980bda87343a01de676455caf23,1631167819959; _ntes_nuid=34d30980bda87343a01de676455caf23; UM_distinctid=17c0c4d974ac0-0ba38bbbaac2f6-5d462912-1fa400-17c0c4d9751fb; _iuqxldmzr_=32; NMTID=00Om6TxDNkNyCDUr0gNqt6nB6FaFhkAAAF87eurOQ; WNMCID=psyebj.1636079184756.01.0; WEVNSM=1.0.0; WM_TID=VMJqpPoVcjlBAQAFRFJutLnIBScu5%2FUN; WM_NI=rJ2Na1%2FOiVw4gOtZ9mXjaTEzi%2FWy2Z58sYTJb2RnIhKorYLEsi%2BIwQFZmj9yWrsA5RhEnkhGUrpreF4SKlgVT8K1LjzaQZ53Fg7zksmX3DBX2%2BlB5ySte0Ih9CsZiUfWWlk%3D; WM_NIKE=9ca17ae2e6ffcda170e2e6eeb5b841f388a6aab67caba88ea2d85b929e9abbf87ca3e9b6b6b6469a98a7aaf52af0fea7c3b92ab296feafe43bed91a7b7f640a591bcbbbc679cb6afb5c872abf1999ab152f7e8bdbad742a2ee9e8fcc6489b1bebacf4fb1b7e5aaf65b8686a38bbc7395aebda2b85aac9ba28ceb4d97aec093e84ef88d858de65e98e885d2cf62babf9fbbb83986b9f99bea79af88fda5c154f2f5a4a3b87391acabd1cc64fb9dbdbbec5fa689998dea37e2a3; JSESSIONID-WYYY=bs0%5CC%5Cv7UnBn8U6MnZGPeKf4v0m40UEWk4bb1k9%5CwCqBgmhc6ckHWvuaxxNy7wDjGpdg6Vx7TK9XbWVnoToHYNomM3wh44tHcVdDmcUyX5UJzF%5CEhrT38j%5C1%2Bi5OI1Q%5Ct6xxn%5CWO9DRUnh6tATDSp9UM%5Cxq65%5CljyyewOwXaZ9F2Zhw0%3A1636341503070&#x27;,&#x27;referer&#x27;: &#x27;https://music.163.com/&#x27;,&#x27;sec-fetch-dest&#x27;: &#x27;document&#x27;,&#x27;sec-fetch-mode&#x27;: &#x27;navigate&#x27;,&#x27;sec-fetch-site&#x27;: &#x27;none&#x27;,&#x27;sec-fetch-user&#x27;: &#x27;?1&#x27;,&#x27;upgrade-insecure-requests&#x27;: &#x27;1&#x27;,&#x27;user-agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&#x27;,&#125;","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"爬虫","slug":"python/爬虫","permalink":"http://example.com/categories/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"pyqt5","slug":"python/pyqt5","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.337Z","comments":true,"path":"2024/12/24/python/pyqt5/","permalink":"http://example.com/2024/12/24/python/pyqt5/","excerpt":"","text":"pyqt5UI生成命令 1pyuic5.exe .\\untitled.ui -o data_analysis.py 资源文件qrc文件格式 12345678&lt;RCC&gt; &lt;qresource prefix=&quot;/&quot;&gt; &lt;file&gt;main.qml&lt;/file&gt; &lt;file&gt;BasicComponentDemo.qml&lt;/file&gt; &lt;file&gt;BasicInputComponent.qml&lt;/file&gt; &lt;file&gt;CustomComponentDemo.qml&lt;/file&gt; &lt;/qresource&gt;&lt;/RCC&gt; 命令 1pyrcc5 -o src.py src.qrc 引用 12#路径为：冒号+prefix路径前缀+file相对路径 QPixmap(&quot;:/imgA.jpg&quot;) 使用例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174from PyQt5 import QtCore, QtGui, QtWidgetsfrom PyQt5.QtWidgets import QLabel, QMessageBox,QFileDialogfrom PyQt5.QtGui import QIconfrom PyQt5.QtCore import QTimer# from mainui import Ui_MainWindowfrom mainui import Ui_MainWindowimport sysimport jpgfuncfrom PIL import Imageimport osimport jpgfuncclass MainWindow(QtWidgets.QMainWindow, Ui_MainWindow): def __init__(self, parent=None): super(MainWindow, self).__init__(parent) self.setupUi(self) # 设置应用程序的窗口图标 self.setWindowIcon(QIcon(&quot;:/apple.ico&quot;)) self.setFixedSize(self.width(),self.height()) self.setWindowTitle(&quot;图片简易处理小工具 作者：gx&quot;) # self.setWindowFlags(QtCore.Qt.WindowMinimizeButtonHint) self.label.setText(&quot;&quot;) # self.setStyleSheet(&quot;#MainWindow&#123;background-color:lightblue&#125;&quot;) self.setStyleSheet(&quot;#MainWindow&#123;border-image:url(:/back.jpg)&#125;&quot;) # self.layout = QtWidgets.QWidget() # self.layout.setStyleSheet(&#x27;&#x27;&#x27;QWidget&#123;background-color:rgb(245, 245, 245);&#125;&#x27;&#x27;&#x27;) self.statusBar.showMessage(&quot;图片简易处理小工具,专门为办公室电脑小白设计，满足基本图片处理需求&quot;) self.comboBox.addItem(&quot;水平&quot;) self.comboBox.addItem(&quot;垂直&quot;) self.pushButton.clicked.connect(self.selectfile) self.pushButton_2.clicked.connect(self.ConvertImage) self.radioButton.clicked.connect(self.func1) self.radioButton_2.clicked.connect(self.func2) self.radioButton_3.clicked.connect(self.func3) self.radioButton_4.clicked.connect(self.func4) self.radioButton_5.clicked.connect(self.func5) self.radioButton_6.clicked.connect(self.func6) self.radioButton_7.clicked.connect(self.func7) self.radioButton_8.clicked.connect(self.func8) self.radioButton_9.clicked.connect(self.func9) self.horizontalSlider.valueChanged.connect(self.sliderchange) self.horizontalSlider_2.valueChanged.connect(self.sliderchange) self.horizontalSlider_3.valueChanged.connect(self.sliderchange) self.horizontalSlider_4.valueChanged.connect(self.sliderchange) def sliderchange(self): R = self.horizontalSlider.value() G = self.horizontalSlider_2.value() B = self.horizontalSlider_3.value() self.label_12.setStyleSheet(&quot;background-color:rgb(&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;.format(R,G,B)) # self.statusBar.hide() def alldisable(self): self.groupBox_2.setEnabled(0) self.groupBox_3.setEnabled(0) def func1(self): if self.radioButton.isChecked(): # self.statusBar.show() self.statusBar.showMessage(&quot;剪裁&quot;) self.alldisable() def func2(self): if self.radioButton_2.isChecked(): self.groupBox_2.setEnabled(1) self.textEdit_20.setEnabled(1) self.statusBar.showMessage(&quot;格式&quot;) def func3(self): if self.radioButton_3.isChecked(): self.statusBar.showMessage(&quot;尺寸&quot;) def func4(self): if self.radioButton_4.isChecked(): self.statusBar.showMessage(&quot;压缩&quot;) def func5(self): if self.radioButton_5.isChecked(): self.statusBar.showMessage(&quot;旋转&quot;) def func6(self): if self.radioButton_6.isChecked(): self.statusBar.showMessage(&quot;镜像&quot;) def func7(self): if self.radioButton_7.isChecked(): self.statusBar.showMessage(&quot;手绘&quot;) def func8(self): if self.radioButton_8.isChecked(): self.statusBar.showMessage(&quot;模糊&quot;) def func9(self): if self.radioButton_9.isChecked(): self.statusBar.showMessage(&quot;黑白&quot;) def selectfile(self): print(&quot;button 1 clicked&quot;) selectfilename = QFileDialog.getOpenFileName() self.filename = selectfilename[0] self.textEdit.setText(self.filename) im = Image.open(self.filename) info = &quot;图片信息：&quot; info+=&quot; 尺寸：&quot;+str(im.width)+&quot;x&quot;+str(im.height) info+=&quot; 格式：&quot;+im.mode info+=&quot; 大小：&quot;+str(os.path.getsize(self.filename))+&quot;B&quot; self.label.setText(info) def ConvertImage(self): print(&quot;button 2 clicked&quot;) if self.radioButton.isChecked(): self.statusBar.showMessage(&quot;剪裁转换开始&quot;) x = self.textEdit_6.toPlainText() x = int(x) y = self.textEdit_7.toPlainText() y = int(y) w = self.textEdit_13.toPlainText() w = int(w) h = self.textEdit_14.toPlainText() h = int(h) jpgfunc.Cut(self.filename,x,y,w,h) if self.radioButton_2.isChecked(): self.statusBar.showMessage(&quot;格式转换开始&quot;) format = self.textEdit_18.toPlainText() jpgfunc.Format(self.filename,format) if self.radioButton_3.isChecked(): self.statusBar.showMessage(&quot;尺寸转换开始&quot;) x = self.textEdit_16.toPlainText() x = int(x) y = self.textEdit_17.toPlainText() y = int(y) jpgfunc.Resize(self.filename,x,y) if self.radioButton_4.isChecked(): self.statusBar.showMessage(&quot;压缩转换开始&quot;) mb = self.textEdit_4.toPlainText() mb = int(mb) step = self.textEdit_15.toPlainText() step = int(step) quality = self.textEdit_5.toPlainText() quality = int(quality) jpgfunc.Compress(self.filename,mb,step,quality) if self.radioButton_5.isChecked(): self.statusBar.showMessage(&quot;旋转转换开始&quot;) angle = self.textEdit_20.toPlainText() angle = int(angle) jpgfunc.Rotate(self.filename,angle) if self.radioButton_6.isChecked(): self.statusBar.showMessage(&quot;镜像转换开始&quot;) select = self.comboBox.currentIndex() select = int(select) jpgfunc.Transpose(self.filename,select) if self.radioButton_7.isChecked(): self.statusBar.showMessage(&quot;手绘转换开始&quot;) jpgfunc.Draw(self.filename) if self.radioButton_8.isChecked(): self.statusBar.showMessage(&quot;模糊转换开始&quot;) cnt = self.textEdit_23.toPlainText() cnt = int(cnt) jpgfunc.Dim(self.filename,cnt) if self.radioButton_9.isChecked(): self.statusBar.showMessage(&quot;黑白转换开始&quot;) jpgfunc.Covert(self.filename) self.statusBar.showMessage(&quot;处理完毕&quot;)if __name__ == &quot;__main__&quot;: app = QtWidgets.QApplication(sys.argv) mainWindow = MainWindow() mainWindow.show() sys.exit(app.exec_())","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"qt","slug":"python/qt","permalink":"http://example.com/categories/python/qt/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"qt","slug":"qt","permalink":"http://example.com/tags/qt/"}]},{"title":"requirements.txt","slug":"python/requirements","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.337Z","comments":true,"path":"2024/12/24/python/requirements/","permalink":"http://example.com/2024/12/24/python/requirements/","excerpt":"","text":"requirements.txt安装pipreqs12pip install pipreqspipreqs ./ --encoding utf-8 通过requirements.txt安装1pip install -r requirements.txt 组件下载指定镜像 1pip install scripy -i https://pypi.tuna.tsinghua.edu.cn/simple –user安装在在用户系统目录下 一般不用 修改下载源user路径下新建pip&#x2F;pip.ini,添加内容 12345[global]index-url=http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com 虚拟空间12345678pip install virtualenvvirtualenv venvvenv/Scripts/activate (For Linux)venv/Scripts/activate.bat (For Windows)# windows无法开启虚拟空间，需管理员进入shellSet-ExecutionPolicy -ExecutionPolicy UNRESTRICTED 快速卸载所有包12pip freeze &gt; python_modules.txt #获取所有包pip uninstall -r python_modules.txt -y #卸载，Y确认 DAPLink develop分支 GCC1234(venv) &gt; pip install -r requirements.txt(venv) &gt; pip uninstall -y project-generator(venv) &gt; pip install --upgrade --user git+https://github.com/mbrossard/project_generator.git@development(venv) &gt; python tools\\progen_compile.py --clean -v stm32f103xb_if","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"正则表达式","slug":"python/正则表达式","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.337Z","comments":true,"path":"2024/12/24/python/正则表达式/","permalink":"http://example.com/2024/12/24/python/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式一、re.findall函数介绍它在re.py中有定义： 12345678910def findall(pattern, string, flags=0): &quot;&quot;&quot;Return a list of all non-overlapping matches in the string. If one or more capturing groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result.&quot;&quot;&quot; return _compile(pattern, flags).findall(string) 返回string中所有与pattern匹配的全部字符串,返回形式为数组。 findall()函数的两种表示形式 123456789import rekk = re.compile(r&#x27;\\d+&#x27;)kk.findall(&#x27;one1two2three3four4&#x27;)#[1,2,3,4] #注意此处findall()的用法，可传两个参数;kk = re.compile(r&#x27;\\d+&#x27;)re.findall(kk,&quot;one123&quot;)#[1,2,3] 二、实例代码后面会讲解代码里的各个部分，先列出来~ 1234567891011121314151617181920212223242526272829import re str = &#x27;aabbabaabbaa&#x27;# 一个&quot;.&quot;就是匹配除 \\n (换行符)以外的任意一个字符print(re.findall(r&#x27;a.b&#x27;,str))#[&#x27;aab&#x27;, &#x27;aab&#x27;]# *前面的字符出现0次或以上print(re.findall(r&#x27;a*b&#x27;,str))#[&#x27;aab&#x27;, &#x27;b&#x27;, &#x27;ab&#x27;, &#x27;aab&#x27;, &#x27;b&#x27;]# 贪婪，匹配从.*前面为开始到后面为结束的所有内容print(re.findall(r&#x27;a.*b&#x27;,str))#[&#x27;aabbabaabb&#x27;]# 非贪婪，遇到开始和结束就进行截取，因此截取多次符合的结果，中间没有字符也会被截取print(re.findall(r&#x27;a.*?b&#x27;,str))#[&#x27;aab&#x27;, &#x27;ab&#x27;, &#x27;aab&#x27;]# 非贪婪，与上面一样，只是与上面的相比多了一个括号，只保留括号的内容print(re.findall(r&#x27;a(.*?)b&#x27;,str))#[&#x27;a&#x27;, &#x27;&#x27;, &#x27;a&#x27;] str = &#x27;&#x27;&#x27;aabbab aabbaa bb&#x27;&#x27;&#x27; #后面多加了2个b# 没有把最后一个换行的aab算进来print(re.findall(r&#x27;a.*?b&#x27;,str))#[&#x27;aab&#x27;, &#x27;ab&#x27;, &#x27;aab&#x27;]# re.S不会对\\n进行中断print(re.findall(r&#x27;a.*?b&#x27;,str,re.S))#[&#x27;aab&#x27;, &#x27;ab&#x27;, &#x27;aab&#x27;, &#x27;aa\\n b&#x27;] 三、re.findall中正则表达式(.*?)字符串是 1str = &#x27;aabbabaabbaa&#x27; 符号 . 就 是匹配除 \\n (换行符)以外的任意一个字符12print(re.findall(r&#x27;a.b&#x27;,str))#[&#x27;aab&#x27;, &#x27;aab&#x27;] 2.符号 * 前面的字符出现0次或以上12print(re.findall(r&#x27;a*b&#x27;,str))#[&#x27;aab&#x27;, &#x27;b&#x27;, &#x27;ab&#x27;, &#x27;aab&#x27;, &#x27;b&#x27;] 3.符号.* 贪婪，匹配从.*前面为开始到后面为结束的所有内容12print(re.findall(r&#x27;a.*b&#x27;,str))#[&#x27;aabbabaabb&#x27;] 4.符号.*? 非贪婪，遇到开始和结束就进行截取，因此截取多次符合的结果，中间没有字符也会被截取12print(re.findall(r&#x27;a.*?b&#x27;,str))#[&#x27;aab&#x27;, &#x27;ab&#x27;, &#x27;aab&#x27;] 5.符号(.*?) 非贪婪，与上面一样，只是与上面的相比多了一个括号，只保留括号的内容12print(re.findall(r&#x27;a(.*?)b&#x27;,str))#[&#x27;a&#x27;, &#x27;&#x27;, &#x27;a&#x27;] 关于带括号与不带括号的区别12345678910111213141516import restring=&quot;abcdefg acbdgef abcdgfe cadbgfe&quot;#不带括号regex=re.compile(&quot;((\\w+)\\s+\\w+)&quot;)print(regex.findall(string))#输出：[(&#x27;abcdefg acbdgef&#x27;, &#x27;abcdefg&#x27;), (&#x27;abcdgfe cadbgfe&#x27;, &#x27;abcdgfe&#x27;)]regex1=re.compile(&quot;(\\w+)\\s+\\w+&quot;)print(regex1.findall(string))#输出：[&#x27;abcdefg&#x27;, &#x27;abcdgfe&#x27;]regex2=re.compile(&quot;\\w+\\s+\\w+&quot;)print(regex2.findall(string))#输出：[&#x27;abcdefg acbdgef&#x27;, &#x27;abcdgfe cadbgfe&#x27;] 第一个 regex 中带有2个括号，其输出list 中包含2个 tuple 第二个 regex 中带有1个括号，其输出内容是括号匹配到的内容，而不是整个表达式所匹配到的结果。 第三个 regex 中不带括号,其输出的内容就是整个表达式所匹配到的内容。 实际上这并不是python特有的，这是正则所特有的 ， 任何一门高级语言使用正则都满足这个特点：有括号时只能匹配到括号中的内容，没有括号【相当于在最外层增加了一个括号】。在正则里面 “()” 代表的是分组的意思，一个括号代表一个分组，你只能匹配到 “()” 中的内容。 四、re.findall中参数re.S的意义1.字符串变为（后面多加了2个b） 123str = &#x27;&#x27;&#x27;aabbab aabbaa bb&#x27;&#x27;&#x27; 2.参数无re.S，没有把最后一个换行的aab算进来 12print(re.findall(r&#x27;a.*?b&#x27;,str))#[&#x27;aab&#x27;, &#x27;ab&#x27;, &#x27;aab&#x27;] 3.参数有re.S，不会对\\n进行中断 12print(re.findall(r&#x27;a.*?b&#x27;,str,re.S))#[&#x27;aab&#x27;, &#x27;ab&#x27;, &#x27;aab&#x27;, &#x27;aa\\n b&#x27;]","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"爬虫","slug":"python/爬虫","permalink":"http://example.com/categories/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"CRC校验","slug":"stm32/CRC","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.330Z","comments":true,"path":"2024/12/24/stm32/CRC/","permalink":"http://example.com/2024/12/24/stm32/CRC/","excerpt":"","text":"CRC全部源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590uint8_t crc4_itu(uint8_t *data, uint_len length);uint8_t crc5_epc(uint8_t *data, uint_len length);uint8_t crc5_itu(uint8_t *data, uint_len length);uint8_t crc5_usb(uint8_t *data, uint_len length);uint8_t crc6_itu(uint8_t *data, uint_len length);uint8_t crc7_mmc(uint8_t *data, uint_len length);uint8_t crc8(uint8_t *data, uint_len length);uint8_t crc8_itu(uint8_t *data, uint_len length);uint8_t crc8_rohc(uint8_t *data, uint_len length);uint8_t crc8_maxim(uint8_t *data, uint_len length);//DS18B20uint16_t crc16_ibm(uint8_t *data, uint_len length);uint16_t crc16_maxim(uint8_t *data, uint_len length);uint16_t crc16_usb(uint8_t *data, uint_len length);uint16_t crc16_modbus(uint8_t *data, uint_len length);uint16_t crc16_ccitt(uint8_t *data, uint_len length);uint16_t crc16_ccitt_false(uint8_t *data, uint_len length);uint16_t crc16_x25(uint8_t *data, uint_len length);uint16_t crc16_xmodem(uint8_t *data, uint_len length);uint16_t crc16_dnp(uint8_t *data, uint_len length);uint32_t crc32(uint8_t *data, uint_len length);uint32_t crc32_mpeg_2(uint8_t *data, uint_len length);/****************************************************************************** * Name: CRC-4/ITU x4+x+1 * Poly: 0x03 * Init: 0x00 * Refin: True * Refout: True * Xorout: 0x00 * Note: *****************************************************************************/uint8_t crc4_itu(uint8_t *data, uint_len length)&#123; uint8_t i; uint8_t crc = 0; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0x0C;// 0x0C = (reverse 0x03)&gt;&gt;(8-4) else crc = (crc &gt;&gt; 1); &#125; &#125; return crc;&#125;/****************************************************************************** * Name: CRC-5/EPC x5+x3+1 * Poly: 0x09 * Init: 0x09 * Refin: False * Refout: False * Xorout: 0x00 * Note: *****************************************************************************/uint8_t crc5_epc(uint8_t *data, uint_len length)&#123; uint8_t i; uint8_t crc = 0x48; // Initial value: 0x48 = 0x09&lt;&lt;(8-5) while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for ( i = 0; i &lt; 8; i++ ) &#123; if ( crc &amp; 0x80 ) crc = (crc &lt;&lt; 1) ^ 0x48; // 0x48 = 0x09&lt;&lt;(8-5) else crc &lt;&lt;= 1; &#125; &#125; return crc &gt;&gt; 3;&#125;/****************************************************************************** * Name: CRC-5/ITU x5+x4+x2+1 * Poly: 0x15 * Init: 0x00 * Refin: True * Refout: True * Xorout: 0x00 * Note: *****************************************************************************/uint8_t crc5_itu(uint8_t *data, uint_len length)&#123; uint8_t i; uint8_t crc = 0; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0x15;// 0x15 = (reverse 0x15)&gt;&gt;(8-5) else crc = (crc &gt;&gt; 1); &#125; &#125; return crc;&#125;/****************************************************************************** * Name: CRC-5/USB x5+x2+1 * Poly: 0x05 * Init: 0x1F * Refin: True * Refout: True * Xorout: 0x1F * Note: *****************************************************************************/uint8_t crc5_usb(uint8_t *data, uint_len length)&#123; uint8_t i; uint8_t crc = 0x1F; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0x14;// 0x14 = (reverse 0x05)&gt;&gt;(8-5) else crc = (crc &gt;&gt; 1); &#125; &#125; return crc ^ 0x1F;&#125;/****************************************************************************** * Name: CRC-6/ITU x6+x+1 * Poly: 0x03 * Init: 0x00 * Refin: True * Refout: True * Xorout: 0x00 * Note: *****************************************************************************/uint8_t crc6_itu(uint8_t *data, uint_len length)&#123; uint8_t i; uint8_t crc = 0; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0x30;// 0x30 = (reverse 0x03)&gt;&gt;(8-6) else crc = (crc &gt;&gt; 1); &#125; &#125; return crc;&#125;/****************************************************************************** * Name: CRC-7/MMC x7+x3+1 * Poly: 0x09 * Init: 0x00 * Refin: False * Refout: False * Xorout: 0x00 * Use: MultiMediaCard,SD,ect. *****************************************************************************/uint8_t crc7_mmc(uint8_t *data, uint_len length)&#123; uint8_t i; uint8_t crc = 0; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for ( i = 0; i &lt; 8; i++ ) &#123; if ( crc &amp; 0x80 ) crc = (crc &lt;&lt; 1) ^ 0x12; // 0x12 = 0x09&lt;&lt;(8-7) else crc &lt;&lt;= 1; &#125; &#125; return crc &gt;&gt; 1;&#125;/****************************************************************************** * Name: CRC-8 x8+x2+x+1 * Poly: 0x07 * Init: 0x00 * Refin: False * Refout: False * Xorout: 0x00 * Note: *****************************************************************************/uint8_t crc8(uint8_t *data, uint_len length)&#123; uint8_t i; uint8_t crc = 0; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for ( i = 0; i &lt; 8; i++ ) &#123; if ( crc &amp; 0x80 ) crc = (crc &lt;&lt; 1) ^ 0x07; else crc &lt;&lt;= 1; &#125; &#125; return crc;&#125;/****************************************************************************** * Name: CRC-8/ITU x8+x2+x+1 * Poly: 0x07 * Init: 0x00 * Refin: False * Refout: False * Xorout: 0x55 * Alias: CRC-8/ATM *****************************************************************************/uint8_t crc8_itu(uint8_t *data, uint_len length)&#123; uint8_t i; uint8_t crc = 0; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for ( i = 0; i &lt; 8; i++ ) &#123; if ( crc &amp; 0x80 ) crc = (crc &lt;&lt; 1) ^ 0x07; else crc &lt;&lt;= 1; &#125; &#125; return crc ^ 0x55;&#125;/****************************************************************************** * Name: CRC-8/ROHC x8+x2+x+1 * Poly: 0x07 * Init: 0xFF * Refin: True * Refout: True * Xorout: 0x00 * Note: *****************************************************************************/uint8_t crc8_rohc(uint8_t *data, uint_len length)&#123; uint8_t i; uint8_t crc = 0xFF; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0xE0; // 0xE0 = reverse 0x07 else crc = (crc &gt;&gt; 1); &#125; &#125; return crc;&#125;/****************************************************************************** * Name: CRC-8/MAXIM x8+x5+x4+1 * Poly: 0x31 * Init: 0x00 * Refin: True * Refout: True * Xorout: 0x00 * Alias: DOW-CRC,CRC-8/IBUTTON * Use: Maxim(Dallas)&#x27;s some devices,e.g. DS18B20 *****************************************************************************/uint8_t crc8_maxim(uint8_t *data, uint_len length)&#123; uint8_t i; uint8_t crc = 0; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; i++) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0x8C; // 0x8C = reverse 0x31 else crc &gt;&gt;= 1; &#125; &#125; return crc;&#125;/****************************************************************************** * Name: CRC-16/IBM x16+x15+x2+1 * Poly: 0x8005 * Init: 0x0000 * Refin: True * Refout: True * Xorout: 0x0000 * Alias: CRC-16,CRC-16/ARC,CRC-16/LHA *****************************************************************************/uint16_t crc16_ibm(uint8_t *data, uint_len length)&#123; uint8_t i; uint16_t crc = 0; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0xA001; // 0xA001 = reverse 0x8005 else crc = (crc &gt;&gt; 1); &#125; &#125; return crc;&#125;/****************************************************************************** * Name: CRC-16/MAXIM x16+x15+x2+1 * Poly: 0x8005 * Init: 0x0000 * Refin: True * Refout: True * Xorout: 0xFFFF * Note: *****************************************************************************/uint16_t crc16_maxim(uint8_t *data, uint_len length)&#123; uint8_t i; uint16_t crc = 0; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0xA001; // 0xA001 = reverse 0x8005 else crc = (crc &gt;&gt; 1); &#125; &#125; return ~crc; // crc^0xffff&#125;/****************************************************************************** * Name: CRC-16/USB x16+x15+x2+1 * Poly: 0x8005 * Init: 0xFFFF * Refin: True * Refout: True * Xorout: 0xFFFF * Note: *****************************************************************************/uint16_t crc16_usb(uint8_t *data, uint_len length)&#123; uint8_t i; uint16_t crc = 0xffff; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0xA001; // 0xA001 = reverse 0x8005 else crc = (crc &gt;&gt; 1); &#125; &#125; return ~crc; // crc^0xffff&#125;/****************************************************************************** * Name: CRC-16/MODBUS x16+x15+x2+1 * Poly: 0x8005 * Init: 0xFFFF * Refin: True * Refout: True * Xorout: 0x0000 * Note: *****************************************************************************/uint16_t crc16_modbus(uint8_t *data, uint_len length)&#123; uint8_t i; uint16_t crc = 0xffff; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0xA001; // 0xA001 = reverse 0x8005 else crc = (crc &gt;&gt; 1); &#125; &#125; return crc;&#125;/****************************************************************************** * Name: CRC-16/CCITT x16+x12+x5+1 * Poly: 0x1021 * Init: 0x0000 * Refin: True * Refout: True * Xorout: 0x0000 * Alias: CRC-CCITT,CRC-16/CCITT-TRUE,CRC-16/KERMIT *****************************************************************************/uint16_t crc16_ccitt(uint8_t *data, uint_len length)&#123; uint8_t i; uint16_t crc = 0; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0x8408; // 0x8408 = reverse 0x1021 else crc = (crc &gt;&gt; 1); &#125; &#125; return crc;&#125;/****************************************************************************** * Name: CRC-16/CCITT-FALSE x16+x12+x5+1 * Poly: 0x1021 * Init: 0xFFFF * Refin: False * Refout: False * Xorout: 0x0000 * Note: *****************************************************************************/uint16_t crc16_ccitt_false(uint8_t *data, uint_len length)&#123; uint8_t i; uint16_t crc = 0xffff; //Initial value while(length--) &#123; crc ^= (uint16_t)(*data++) &lt;&lt; 8; // crc ^= (uint6_t)(*data)&lt;&lt;8; data++; for (i = 0; i &lt; 8; ++i) &#123; if ( crc &amp; 0x8000 ) crc = (crc &lt;&lt; 1) ^ 0x1021; else crc &lt;&lt;= 1; &#125; &#125; return crc;&#125;/****************************************************************************** * Name: CRC-16/X25 x16+x12+x5+1 * Poly: 0x1021 * Init: 0xFFFF * Refin: True * Refout: True * Xorout: 0XFFFF * Note: *****************************************************************************/uint16_t crc16_x25(uint8_t *data, uint_len length)&#123; uint8_t i; uint16_t crc = 0xffff; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0x8408; // 0x8408 = reverse 0x1021 else crc = (crc &gt;&gt; 1); &#125; &#125; return ~crc; // crc^Xorout&#125;/****************************************************************************** * Name: CRC-16/XMODEM x16+x12+x5+1 * Poly: 0x1021 * Init: 0x0000 * Refin: False * Refout: False * Xorout: 0x0000 * Alias: CRC-16/ZMODEM,CRC-16/ACORN *****************************************************************************/uint16_t crc16_xmodem(uint8_t *data, uint_len length)&#123; uint8_t i; uint16_t crc = 0; // Initial value while(length--) &#123; crc ^= (uint16_t)(*data++) &lt;&lt; 8; // crc ^= (uint16_t)(*data)&lt;&lt;8; data++; for (i = 0; i &lt; 8; ++i) &#123; if ( crc &amp; 0x8000 ) crc = (crc &lt;&lt; 1) ^ 0x1021; else crc &lt;&lt;= 1; &#125; &#125; return crc;&#125;/****************************************************************************** * Name: CRC-16/DNP x16+x13+x12+x11+x10+x8+x6+x5+x2+1 * Poly: 0x3D65 * Init: 0x0000 * Refin: True * Refout: True * Xorout: 0xFFFF * Use: M-Bus,ect. *****************************************************************************/uint16_t crc16_dnp(uint8_t *data, uint_len length)&#123; uint8_t i; uint16_t crc = 0; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0xA6BC; // 0xA6BC = reverse 0x3D65 else crc = (crc &gt;&gt; 1); &#125; &#125; return ~crc; // crc^Xorout&#125;/****************************************************************************** * Name: CRC-32 x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1 * Poly: 0x4C11DB7 * Init: 0xFFFFFFF * Refin: True * Refout: True * Xorout: 0xFFFFFFF * Alias: CRC_32/ADCCP * Use: WinRAR,ect. *****************************************************************************/uint32_t crc32(uint8_t *data, uint_len length)&#123; uint8_t i; uint32_t crc = 0xffffffff; // Initial value while(length--) &#123; crc ^= *data++; // crc ^= *data; data++; for (i = 0; i &lt; 8; ++i) &#123; if (crc &amp; 1) crc = (crc &gt;&gt; 1) ^ 0xEDB88320;// 0xEDB88320= reverse 0x04C11DB7 else crc = (crc &gt;&gt; 1); &#125; &#125; return ~crc;&#125;/****************************************************************************** * Name: CRC-32/MPEG-2 x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1 * Poly: 0x4C11DB7 * Init: 0xFFFFFFF * Refin: False * Refout: False * Xorout: 0x0000000 * Note: *****************************************************************************/uint32_t crc32_mpeg_2(uint8_t *data, uint_len length)&#123; uint8_t i; uint32_t crc = 0xffffffff; // Initial value while(length--) &#123; crc ^= (uint32_t)(*data++) &lt;&lt; 24;// crc ^=(uint32_t)(*data)&lt;&lt;24; data++; for (i = 0; i &lt; 8; ++i) &#123; if ( crc &amp; 0x80000000 ) crc = (crc &lt;&lt; 1) ^ 0x04C11DB7; else crc &lt;&lt;= 1; &#125; &#125; return crc;&#125;","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"crc","slug":"stm32/crc","permalink":"http://example.com/categories/stm32/crc/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"crc","slug":"crc","permalink":"http://example.com/tags/crc/"}]},{"title":"USB报告描述符","slug":"stm32/USB key mouse","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.328Z","comments":true,"path":"2024/12/24/stm32/USB key mouse/","permalink":"http://example.com/2024/12/24/stm32/USB%20key%20mouse/","excerpt":"","text":"USB HID 报告描述符HID全称Human Interface Device。HID协议里增加了HID描述符和报告描述符，以及特定的关于HID的类请求。HID设备的通信是通过报表来进行的。据说，报告描述符是USB设备中最难的描述符了。关于HID描述符可以参考HID协议。接下来我们谈谈报告描述符。 鼠标它描述了4个字节，第一个字节表示按键，第二个字节表示x轴（即鼠标左右移动，0表示不动，正值表示往右移，负值表示往左移），第三个字节表示y轴（即鼠标上下移动，0表示不动，正值表示往下移动，负值表示往上移动），第四个字节表示鼠标滚轮（正值为往上滚动，负值为往下滚动）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758code char MouseReportDescriptor[52] = &#123; //通用桌面设备 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //鼠标 0x09, 0x02, // USAGE (Mouse) //集合 0xa1, 0x01, // COLLECTION (Application) //指针设备 0x09, 0x01, // USAGE (Pointer) //集合 0xa1, 0x00, // COLLECTION (Physical) //按键 0x05, 0x09, // USAGE_PAGE (Button) //使用最小值1 0x19, 0x01, // USAGE_MINIMUM (Button 1) //使用最大值3。1表示左键，2表示右键，3表示中键 0x29, 0x03, // USAGE_MAXIMUM (Button 3) //逻辑最小值0 0x15, 0x00, // LOGICAL_MINIMUM (0) //逻辑最大值1 0x25, 0x01, // LOGICAL_MAXIMUM (1) //数量为3 0x95, 0x03, // REPORT_COUNT (3) //大小为1bit 0x75, 0x01, // REPORT_SIZE (1) //输入，变量，数值，绝对值 //以上3个bit分别表示鼠标的三个按键情况，最低位（bit-0）为左键 //bit-1为右键，bit-2为中键，按下时对应的位值为1，释放时对应的值为0 0x81, 0x02, // INPUT (Data,Var,Abs) //填充5个bit，补足一个字节 0x95, 0x01, // REPORT_COUNT (1) 0x75, 0x05, // REPORT_SIZE (5) 0x81, 0x03, // INPUT (Cnst,Var,Abs) //用途页为通用桌面 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //用途为X 0x09, 0x30, // USAGE (X) //用途为Y 0x09, 0x31, // USAGE (Y) //用途为滚轮 0x09, 0x38, // USAGE (Wheel) //逻辑最小值为-127 0x15, 0x81, // LOGICAL_MINIMUM (-127) //逻辑最大值为+127 0x25, 0x7f, // LOGICAL_MAXIMUM (127) //大小为8个bits 0x75, 0x08, // REPORT_SIZE (8) //数量为3个，即分别代表x,y,滚轮 0x95, 0x03, // REPORT_COUNT (3) //输入，变量，值，相对值 0x81, 0x06, // INPUT (Data,Var,Rel) //关集合 0xc0, // END_COLLECTION 0xc0 // END_COLLECTION &#125;; 通过对上面的报告分析，我们知道报告返回4个字节，没有报告ID。如果鼠标左键按下，则返回01 00 00 00（十六进制值），如果右键按下，则返回02 00 00 00，如果中键按下，则返回04 00 00 00，如果三个键同时按下，则返回07 00 00 00。如果鼠标往右移动则第二字节返回正值，值越大移动速度越快。其它的类推。 键盘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798code char KeyBoardReportDescriptor[63] = &#123; //表示用途页为通用桌面设备 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //表示用途为键盘 0x09, 0x06, // USAGE (Keyboard) //表示应用集合，必须要以END_COLLECTION来结束它，见最后的END_COLLECTION 0xa1, 0x01, // COLLECTION (Application) //表示用途页为按键 0x05, 0x07, // USAGE_PAGE (Keyboard) //用途最小值，这里为左ctrl键 0x19, 0xe0, // USAGE_MINIMUM (Keyboard LeftControl) //用途最大值，这里为右GUI键，即window键 0x29, 0xe7, // USAGE_MAXIMUM (Keyboard Right GUI) //逻辑最小值为0 0x15, 0x00, // LOGICAL_MINIMUM (0) //逻辑最大值为1 0x25, 0x01, // LOGICAL_MAXIMUM (1) //报告大小（即这个字段的宽度）为1bit，所以前面的逻辑最小值为0，逻辑最大值为1 0x75, 0x01, // REPORT_SIZE (1) //报告的个数为8，即总共有8个bits 0x95, 0x08, // REPORT_COUNT (8) //输入用，变量，值，绝对值。像键盘这类一般报告绝对值， //而鼠标移动这样的则报告相对值，表示鼠标移动多少 0x81, 0x02, // INPUT (Data,Var,Abs) //上面这这几项描述了一个输入用的字段，总共为8个bits，每个bit表示一个按键 //分别从左ctrl键到右GUI键。这8个bits刚好构成一个字节，它位于报告的第一个字节。 //它的最低位，即bit-0对应着左ctrl键，如果返回的数据该位为1，则表示左ctrl键被按下， //否则，左ctrl键没有按下。最高位，即bit-7表示右GUI键的按下情况。中间的几个位， //需要根据HID协议中规定的用途页表（HID Usage Tables）来确定。这里通常用来表示 //特殊键，例如ctrl，shift，del键等 //这样的数据段个数为1 0x95, 0x01, // REPORT_COUNT (1) //每个段长度为8bits 0x75, 0x08, // REPORT_SIZE (8) //输入用，常量，值，绝对值 0x81, 0x03, // INPUT (Cnst,Var,Abs) //上面这8个bit是常量，设备必须返回0 //这样的数据段个数为5 0x95, 0x05, // REPORT_COUNT (5) //每个段大小为1bit 0x75, 0x01, // REPORT_SIZE (1) //用途是LED，即用来控制键盘上的LED用的，因此下面会说明它是输出用 0x05, 0x08, // USAGE_PAGE (LEDs) //用途最小值是Num Lock，即数字键锁定灯 0x19, 0x01, // USAGE_MINIMUM (Num Lock) //用途最大值是Kana，这个是什么灯我也不清楚^_^ 0x29, 0x05, // USAGE_MAXIMUM (Kana) //如前面所说，这个字段是输出用的，用来控制LED。变量，值，绝对值。 //1表示灯亮，0表示灯灭 0x91, 0x02, // OUTPUT (Data,Var,Abs) //这样的数据段个数为1 0x95, 0x01, // REPORT_COUNT (1) //每个段大小为3bits 0x75, 0x03, // REPORT_SIZE (3) //输出用，常量，值，绝对 0x91, 0x03, // OUTPUT (Cnst,Var,Abs) //由于要按字节对齐，而前面控制LED的只用了5个bit， //所以后面需要附加3个不用bit，设置为常量。 //报告个数为6 0x95, 0x06, // REPORT_COUNT (6) //每个段大小为8bits 0x75, 0x08, // REPORT_SIZE (8) //逻辑最小值0 0x15, 0x00, // LOGICAL_MINIMUM (0) //逻辑最大值255 0x25, 0xFF, // LOGICAL_MAXIMUM (255) //用途页为按键 0x05, 0x07, // USAGE_PAGE (Keyboard) //使用最小值为0 0x19, 0x00, // USAGE_MINIMUM (Reserved (no event indicated)) //使用最大值为0x65 0x29, 0x65, // USAGE_MAXIMUM (Keyboard Application) //输入用，变量，数组，绝对值 0x81, 0x00, // INPUT (Data,Ary,Abs) //以上定义了6个8bit宽的数组，每个8bit（即一个字节）用来表示一个按键，所以可以同时 //有6个按键按下。没有按键按下时，全部返回0。如果按下的键太多，导致键盘扫描系统 //无法区分按键时，则全部返回0x01，即6个0x01。如果有一个键按下，则这6个字节中的第一 //个字节为相应的键值（具体的值参看HID Usage Tables），如果两个键按下，则第1、2两个 //字节分别为相应的键值，以次类推。 //关集合，跟上面的对应 0xc0 // END_COLLECTION &#125;; 通过上面的分析，我们知道这个报告中只有一个报告，所以没有报告ID，因此返回的都是实际使用的数据。总共有8字节输入，1字节输出。其中输入的第一字节用来表示特殊按键，第二字节保留，后面的六字节为普通按键。 如果只有左ctrl键按下，则返回01 00 00 00 00 00 00 00（十六进制）， 如果只有数字键1 按下，则返回00 00 59 00 00 00 00 00， 如果数字键1 和2 同时按下，则返回00 00 59 5A 00 00 00 00， 如果再按下左shift 键，则返回02 00 59 5A 00 00 00 00， 然后再释放1 键，则返回02 00 5A 00 00 00 00 00， 然后全部按键释放，则返回00 00 00 00 00 00 00 00。 这些数据（即报告）都是通过中断端点返回的。当按下Num Lock键时，PC会发送输出报告，从报告描述符中我们知道，Num Lock的LED对应着输出报告的最低位，当数字小键盘打开时，输出xxxxxxx1（二进制，打x的由其它的LED状态决定）；当数字小键盘关闭时，输出xxxxxxx0（同前）。取出最低位就可以控制数字键锁定LED了。","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"usb","slug":"stm32/usb","permalink":"http://example.com/categories/stm32/usb/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"usb","slug":"usb","permalink":"http://example.com/tags/usb/"}]},{"title":"stm32 USB","slug":"stm32/USB","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.330Z","comments":true,"path":"2024/12/24/stm32/USB/","permalink":"http://example.com/2024/12/24/stm32/USB/","excerpt":"","text":"stm32 USBDEVICEwireshark的usb抓包分析 STM32F103 USB EP0通信数据详解 USB的端点描述符详解 Custom HID 1.描述符:12345678910111213141516171819202122232425__ALIGN_BEGIN static uint8_t CUSTOM_HID_ReportDesc_FS[USBD_CUSTOM_HID_REPORT_DESC_SIZE] __ALIGN_END =&#123; /* USER CODE BEGIN 0 */ 0x05, 0x8c, /* USAGE_PAGE (ST Page) */ 0x09, 0x01, /* USAGE (Demo Kit) */ 0xa1, 0x01, /* COLLECTION (Application) */ // The Input report 0x09,0x03, // USAGE ID - Vendor defined 0x15,0x00, // LOGICAL_MINIMUM (0) 0x26,0x00, 0xFF, // LOGICAL_MAXIMUM (255) 0x75,0x08, // REPORT_SIZE (8bit) 0x95,0x40, // REPORT_COUNT (64Byte) 0x81,0x02, // INPUT (Data,Var,Abs) // The Output report 0x09,0x04, // USAGE ID - Vendor defined 0x15,0x00, // LOGICAL_MINIMUM (0) 0x26,0x00,0xFF, // LOGICAL_MAXIMUM (255) 0x75,0x08, // REPORT_SIZE (8bit) 0x95,0x40, // REPORT_COUNT (64Byte) 0x91,0x02, // OUTPUT (Data,Var,Abs) /* USER CODE END 0 */ 0xC0 /* END_COLLECTION */&#125;; 2.usbd_conf.h做buff长度修改：123#define USBD_CUSTOMHID_OUTREPORT_BUF_SIZE 64#define USBD_CUSTOM_HID_REPORT_DESC_SIZE 33 usbd_customhid.h文件中的发送与接收长度123#define CUSTOM_HID_EPIN_SIZE 0x40#define CUSTOM_HID_EPOUT_SIZE 0x40 3.收发内容:123456789101112131415161718uint8_t USB_Recive_Buffer[64];static uint8_t USBD_CUSTOM_HID_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum)&#123; USBD_CUSTOM_HID_HandleTypeDef *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)pdev-&gt;pClassData; /* ((USBD_CUSTOM_HID_ItfTypeDef *)pdev-&gt;pUserData)-&gt;OutEvent(hhid-&gt;Report_buf[0], hhid-&gt;Report_buf[1]); USBD_LL_PrepareReceive(pdev, CUSTOM_HID_EPOUT_ADDR , hhid-&gt;Report_buf, USBD_CUSTOMHID_OUTREPORT_BUF_SIZE); */ USBD_CUSTOM_HID_SendReport(pdev,USB_Recive_Buffer,64); USBD_LL_PrepareReceive( pdev, CUSTOM_HID_EPOUT_ADDR , USB_Recive_Buffer, sizeof( USB_Recive_Buffer ) ); return USBD_OK;&#125; CDC接收 1static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len) 发送 1CDC_Transmit_FS HID_MOUSEDemo:鼠标每秒右移10 12345678910111213141516struct mouseHID_t &#123; uint8_t buttons;//左0x0001 右0x0010 中0x0100 int8_t x;//+:右 -:左 int8_t y; int8_t wheel;//+:上 -:下&#125;;struct mouseHID_t mouseHID;mouseHID.buttons = 0;mouseHID.x = 10;mouseHID.y = 0;mouseHID.wheel = 0; mouseHID.x = 10; USBD_HID_SendReport(&amp;hUsbDeviceFS, (uint8_t*)&amp;mouseHID, sizeof(struct mouseHID_t)); HAL_Delay(1000); HID_KEY usbd_hid.h文件 12#define HID_EPIN_SIZE 0x08#define HID_MOUSE_REPORT_DESC_SIZE 63 usbd_desc.c文件 12// #define USBD_VID 0x1111 #define USBD_PID_FS 0x1111 usbd_hid.c文件 10x01, /*nInterfaceProtocol : 0=none, 1=keyboard, 2=mouse*/ 123456789101112131415161718192021222324252627282930313233HID_MOUSE_ReportDesc[HID_MOUSE_REPORT_DESC_SIZE] 0x05, 0x01, // USAGE_PAGE (Generic Desktop) //63 0x09, 0x06, // USAGE (Keyboard) 0xa1, 0x01, // COLLECTION (Application) 0x05, 0x07, // USAGE_PAGE (Keyboard) 0x19, 0xe0, // USAGE_MINIMUM (Keyboard LeftControl) 0x29, 0xe7, // USAGE_MAXIMUM (Keyboard Right GUI) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x25, 0x01, // LOGICAL_MAXIMUM (1) 0x75, 0x01, // REPORT_SIZE (1) 0x95, 0x08, // REPORT_COUNT (8) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x95, 0x01, // REPORT_COUNT (1) 0x75, 0x08, // REPORT_SIZE (8) 0x81, 0x03, // INPUT (Cnst,Var,Abs) 0x95, 0x05, // REPORT_COUNT (5) 0x75, 0x01, // REPORT_SIZE (1) 0x05, 0x08, // USAGE_PAGE (LEDs) 0x19, 0x01, // USAGE_MINIMUM (Num Lock) 0x29, 0x05, // USAGE_MAXIMUM (Kana) 0x91, 0x02, // OUTPUT (Data,Var,Abs) 0x95, 0x01, // REPORT_COUNT (1) 0x75, 0x03, // REPORT_SIZE (3) 0x91, 0x03, // OUTPUT (Cnst,Var,Abs) 0x95, 0x06, // REPORT_COUNT (6) 0x75, 0x08, // REPORT_SIZE (8) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x25, 0x65, // LOGICAL_MAXIMUM (101) 0x05, 0x07, // USAGE_PAGE (Keyboard) 0x19, 0x00, // USAGE_MINIMUM (Reserved (no event indicated)) 0x29, 0x65, // USAGE_MAXIMUM (Keyboard Application) 0x81, 0x00, // INPUT (Data,Ary,Abs) 0xc0, // END_COLLECTION Demo:输出按键A 1234567891011121314151617181920212223242526/** buffer[0] - bit0: Left CTRL* -bit1: Left SHIFT* -bit2: Left ALT* -bit3: Left GUI* -bit4: Right CTRL* -bit5: Right SHIFT* -bit6: Right ALT* -bit7: Right GUI * buffer[1] - Padding = Always 0x00* buffer[2] - Key 1* buffer[3] - Key 2* buffer[4] - Key 3* buffer[5] - Key 4* buffer[6] - Key 5* buffer[7] - Key 6*/ buffer[0] = 0x02; //shift buffer[2] = 0x04; // a USBD_HID_SendReport(&amp;hUsbDeviceFS, buffer, 8); //send HAL_Delay(15); //delay buffer[0] = 0x00; buffer[2] = 0x00; USBD_HID_SendReport(&amp;hUsbDeviceFS, buffer, 8); HAL_Delay(15); HOSTHID_KeyMouse 1234567891011121314151617181920212223242526void USBMouseHandler(void)&#123; static uint8_t temp; if (Appli_state == APPLICATION_READY) &#123; //keyboard if (USBH_HID_GetDeviceType(&amp;hUsbHostFS) == HID_KEYBOARD) &#123; HID_KEYBD_Info_TypeDef *KeyEvent = USBH_HID_GetKeybdInfo(&amp;hUsbHostFS); if (temp != USBH_HID_GetASCIICode(KeyEvent)) &#123; temp = USBH_HID_GetASCIICode(KeyEvent); printf(&quot;%c&quot;,USBH_HID_GetASCIICode(KeyEvent)); &#125; &#125; //mouse else if (USBH_HID_GetDeviceType(&amp;hUsbHostFS) == HID_MOUSE) &#123; HID_MOUSE_Info_TypeDef *MouseEvent = USBH_HID_GetMouseInfo(&amp;hUsbHostFS); if (MouseEvent != NULL) &#123; printf(&quot;button:%d\\r\\n&quot;,MouseEvent-&gt;buttons[0]); &#125; &#125; &#125;&#125; 需要对枚举状态判断 1234567891011121314151617static uint8_t i;//-------------------------------- case HOST_ENUMERATION://-------------------------------- i = 0; &#125; else &#123; i++; USBH_Delay(10); if (i&gt;200) &#123; i = 0; phost-&gt;gState = HOST_DEV_DISCONNECTED; &#125; &#125; 长时间枚举失败 返回","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"usb","slug":"stm32/usb","permalink":"http://example.com/categories/stm32/usb/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"usb","slug":"usb","permalink":"http://example.com/tags/usb/"}]},{"title":"Scrapy","slug":"python/scrapy","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.337Z","comments":true,"path":"2024/12/24/python/scrapy/","permalink":"http://example.com/2024/12/24/python/scrapy/","excerpt":"","text":"scrapy 新建项目1scrapy startproject lianjia 打开目录1cd lianjia 新建爬虫1scrapy genspider fang wh.lianjia.com/ershoufang 运行爬虫 1scrapy crawl fang 工程修改 settings.py配置参数相关 1234//robots.txt 规则 ROBOTSTXT_OBEY = False//延时 DOWNLOAD_DELAY = 0.2 pipelines.py存储相关 12345678910111213141516171819202122from itemadapter import ItemAdapterimport csvimport codecsclass LianjiaPipeline: def process_item(self, item, spider): # self.filename = &#x27;a.csv&#x27; self.filename = str(item[&#x27;local&#x27;]+&#x27;.csv&#x27;) self.file = codecs.open(self.filename, &#x27;a&#x27;, encoding=&#x27;gbk&#x27;)#&#x27;utf_8_sig&#x27; fieldnames = [&#x27;local&#x27;,&#x27;page&#x27;,&#x27;cnt&#x27;,&#x27;title&#x27;, &#x27;html&#x27;,&#x27;flood&#x27;, &#x27;type&#x27;,&#x27;area&#x27;,&#x27;dir&#x27;,&#x27;mode1&#x27;,&#x27;mode2&#x27;,&#x27;mode3&#x27;,&#x27;price&#x27;, &#x27;unit&#x27;]#,&#x27;year&#x27; # fieldnames = [&#x27;title&#x27;, &#x27;flood&#x27;, &#x27;address&#x27;,&#x27;price&#x27;, &#x27;unit&#x27;] w = csv.DictWriter(self.file, fieldnames=fieldnames) w.writerow(item) self.file.close() return item# def __init__(self):# self.file = codecs.open(&#x27;zhuankou.csv&#x27;, &#x27;w&#x27;, encoding=&#x27;gbk&#x27;)#&#x27;utf_8_sig&#x27;# def close_spider(self, spider):# self.file.close() items.py注册项 12345678910111213141516171819202122232425262728import scrapyclass LianjiaItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() local= scrapy.Field() page = scrapy.Field() cnt =scrapy.Field() title= scrapy.Field() html= scrapy.Field() flood= scrapy.Field() address= scrapy.Field() type= scrapy.Field() area= scrapy.Field() dir= scrapy.Field() mode1= scrapy.Field() mode2= scrapy.Field() # year= scrapy.Field() mode3= scrapy.Field() price= scrapy.Field() unit= scrapy.Field() pass spiders解析相关 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import scrapyfrom lianjia.items import LianjiaItemclass FangSpider(scrapy.Spider): name = &#x27;fang&#x27; allowed_domains = [&#x27;wh.lianjia.com&#x27;] start_urls = [&#x27;http://wh.lianjia.com/ershoufang/&#x27;]#+pg1/ getpathall = [] urlnum = 0 &#x27;&#x27;&#x27; #解析全部区域 def start_requests(self): self.base = &#x27;http://wh.lianjia.com&#x27; url = &#x27;http://wh.lianjia.com/ershoufang/&#x27; yield scrapy.Request(url=url,callback=self.parse_url) def parse_url(self,response): locals = response.xpath(&#x27;//div[@class=&quot;position&quot;]//div[@data-role=&quot;ershoufang&quot;]//a[@title]/@href&#x27;).extract() # print(locals) self.getpathall.extend(locals) cnt = len(locals) # print(cnt) for list in locals: url = self.base +list # print(url) yield scrapy.Request(url=url,meta=&#123;&#x27;flag&#x27;:cnt&#125;,callback=self.prase_local) # print(list) def prase_local(self,response): self.urlnum+=1 self.area = response.xpath(&#x27;//div[@class=&quot;position&quot;]//div[@data-role=&quot;ershoufang&quot;]//div[2]//a/@href&#x27;).extract() # print(self.area) self.getpathall.extend(self.area) # print(self.urlnum) num = response.meta[&#x27;flag&#x27;] if num == self.urlnum: set(self.getpathall) for list in self.getpathall: url = self.base+list local = list.split(&#x27;/&#x27;)[2] yield scrapy.Request(url=url,meta=&#123;&#x27;local&#x27;:local&#125;,callback=self.parse_list) print(&#x27;获取区域列表&#x27;) print(list) &#x27;&#x27;&#x27; def start_requests(self): # def parse_list(self,response): # local = response.meta[&#x27;local&#x27;] total = 100 local = &#x27;guanggudong&#x27; print(&#x27;解析区域:&#x27;+local) for i in range(1,total): if i &gt; 1: url=&quot;http://wh.lianjia.com/ershoufang/&#123;0&#125;/pg&#123;1&#125;/&quot;.format(local,i) # print(url) else: url = &#x27;http://wh.lianjia.com/ershoufang/&#123;&#125;&#x27;.format(local) yield scrapy.Request(url=url,meta=&#123;&#x27;local&#x27;:local,&#x27;page&#x27;:i&#125;,callback=self.parse) def parse(self, response): item=LianjiaItem() item[&#x27;local&#x27;] = response.meta[&#x27;local&#x27;] item[&#x27;page&#x27;] = response.meta[&#x27;page&#x27;] xpath_parse = response.xpath(&#x27;//div[@class=&quot;info clear&quot;]&#x27;) print(&quot;获取第&#123;&#125;页&quot;.format(item[&#x27;page&#x27;])) cnt = 1 for xpath in xpath_parse: item[&#x27;cnt&#x27;] = cnt item[&#x27;title&#x27;] = xpath.xpath(&#x27;.//div[@class=&quot;title&quot;]//a/text()&#x27;).get() # print(item[&#x27;title&#x27;]) item[&#x27;html&#x27;] = xpath.xpath(&#x27;.//div[@class=&quot;title&quot;]//a/@href&#x27;).get() item[&#x27;flood&#x27;] = xpath.xpath(&#x27;.//div[@class=&quot;flood&quot;]//a/text()&#x27;).get() # item[&#x27;address&#x27;] = xpath.xpath(&#x27;.//div[@class=&quot;address&quot;]//div/text()&#x27;).get() strinfo = xpath.xpath(&#x27;.//div[@class=&quot;address&quot;]//div/text()&#x27;).get() list = strinfo.split(&#x27;|&#x27;,5) item[&#x27;type&#x27;] = list[0] item[&#x27;area&#x27;] = list[1] item[&#x27;dir&#x27;] = list[2] item[&#x27;mode1&#x27;] = list[3] item[&#x27;mode2&#x27;] = list[4] item[&#x27;mode3&#x27;] = list[5] item[&#x27;price&#x27;] = xpath.xpath(&#x27;.//div[@class=&quot;totalPrice totalPrice2&quot;]//span//text()&#x27;).get() item[&#x27;price&#x27;] += xpath.xpath(&#x27;.//div[@class=&quot;totalPrice totalPrice2&quot;]//i[2]//text()&#x27;).get() item[&#x27;unit&#x27;] = xpath.xpath(&#x27;.//div[@class=&quot;unitPrice&quot;]//span//text()&#x27;).get() cnt+=1 yield(item) pass","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"爬虫","slug":"python/爬虫","permalink":"http://example.com/categories/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"编译断言","slug":"stm32/assert","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.328Z","comments":true,"path":"2024/12/24/stm32/assert/","permalink":"http://example.com/2024/12/24/stm32/assert/","excerpt":"","text":"编译断言编译期间断言判断利用枚举数判断12345678910#define COMPILER_CONCAT_(a, b) a##b#define COMPILER_CONCAT(a, b) COMPILER_CONCAT_(a, b)// Divide by zero if the the expression is false. This// causes an error at compile time.//// The special value &#x27;__COUNTER__&#x27; is used to create a unique value to// append to &#x27;compiler_assert_&#x27; to create a unique token. This prevents// conflicts resulting from the same enum being declared multiple times.#define COMPILER_ASSERT(e) enum &#123; COMPILER_CONCAT(compiler_assert_, __COUNTER__) = 1/((e) ? 1 : 0) &#125; 1234567891011121314151617181920//(4位)单hex转字符static char hex_to_ascii(uint8_t x)&#123; return (&#x27;0&#x27; + (x&gt;9 ? x+0x27 : x));&#125;//8位HEX转字符串uint32_t util_write_hex8(char *str, uint8_t value)&#123; static const char nybble_chars[] = &quot;0123456789abcdef&quot;; *(str + 0) = nybble_chars[(value &gt;&gt; 4) &amp; 0x0F ]; *(str + 1) = nybble_chars[(value &gt;&gt; 0) &amp; 0x0F ]; return 2;&#125;//字符转数static uint8_t ctoh(char c)&#123; return (c &amp; 0x10) ? /*0-9*/ c &amp; 0xf : /*A-F, a-f*/ (c &amp; 0xf) + 9;&#125;","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"}]},{"title":"DAPLink","slug":"stm32/daplink","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.328Z","comments":true,"path":"2024/12/24/stm32/daplink/","permalink":"http://example.com/2024/12/24/stm32/daplink/","excerpt":"","text":"DAPLink去掉USB的IAP功能,bootloader省掉，APP部分修改宏定义大小，可用stm32f103c8t6stm32f103xb_stm32f103rb_if 比stm32f103xb_if 多了g_target_family定义init_family函数直接返回,多了目标配置 12345init_family();if (g_target_family &amp;&amp; g_target_family-&gt;prerun_target_config) &#123; g_target_family-&gt;prerun_target_config();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @file daplink_addr.h * @brief * * DAPLink Interface Firmware * */#ifndef DAPLINK_ADDR_H#define DAPLINK_ADDR_H/* Device sizes */#define DAPLINK_ROM_START 0x08000000#define DAPLINK_ROM_SIZE 0x00010000#define DAPLINK_RAM_START 0x20000000#define DAPLINK_RAM_SIZE 0x00005000/* ROM sizes */#define DAPLINK_ROM_BL_START 0x08000000#define DAPLINK_ROM_BL_SIZE 0#define DAPLINK_ROM_CONFIG_ADMIN_START 0x08000000#define DAPLINK_ROM_CONFIG_ADMIN_SIZE 0#define DAPLINK_ROM_IF_START 0x08000000#define DAPLINK_ROM_IF_SIZE 0x0000FC00#define DAPLINK_ROM_CONFIG_USER_START 0x0800FC00#define DAPLINK_ROM_CONFIG_USER_SIZE 0x00000400/* RAM sizes */#define DAPLINK_RAM_APP_START 0x20000000#define DAPLINK_RAM_APP_SIZE 0x00004F00#define DAPLINK_RAM_SHARED_START 0x20004F00#define DAPLINK_RAM_SHARED_SIZE 0x00000100/* Flash Programming Info */#define DAPLINK_SECTOR_SIZE 0x00000400#define DAPLINK_MIN_WRITE_SIZE 0x00000400/* Current build */#if defined(DAPLINK_BL)#define DAPLINK_ROM_APP_START DAPLINK_ROM_BL_START#define DAPLINK_ROM_APP_SIZE DAPLINK_ROM_BL_SIZE#define DAPLINK_ROM_UPDATE_START DAPLINK_ROM_IF_START#define DAPLINK_ROM_UPDATE_SIZE DAPLINK_ROM_IF_SIZE#elif defined(DAPLINK_IF)#define DAPLINK_ROM_APP_START DAPLINK_ROM_IF_START#define DAPLINK_ROM_APP_SIZE DAPLINK_ROM_IF_SIZE#define DAPLINK_ROM_UPDATE_START DAPLINK_ROM_BL_START#define DAPLINK_ROM_UPDATE_SIZE DAPLINK_ROM_BL_SIZE#else#error &quot;Build must be either bootloader or interface&quot;#endif#endif IO_Config.h修改配置更改IO口,uart.c修改CDC串口。可引出boot0,CDC改用串口1，使用ISP烧录，增加nReset按键，增加各外设LED指示可以在vfs_user.c加入使用信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static uint32_t update_details_txt_file(uint8_t *buf, uint32_t size, uint32_t start)&#123; uint32_t pos = 0; pos += util_write_string_in_region(buf, size, start, pos, &quot;Author: guoxin\\r\\n\\r\\n&quot; // Build ID &quot;Build ID: (&quot; COMPILER_DESCRIPTION LOCAL_MODS &quot;)\\r\\n&quot;); // Unique ID pos += expand_string_in_region(buf, size, start, pos, &quot;Unique ID: @U\\r\\n&quot;); // HIC ID pos += expand_string_in_region(buf, size, start, pos, &quot;HIC ID: @D\\r\\n&quot;); // Settings pos += setting_in_region(buf, size, start, pos, &quot;Auto Reset&quot;, config_get_auto_rst()); pos += setting_in_region(buf, size, start, pos, &quot;Automation allowed&quot;, config_get_automation_allowed()); pos += setting_in_region(buf, size, start, pos, &quot;Overflow detection&quot;, config_get_overflow_detect()); pos += setting_in_region(buf, size, start, pos, &quot;Incompatible image detection&quot;, config_get_detect_incompatible_target()); pos += setting_in_region(buf, size, start, pos, &quot;Page erasing&quot;, config_ram_get_page_erase()); // Current mode and version#if defined(DAPLINK_BL) pos += util_write_string_in_region(buf, size, start, pos, &quot;Daplink Mode: Bootloader\\r\\n&quot;); pos += expand_string_in_region(buf, size, start, pos, &quot;Bootloader Version: @V\\r\\n&quot;); if (info_get_interface_present()) &#123; char version[6] = &#123; 0, 0, 0, 0, &#x27;\\r&#x27;, &#x27;\\n&#x27; &#125;; pos += util_write_string_in_region(buf, size, start, pos, &quot;Interface Version: &quot;); util_write_uint32_zp(version, info_get_interface_version(), 4); pos += util_write_in_region(buf, size, start, pos, version, 6); &#125;#elif defined(DAPLINK_IF) pos += util_write_string_in_region(buf, size, start, pos, &quot;Daplink Mode: Interface\\r\\n&quot;); pos += expand_string_in_region(buf, size, start, pos, &quot;Interface Version: @V\\r\\n&quot;);#if DAPLINK_ROM_BL_SIZE != 0 if (info_get_bootloader_present()) &#123; char version[6] = &#123; 0, 0, 0, 0, &#x27;\\r&#x27;, &#x27;\\n&#x27; &#125;; pos += util_write_string_in_region(buf, size, start, pos, &quot;Bootloader Version: &quot;); util_write_uint32_zp(version, info_get_bootloader_version(), 4); pos += util_write_in_region(buf, size, start, pos, version, 6); &#125;#endif#endif pos += util_write_string_in_region(buf, size, start, pos, // Local modifications when making the build#if GIT_LOCAL_MODS &quot;Local Mods: 1\\r\\n&quot;#else &quot;Local Mods: 0\\r\\n&quot;#endif // Supported USB endpoints &quot;USB Interfaces: &quot;#ifdef MSC_ENDPOINT &quot;MSD&quot;#endif#ifdef CDC_ENDPOINT &quot;, CDC&quot;#endif#ifdef HID_ENDPOINT &quot;, HID&quot;#endif#if (WEBUSB_INTERFACE) &quot;, WebUSB&quot;#endif &quot;\\r\\n&quot;);#if DAPLINK_ROM_BL_SIZE != 0 // CRC of the bootloader (if there is one) if (info_get_bootloader_present()) &#123; pos += hex32_field_in_region(buf, size, start, pos, &quot;Bootloader CRC&quot;, info_get_crc_bootloader()); &#125;#endif // CRC of the interface pos += hex32_field_in_region(buf, size, start, pos, &quot;Interface CRC&quot;, info_get_crc_interface()); // Number of remounts that have occurred pos += uint32_field_in_region(buf, size, start, pos, &quot;Remount count&quot;, remount_count); //Target URL pos += expand_string_in_region(buf, size, start, pos, &quot;target mcu: stm32f103rb\\r\\n&quot;); pos += expand_string_in_region(buf, size, start, pos, &quot;\\r\\nUSART-&gt;TX:A2 RX:A3\\r\\nSWD-&gt;CLK:B13 DIO:B14 (DIO_IN:A12)\\r\\nJTAG-&gt;TDI:A7 TDO:A5\\r\\nLED:A9&quot;); return pos;&#125; 12//修改虚拟硬盘文件void vfs_user_build_filesystem() 12//修改磁盘名称static inline const char * get_daplink_drive_name ( void )","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"DAPLink","slug":"stm32/DAPLink","permalink":"http://example.com/categories/stm32/DAPLink/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"DAPLink","slug":"DAPLink","permalink":"http://example.com/tags/DAPLink/"}]},{"title":"objdump","slug":"stm32/dump","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.330Z","comments":true,"path":"2024/12/24/stm32/dump/","permalink":"http://example.com/2024/12/24/stm32/dump/","excerpt":"","text":"objdump - 显示二进制文件信息 输出代码arm-none-eabi-objdump -j .text -S test.elf 输出汇编arm-none-eabi-objdump -D test.elf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687--archive-headers -a 显示档案库的成员信息,类似ls -l将lib*.a的信息列出。 -b bfdname --target=bfdname 指定目标码格式。这不是必须的，objdump能自动识别许多格式，比如： objdump -b oasys -m vax -h fu.o 显示fu.o的头部摘要信息，明确指出该文件是Vax系统下用Oasys编译器生成的目标文件。objdump -i将给出这里可以指定的目标码格式列表。 -C --demangle 将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得C++函数名以可理解的方式显示出来。 --debugging -g 显示调试信息。企图解析保存在文件中的调试信息并以C语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持。 -e --debugging-tags 类似-g选项，但是生成的信息是和ctags工具相兼容的格式。 --disassemble -d 从objfile中反汇编那些特定指令机器码的section。 -D --disassemble-all 与 -d 类似，但反汇编所有section. --prefix-addresses 反汇编的时候，显示每一行的完整地址。这是一种比较老的反汇编格式。 -EB -EL --endian=&#123;big|little&#125; 指定目标文件的小端。这个项将影响反汇编出来的指令。在反汇编的文件没描述小端信息的时候用。例如S-records. -f --file-headers 显示objfile中每个文件的整体头部摘要信息。 -h --section-headers --headers 显示目标文件各个section的头部摘要信息。 -H --help 简短的帮助信息。 -i --info 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。 -j name--section=name 仅仅显示指定名称为name的section的信息 -l--line-numbers 用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用使用-ld和使用-d的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g之类的调试编译选项。 -m machine --architecture=machine 指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候(比如S-records)，这个选项很有用。可以用-i选项列出这里能够指定的架构. --reloc -r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。 --dynamic-reloc -R 显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库。 -s --full-contents 显示指定section的完整内容。默认所有的非空section都会被显示。 -S --source 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。 --show-raw-insn 反汇编的时候，显示每条汇编指令对应的机器码，如不指定--prefix-addresses，这将是缺省选项。 --no-show-raw-insn 反汇编时，不显示汇编指令的机器码，如不指定--prefix-addresses，这将是缺省选项。 --start-address=address 从指定地址开始显示数据，该选项影响-d、-r和-s选项的输出。 --stop-address=address 显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出。 -t --syms 显示文件的符号表入口。类似于nm -s提供的信息 -T --dynamic-syms 显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D|--dynamic 显示的信息。 -V --version 版本信息 --all-headers -x 显示所可用的头信息，包括符号表、重定位入口。-x 等价于-a -f -h -r -t 同时指定。 -z --disassemble-zeroes 一般反汇编输出将省略大块的零，该选项使得这些零块也被反汇编。 @file 可以将选项集中到一个文件中，然后使用这个@file选项载入。","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"objdump","slug":"stm32/objdump","permalink":"http://example.com/categories/stm32/objdump/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"objdump","slug":"objdump","permalink":"http://example.com/tags/objdump/"}]},{"title":"HardFault","slug":"stm32/hardfault","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-28T01:49:30.224Z","comments":true,"path":"2024/12/24/stm32/hardfault/","permalink":"http://example.com/2024/12/24/stm32/hardfault/","excerpt":"","text":"HardFaultMSP的含义是Main_Stack_Pointer，即主栈PSP的含义是 Process_Stack_Pointer,即任务栈 armcortex-m的设计，一共有32个寄存器13个通用寄存器，r0-r121个栈指针寄存器SP(r13)，PSP(SP_process)和MSP(SP_main)1个链接寄存器LR(r14)，执行下一级函数自动存放LR压栈，函数返回的时会弹出LR到PC1个程序计数器PC(r15)，指向当前指向的程序地址1个程序状态寄存器（xPSR） r0~r3 用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。 r4~r11 被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。 r12 是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。 r13 是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。 r14 是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复 r15 是程序计数器 PC。它不能用于任何其它用途。 注意：在中断程序中，所有的寄存器都必须保护，编译器会自动保护R4～R11 不同的模式下，R0-R12、SP、LR是各有一份的，所以这样算下来，总共是32个寄存器，但是在不同的模式下，并不能完全看到这32个寄存器的状态，只能看到其中的一部分。 自动压栈处理：xPSR-&gt;PC-&gt;LR-&gt;r12-&gt;r3-&gt;r2-&gt;r1-&gt;r0 xPSP寄存器的 bit9被用来指示 SP是否需要对齐，bit9如果为1的话就需要双字对齐如果为0的话就不需要双字对齐 当触发了PendSV异常进入中断后，系统默认是出于MSP状态的。当切换任务时，就需要使用PSP作为任务堆栈指针。 一般使用修改LR寄存器的值来改变SP使用MSP还是PSP. LR &#x3D;0xFFFFFFF9 使用MSP堆栈指针 LR &#x3D;0xFFFFFFFD 使用PSP堆栈指针 所以一般PendSV中任务堆栈处理完毕后，需要使用LDR LR，&#x3D;0xFFFFFFFD指令进行PSP任务堆栈的选择。再执行BX LR 指令，即可切换到堆栈保存的任务中去 LR寄存器记录函数或子程序调用后的返回地址，若函数又调用了函数或子程序，为了保证LR值不丢失，需要将LR入栈.在异常处理时LR会被更新为特殊的EXC_RETURN数值。典型的有如下3种值： 0xFFFFFFF1 中断返回时从MSP恢复栈，返回之后操作模式为处理模式，使用MSP栈，即在中断嵌套情况下，返回上一级中断 0xFFFFFFF9 中断返回时从MSP恢复栈，返回之后操作模式为线程模式，使用MSP栈，该情况在只使用MSP不使用PSP时发生 0xFFFFFFFD 中断返回时从PSP恢复栈，返回之后操作模式为线程模式，使用PSP栈，即一般的从中断返回用户线程的情况 参考 GCC下daplink 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//hexdump logic on hardfault__USED __NO_RETURN void _fault_handler(uint32_t _lr)&#123; uint32_t stk_ptr; uint32_t * stack = (uint32_t *)__get_MSP(); if ((_lr &amp; 0xF) == 0xD) &#123; //process stack stack = (uint32_t *)__get_PSP(); &#125; //calculate stack ptr before fault stk_ptr = (uint32_t)stack + 0x20; if ((stack[7] &amp; 0x200) != 0) &#123; //xpsr bit 9 align stk_ptr += 0x4; &#125; if ((_lr &amp; 0x10) == 0) &#123; //fp stk_ptr += 0x48; &#125; config_ram_add_hexdump(_lr); //EXC_RETURN config_ram_add_hexdump(__get_PSP()); config_ram_add_hexdump(__get_MSP()); config_ram_add_hexdump(__get_CONTROL()); config_ram_add_hexdump(stk_ptr); //SP config_ram_add_hexdump(stack[5]); //LR config_ram_add_hexdump(stack[6]); //PC config_ram_add_hexdump(stack[7]); //xPSR#if !defined(__CORTEX_M)#error &quot;__CORTEX_M not defined!!&quot;#elif (__CORTEX_M &gt; 0x00) config_ram_add_hexdump(SCB-&gt;HFSR); config_ram_add_hexdump(SCB-&gt;CFSR); config_ram_add_hexdump(SCB-&gt;DFSR); config_ram_add_hexdump(SCB-&gt;AFSR); config_ram_add_hexdump(SCB-&gt;MMFAR); config_ram_add_hexdump(SCB-&gt;BFAR);#endif // __CORTEX_M util_assert(0); SystemReset(); while (1); // Wait for reset&#125;#if defined(__CC_ARM) // armccvoid HardFault_Handler()&#123; register unsigned int _lr __asm(&quot;lr&quot;); _fault_handler(_lr);&#125;#else // gcc and armclangvoid HardFault_Handler()&#123; __ASM volatile ( &quot; mov r0, lr \\n\\t&quot; &quot; bl _fault_handler \\n\\t&quot; );&#125;#endif 简易dump 1234567891011121314__USED __NO_RETURN void _fault_handler(uint32_t sp)&#123; printf(&quot;\\narm-none-eabi-addr2line -e _____.elf -a -f %08x\\n&quot;,((uint32_t *)sp)[6]);&#125;void HardFault_Handler(void)&#123; __ASM volatile ( &quot; mov r0,sp \\n\\t&quot; &quot; bl _fault_handler \\n\\t&quot; ); while(1) &#123; &#125;&#125; 其他信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define SCB_CFSR_MMFSR_IACCVIOL (0x01 &lt;&lt; 0)#define SCB_CFSR_MMFSR_DACCVIOL (0x01 &lt;&lt; 1)#define SCB_CFSR_MMFSR_MUNSTKERR (0x01 &lt;&lt; 3)#define SCB_CFSR_MMFSR_MSTKERR (0x01 &lt;&lt; 4)#define SCB_CFSR_MMFSR_MMARVALID (0x01 &lt;&lt; 7)#define SCB_CFSR_BFSR_IBUSERR (0x01 &lt;&lt; (0 + 8))#define SCB_CFSR_BFSR_PRECISERR (0x01 &lt;&lt; (1 + 8))#define SCB_CFSR_BFSR_IMPRECISERR (0x01 &lt;&lt; (2 + 8))#define SCB_CFSR_BFSR_UNSTKERR (0x01 &lt;&lt; (3 + 8))#define SCB_CFSR_BFSR_STKERR (0x01 &lt;&lt; (4 + 8))#define SCB_CFSR_BFSR_BFARVALID (0x01 &lt;&lt; (7 + 8))#define SCB_CFSR_UFSR_UNDEFINSTR (0x01 &lt;&lt; (0 + 16))#define SCB_CFSR_UFSR_INVSTATE (0x01 &lt;&lt; (1 + 16))#define SCB_CFSR_UFSR_INVPC (0x01 &lt;&lt; (2 + 16))#define SCB_CFSR_UFSR_NOCP (0x01 &lt;&lt; (3 + 16))#define SCB_CFSR_UFSR_UNALIGNED (0x01 &lt;&lt; (8 + 16))#define SCB_CFSR_UFSR_DIVBYZERO (0x01 &lt;&lt; (9 + 16))void FAULT_PrintFaultRegs(void)&#123; DBG_SendPolling(&quot;MMFSR : %x[%s%s%s%s%s]\\r\\n&quot;, SCB-&gt;CFSR &amp; SCB_CFSR_MEMFAULTSR_Msk, (0 == (SCB_CFSR_MMFSR_IACCVIOL &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;IACCVIOL|&quot;, (0 == (SCB_CFSR_MMFSR_DACCVIOL &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;DACCVIOL|&quot;, (0 == (SCB_CFSR_MMFSR_MUNSTKERR &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;MUNSTKERR|&quot;, (0 == (SCB_CFSR_MMFSR_MSTKERR &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;MSTKERR|&quot;, (0 == (SCB_CFSR_MMFSR_MMARVALID &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;MMARVALID|&quot;); DBG_SendPolling(&quot;BFSR : %x[%s%s%s%s%s%s]\\r\\n&quot;, SCB-&gt;CFSR &amp; SCB_CFSR_BUSFAULTSR_Msk, (0 == (SCB_CFSR_BFSR_IBUSERR &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;IBUSERR|&quot;, (0 == (SCB_CFSR_BFSR_PRECISERR &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;PRECISERR|&quot;, (0 == (SCB_CFSR_BFSR_IMPRECISERR &amp; SCB-&gt;CFSR))? &quot;&quot;:&quot;IMPRECISERR|&quot;, (0 == (SCB_CFSR_BFSR_UNSTKERR &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;UNSTKERR|&quot;, (0 == (SCB_CFSR_BFSR_STKERR &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;STKERR|&quot;, (0 == (SCB_CFSR_BFSR_BFARVALID &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;BFARVALID|&quot;); DBG_SendPolling(&quot;UFSR : %x[%s%s%s%s%s%s]\\r\\n&quot;, SCB-&gt;CFSR &amp; SCB_CFSR_USGFAULTSR_Msk, (0 == (SCB_CFSR_UFSR_UNDEFINSTR &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;UNDEFINSTR|&quot;, (0 == (SCB_CFSR_UFSR_INVSTATE &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;INVSTATE|&quot;, (0 == (SCB_CFSR_UFSR_INVPC &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;INVPC|&quot;, (0 == (SCB_CFSR_UFSR_NOCP &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;NOCP|&quot;, (0 == (SCB_CFSR_UFSR_UNALIGNED &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;UNALIGNED|&quot;, (0 == (SCB_CFSR_UFSR_DIVBYZERO &amp; SCB-&gt;CFSR)) ? &quot;&quot;:&quot;DIVBYZERO|&quot;); DBG_SendPolling(&quot;HFSR : %x[%s%s%s]\\r\\n&quot;, SCB-&gt;HFSR, (0 == (SCB_HFSR_DEBUGEVT_Msk &amp; SCB-&gt;HFSR)) ? &quot;&quot;:&quot;DEBUGEVT|&quot;, (0 == (SCB_HFSR_FORCED_Msk &amp; SCB-&gt;HFSR)) ? &quot;&quot;:&quot;FORCED|&quot;, (0 == (SCB_HFSR_VECTTBL_Msk &amp; SCB-&gt;HFSR)) ? &quot;&quot;:&quot;VECTTBL|&quot;); DBG_SendPolling(&quot;DFSR : %x\\r\\n&quot;, SCB-&gt;DFSR); DBG_SendPolling(&quot;MMFAR : %x\\r\\n&quot;, SCB-&gt;MMFAR); DBG_SendPolling(&quot;BFAR : %x\\r\\n&quot;, SCB-&gt;BFAR);&#125;","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"HardFault","slug":"stm32/HardFault","permalink":"http://example.com/categories/stm32/HardFault/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"HardFault","slug":"HardFault","permalink":"http://example.com/tags/HardFault/"}]},{"title":"HEX文件","slug":"stm32/hex","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.330Z","comments":true,"path":"2024/12/24/stm32/hex/","permalink":"http://example.com/2024/12/24/stm32/hex/","excerpt":"","text":"HEX文件以及特定位置写入stm32特定位置写入数据12const char __attribute__((section(&quot;.lua_script&quot;))) script[] = &#123;1,2,3,4,5,6&#125;;//数组名可以去掉 123456.lua_script 0x08003000 :&#123; . = ALIGN(4); KEEP(*(.lua_script)) . = ALIGN(4);&#125; &gt;FLASH 编译输出hex 123456789:082D5400434445460000000065:042D5C00F900000872:042D6000CD0000089A:083000000102030405060000B3:10300800AA550000000000000000000000000000B9:103018000000000000A24A04001000100010001078:043028000010001084:04000005080029893D:00000001FF :083000000102030405060000B3 由于链接文件多处使用”.”定位，链接器链接是按照SECTIONS里的段顺序排列的，前面的排列完之后就能计算出当前地址，私有部分最好自定义段位置，各个段不要超过地址限制如： 1234567FLASH_USR (rx) : ORIGIN = 0x8006000, LENGTH = 8K .lua_script 0x8007F00: &#123; . = ALIGN(4); KEEP(*(.lua_script)) . = ALIGN(4); &#125; &gt;FLASH_USR stm32特定位置写入函数123456.lua_script2 0x80F0100 :&#123; . = ALIGN(4); KEEP(*(.lua_script2)) . = ALIGN(4);&#125; &gt;FLASH_USR 运行函数，地址+1 1(*(void(*)())0x80F0100+1)(); 链接文件脚本说明 HEX文件 第一个字节0×02表示该行数据中有两个数据（字节） 第二个、第三个字节0x00 0x00表示本行数据的起始地址位 第四个字节有0x00 0x01 0x02 0x03 0x04 0x05，分别有以下含义 ‘00’ Data Rrecord: 用来记录数据，HEX文件的大部分记录都是数据记录 ‘01’ 文件结束记录： 用来标识文件结束，放在文件的最后，标识HEX文件的结尾 ‘02’ 扩展段地址记录： 用来标识扩展段地址的记录 ‘03’ 开始段地址记录： 开始段地址记录 ‘04’ 扩展线性地址记录： 用来标识扩展线性地址的记录 ‘05’ 开始线性地址记录： 开始线性地址记录 最后一个字节0xf8为校验和。校验和&#x3D; 0x100 - 累加和。在nodepad++中，如果该校验和不是绿色，则表示该校验和是错的。 注意，0×04标识扩展线性地址的记录，所以如020000040002f8中，拓展地址是0002。那么第二行数据的起始地址就是0002c000，即0x0002c000开始 HEX文件详解 其他KEIl编译stm32，堆栈使用超过设定便会溢出 GCC编译，根据链接文件排列各段，堆栈大小设置只起到判断大小是否超过RAM，对结果没有任何影响 ARM 之一 ELF文件、镜像（Image）文件、可执行文件、对象文件 详解 map文件可以看出Reset_Handler处开始运行，然后顺序进入函数Linker script and memory map可以看出__do_global_dtors_aux出自gcc中crtbegin.o bootloader合并1234567891011121314151617@echo offset BOOT_HEX=.\\boot.hexset APP_HEX=.\\app.hexset OUT_HEX=.\\out.hexset TEMP=.\\temp.txt:HEX_STEPset var=&quot;:00000001FF&quot;findstr /v %var% &quot;%IAP_HEX%&quot; &gt;&gt;%TEMP%del %OUT_HEX%type %TEMP% %APP_HEX% &gt;&gt; %OUT_HEX%del %TEMP% jlink 烧录bat依赖jlink.exe JLinkARM.dll 1jlink.exe config.txt config.txt 123456789si 1 // #选择swd接口 speed 4000 //设置速度device STM32F427IIr //重新复位目标h //挂起目标loadfile &quot;./out.hex&quot;setpc 0x08000000 //设置pc指针gq","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"hex","slug":"stm32/hex","permalink":"http://example.com/categories/stm32/hex/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"hex","slug":"hex","permalink":"http://example.com/tags/hex/"}]},{"title":"链接文件","slug":"stm32/ld","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.330Z","comments":true,"path":"2024/12/24/stm32/ld/","permalink":"http://example.com/2024/12/24/stm32/ld/","excerpt":"","text":"链接文件test.c编译放入特定位置 script12345678910.ccmram :&#123; . = ALIGN(4); _sccmram = .; /* create a global symbol at ccmram start */ *(.ccmram) *(.ccmram*) *test.o(*.bss* *.data*)/*编译的结果*/ . = ALIGN(4); _eccmram = .; /* create a global symbol at ccmram end */&#125; &gt;CCMRAM AT&gt; FLASH hardfault error确定使用的是那个堆栈，MSP或者是PSP，确定以后，在内存查看窗口，输入堆栈的地址，以这个地址开始的8个32位数值，应该依次是R0,R1,R2,R3,R12,R14,R15,XPSR的数值，据此判定你的堆栈地址是不是对的(有时需要考虑堆栈的增长方向)。R14，R15的地址就是我们出错的代码所在的地址，需要在这个地址基础上，首先偶数对齐，然后向上减去8个字节。 需要考虑的是，在使用MSP的时候，有出错的地方并不一定在R14，R15处，而是在XPSR往后的第二个地址处，在这个附近查找，排除故障。 12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 闪存装载软件STM32CubeProgrammer的闪存装载软件 IAR程序放入.bss段 12#pragma section=&quot;.bss&quot; openocd添加第三方设备 在.&#x2F;tcl&#x2F;target中,添加自己设备的.cfg文件,此文件用于编译后传递到scripts中供用户调用，此文件用于编译后传递到scripts中供用户调用 在.&#x2F;src&#x2F;flash&#x2F;nor中,添加自己设备的.c文件,此文件用于告知openocd你文件的flash烧录流程，此文件用于告知openocd你文件的flash烧录流程 在 &#x2F;src&#x2F;flash&#x2F;nor&#x2F;drivers.c中,添加自己设备的设备名,此处让openocd知晓你的设备，此处让openocd知晓你的设备. 在flash&#x2F;nor中,更改Makefile.am,令openocd的编译过程可以引用到你刚刚添加的文件.","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"}]},{"title":"mqtt","slug":"stm32/lwip mqtt","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:24:04.861Z","comments":true,"path":"2024/12/24/stm32/lwip mqtt/","permalink":"http://example.com/2024/12/24/stm32/lwip%20mqtt/","excerpt":"","text":"LWIP MQTT调试lwip以太网MQTT连接服务器，发现如果服务器不需要用户名和密码权限则可以正常连接MQTT服务器，并能够发布和订阅消息，但连接需要用户名和密码的服务器，则提示认证失败。 分析发现函数mqtt_client_connect没有处理client结构体中的用户名和密码字段 原函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147err_tmqtt_client_connect(mqtt_client_t *client, const ip_addr_t *ip_addr, u16_t port, mqtt_connection_cb_t cb, void *arg, const struct mqtt_connect_client_info_t *client_info)&#123; err_t err; size_t len; u16_t client_id_length; /* Length is the sum of 2+&quot;MQTT&quot;, protocol level, flags and keep alive */ u16_t remaining_length = 2 + 4 + 1 + 1 + 2; u8_t flags = 0, will_topic_len = 0, will_msg_len = 0; u16_t client_user_len = 0, client_pass_len = 0; LWIP_ASSERT_CORE_LOCKED(); LWIP_ASSERT(&quot;mqtt_client_connect: client != NULL&quot;, client != NULL); LWIP_ASSERT(&quot;mqtt_client_connect: ip_addr != NULL&quot;, ip_addr != NULL); LWIP_ASSERT(&quot;mqtt_client_connect: client_info != NULL&quot;, client_info != NULL); LWIP_ASSERT(&quot;mqtt_client_connect: client_info-&gt;client_id != NULL&quot;, client_info-&gt;client_id != NULL); if (client-&gt;conn_state != TCP_DISCONNECTED) &#123; LWIP_DEBUGF(MQTT_DEBUG_WARN, (&quot;mqtt_client_connect: Already connected\\n&quot;)); return ERR_ISCONN; &#125; /* Wipe clean */ memset(client, 0, sizeof(mqtt_client_t)); client-&gt;connect_arg = arg; client-&gt;connect_cb = cb; client-&gt;keep_alive = client_info-&gt;keep_alive; mqtt_init_requests(client-&gt;req_list, LWIP_ARRAYSIZE(client-&gt;req_list)); /* Build connect message */ if (client_info-&gt;will_topic != NULL &amp;&amp; client_info-&gt;will_msg != NULL) &#123; flags |= MQTT_CONNECT_FLAG_WILL; flags |= (client_info-&gt;will_qos &amp; 3) &lt;&lt; 3; if (client_info-&gt;will_retain) &#123; flags |= MQTT_CONNECT_FLAG_WILL_RETAIN; &#125; len = strlen(client_info-&gt;will_topic); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;will_topic length overflow&quot;, len &lt;= 0xFF, return ERR_VAL); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;will_topic length must be &gt; 0&quot;, len &gt; 0, return ERR_VAL); will_topic_len = (u8_t)len; len = strlen(client_info-&gt;will_msg); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;will_msg length overflow&quot;, len &lt;= 0xFF, return ERR_VAL); will_msg_len = (u8_t)len; len = remaining_length + 2 + will_topic_len + 2 + will_msg_len; LWIP_ERROR(&quot;mqtt_client_connect: remaining_length overflow&quot;, len &lt;= 0xFFFF, return ERR_VAL); remaining_length = (u16_t)len; &#125; if (client_info-&gt;client_user != NULL) &#123; flags |= MQTT_CONNECT_FLAG_USERNAME; len = strlen(client_info-&gt;client_user); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;client_user length overflow&quot;, len &lt;= 0xFFFF, return ERR_VAL); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;client_user length must be &gt; 0&quot;, len &gt; 0, return ERR_VAL); client_user_len = (u16_t)len; len = remaining_length + 2 + client_user_len; LWIP_ERROR(&quot;mqtt_client_connect: remaining_length overflow&quot;, len &lt;= 0xFFFF, return ERR_VAL); remaining_length = (u16_t)len; &#125; if (client_info-&gt;client_pass != NULL) &#123; flags |= MQTT_CONNECT_FLAG_PASSWORD; len = strlen(client_info-&gt;client_pass); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;client_pass length overflow&quot;, len &lt;= 0xFFFF, return ERR_VAL); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;client_pass length must be &gt; 0&quot;, len &gt; 0, return ERR_VAL); client_pass_len = (u16_t)len; len = remaining_length + 2 + client_pass_len; LWIP_ERROR(&quot;mqtt_client_connect: remaining_length overflow&quot;, len &lt;= 0xFFFF, return ERR_VAL); remaining_length = (u16_t)len; &#125; /* Don&#x27;t complicate things, always connect using clean session */ flags |= MQTT_CONNECT_FLAG_CLEAN_SESSION; len = strlen(client_info-&gt;client_id); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;client_id length overflow&quot;, len &lt;= 0xFFFF, return ERR_VAL); client_id_length = (u16_t)len; len = remaining_length + 2 + client_id_length; LWIP_ERROR(&quot;mqtt_client_connect: remaining_length overflow&quot;, len &lt;= 0xFFFF, return ERR_VAL); remaining_length = (u16_t)len; if (mqtt_output_check_space(&amp;client-&gt;output, remaining_length) == 0) &#123; return ERR_MEM; &#125;#if LWIP_ALTCP &amp;&amp; LWIP_ALTCP_TLS if (client_info-&gt;tls_config) &#123; client-&gt;conn = altcp_tls_new(client_info-&gt;tls_config, IP_GET_TYPE(ip_addr)); &#125; else#endif &#123; client-&gt;conn = altcp_tcp_new_ip_type(IP_GET_TYPE(ip_addr)); &#125; if (client-&gt;conn == NULL) &#123; return ERR_MEM; &#125; /* Set arg pointer for callbacks */ altcp_arg(client-&gt;conn, client); /* Any local address, pick random local port number */ err = altcp_bind(client-&gt;conn, IP_ADDR_ANY, 0); if (err != ERR_OK) &#123; LWIP_DEBUGF(MQTT_DEBUG_WARN, (&quot;mqtt_client_connect: Error binding to local ip/port, %d\\n&quot;, err)); goto tcp_fail; &#125; LWIP_DEBUGF(MQTT_DEBUG_TRACE, (&quot;mqtt_client_connect: Connecting to host: %s at port:%&quot;U16_F&quot;\\n&quot;, ipaddr_ntoa(ip_addr), port)); /* Connect to server */ err = altcp_connect(client-&gt;conn, ip_addr, port, mqtt_tcp_connect_cb); if (err != ERR_OK) &#123; LWIP_DEBUGF(MQTT_DEBUG_TRACE, (&quot;mqtt_client_connect: Error connecting to remote ip/port, %d\\n&quot;, err)); goto tcp_fail; &#125; /* Set error callback */ altcp_err(client-&gt;conn, mqtt_tcp_err_cb); client-&gt;conn_state = TCP_CONNECTING; /* Append fixed header */ mqtt_output_append_fixed_header(&amp;client-&gt;output, MQTT_MSG_TYPE_CONNECT, 0, 0, 0, remaining_length); /* Append Protocol string */ mqtt_output_append_string(&amp;client-&gt;output, &quot;MQTT&quot;, 4); /* Append Protocol level */ mqtt_output_append_u8(&amp;client-&gt;output, 4); /* Append connect flags */ mqtt_output_append_u8(&amp;client-&gt;output, flags); /* Append keep-alive */ mqtt_output_append_u16(&amp;client-&gt;output, client_info-&gt;keep_alive); /* Append client id */ mqtt_output_append_string(&amp;client-&gt;output, client_info-&gt;client_id, client_id_length); /* Append will message if used */ if ((flags &amp; MQTT_CONNECT_FLAG_WILL) != 0) &#123; mqtt_output_append_string(&amp;client-&gt;output, client_info-&gt;will_topic, will_topic_len); mqtt_output_append_string(&amp;client-&gt;output, client_info-&gt;will_msg, will_msg_len); &#125; /* Append user name if given */ if ((flags &amp; MQTT_CONNECT_FLAG_USERNAME) != 0) &#123; mqtt_output_append_string(&amp;client-&gt;output, client_info-&gt;client_user, client_user_len); &#125; /* Append password if given */ if ((flags &amp; MQTT_CONNECT_FLAG_PASSWORD) != 0) &#123; mqtt_output_append_string(&amp;client-&gt;output, client_info-&gt;client_pass, client_pass_len); &#125; return ERR_OK;tcp_fail: altcp_abort(client-&gt;conn); client-&gt;conn = NULL; return err;&#125; 修改后123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132err_tmqtt_client_connect(mqtt_client_t *client, const ip_addr_t *ip_addr, u16_t port, mqtt_connection_cb_t cb, void *arg, const struct mqtt_connect_client_info_t *client_info)&#123; err_t err; size_t len; u16_t client_id_length; /* Length is the sum of 2+&quot;MQTT&quot;, protocol level, flags and keep alive */ u16_t remaining_length = 2 + 4 + 1 + 1 + 2; u8_t flags = 0, will_topic_len = 0, will_msg_len = 0; LWIP_ASSERT(&quot;mqtt_client_connect: client != NULL&quot;, client != NULL); LWIP_ASSERT(&quot;mqtt_client_connect: ip_addr != NULL&quot;, ip_addr != NULL); LWIP_ASSERT(&quot;mqtt_client_connect: client_info != NULL&quot;, client_info != NULL); LWIP_ASSERT(&quot;mqtt_client_connect: client_info-&gt;client_id != NULL&quot;, client_info-&gt;client_id != NULL); if (client-&gt;conn_state != TCP_DISCONNECTED) &#123; LWIP_DEBUGF(MQTT_DEBUG_WARN,(&quot;mqtt_client_connect: Already connected\\n&quot;)); return ERR_ISCONN; &#125; /* Wipe clean */ memset(client, 0, sizeof(mqtt_client_t)); client-&gt;connect_arg = arg; client-&gt;connect_cb = cb; client-&gt;keep_alive = client_info-&gt;keep_alive; mqtt_init_requests(client-&gt;req_list); /* Build connect message */ if (client_info-&gt;will_topic != NULL &amp;&amp; client_info-&gt;will_msg != NULL) &#123; flags |= MQTT_CONNECT_FLAG_WILL; flags |= (client_info-&gt;will_qos &amp; 3) &lt;&lt; 3; if (client_info-&gt;will_retain) &#123; flags |= MQTT_CONNECT_FLAG_WILL_RETAIN; &#125; len = strlen(client_info-&gt;will_topic); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;will_topic length overflow&quot;, len &lt;= 0xFF, return ERR_VAL); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;will_topic length must be &gt; 0&quot;, len &gt; 0, return ERR_VAL); will_topic_len = (u8_t)len; len = strlen(client_info-&gt;will_msg); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;will_msg length overflow&quot;, len &lt;= 0xFF, return ERR_VAL); will_msg_len = (u8_t)len; len = remaining_length + 2 + will_topic_len + 2 + will_msg_len; LWIP_ERROR(&quot;mqtt_client_connect: remaining_length overflow&quot;, len &lt;= 0xFFFF, return ERR_VAL); remaining_length = (u16_t)len; &#125; /* Don&#x27;t complicate things, always connect using clean session */ flags |= MQTT_CONNECT_FLAG_CLEAN_SESSION; len = strlen(client_info-&gt;client_id); LWIP_ERROR(&quot;mqtt_client_connect: client_info-&gt;client_id length overflow&quot;, len &lt;= 0xFFFF, return ERR_VAL); client_id_length = (u16_t)len; len = remaining_length + 2 + client_id_length; LWIP_ERROR(&quot;mqtt_client_connect: remaining_length overflow&quot;, len &lt;= 0xFFFF, return ERR_VAL); //------------------------------------------------------------------------------------------------------------------------------- if(client_info-&gt;client_user!=NULL) &#123; flags |= MQTT_CONNECT_FLAG_USERNAME; len+=2 + strlen(client_info-&gt;client_user); &#125; if(client_info-&gt;client_pass!=NULL) &#123; flags |= MQTT_CONNECT_FLAG_PASSWORD; len+=2 + strlen(client_info-&gt;client_pass); &#125;//------------------------------------------------------------------------------------------------------------------------------- remaining_length = (u16_t)len; if (mqtt_output_check_space(&amp;client-&gt;output, remaining_length) == 0) &#123; return ERR_MEM; &#125; client-&gt;conn = tcp_new(); if (client-&gt;conn == NULL) &#123; return ERR_MEM; &#125; /* Set arg pointer for callbacks */ tcp_arg(client-&gt;conn, client); /* Any local address, pick random local port number */ err = tcp_bind(client-&gt;conn, IP_ADDR_ANY, 0); if (err != ERR_OK) &#123; LWIP_DEBUGF(MQTT_DEBUG_WARN,(&quot;mqtt_client_connect: Error binding to local ip/port, %d\\n&quot;, err)); goto tcp_fail; &#125; LWIP_DEBUGF(MQTT_DEBUG_TRACE,(&quot;mqtt_client_connect: Connecting to host: %s at port:%&quot;U16_F&quot;\\n&quot;, ipaddr_ntoa(ip_addr), port)); /* Connect to server */ err = tcp_connect(client-&gt;conn, ip_addr, port, mqtt_tcp_connect_cb); if (err != ERR_OK) &#123; LWIP_DEBUGF(MQTT_DEBUG_TRACE,(&quot;mqtt_client_connect: Error connecting to remote ip/port, %d\\n&quot;, err)); goto tcp_fail; &#125; /* Set error callback */ tcp_err(client-&gt;conn, mqtt_tcp_err_cb); client-&gt;conn_state = TCP_CONNECTING; /* Append fixed header */ mqtt_output_append_fixed_header(&amp;client-&gt;output, MQTT_MSG_TYPE_CONNECT, 0, 0, 0, remaining_length); /* Append Protocol string */ mqtt_output_append_string(&amp;client-&gt;output, &quot;MQTT&quot;, 4); /* Append Protocol level */ mqtt_output_append_u8(&amp;client-&gt;output, 4); /* Append connect flags */ mqtt_output_append_u8(&amp;client-&gt;output, flags); /* Append keep-alive */ mqtt_output_append_u16(&amp;client-&gt;output, client_info-&gt;keep_alive); /* Append client id */ mqtt_output_append_string(&amp;client-&gt;output, client_info-&gt;client_id, client_id_length); /* Append will message if used */ if ((flags &amp; MQTT_CONNECT_FLAG_WILL) != 0) &#123; mqtt_output_append_string(&amp;client-&gt;output, client_info-&gt;will_topic, will_topic_len); mqtt_output_append_string(&amp;client-&gt;output, client_info-&gt;will_msg, will_msg_len); &#125;//------------------------------------------------------------------------------------------------------------------------------- if((flags &amp; MQTT_CONNECT_FLAG_USERNAME) != 0) &#123; mqtt_output_append_string(&amp;client-&gt;output, client_info-&gt;client_user, strlen(client_info-&gt;client_user)); &#125; if((flags &amp; MQTT_CONNECT_FLAG_PASSWORD) != 0) &#123; mqtt_output_append_string(&amp;client-&gt;output, client_info-&gt;client_pass, strlen(client_info-&gt;client_pass)); &#125;//------------------------------------------------------------------------------------------------------------------------------- return ERR_OK;tcp_fail: tcp_abort(client-&gt;conn); client-&gt;conn = NULL; return err;&#125; 2.02以后的版本已经修复这个bug","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"mqtt","slug":"stm32/mqtt","permalink":"http://example.com/categories/stm32/mqtt/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"lwip","slug":"lwip","permalink":"http://example.com/tags/lwip/"},{"name":"mqtt","slug":"mqtt","permalink":"http://example.com/tags/mqtt/"}]},{"title":"lwip宏","slug":"stm32/lwip","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:22:54.679Z","comments":true,"path":"2024/12/24/stm32/lwip/","permalink":"http://example.com/2024/12/24/stm32/lwip/","excerpt":"","text":"lwip宏定义 TCPIP_THREAD_PRIO: 定义了lwIP协议栈中的TCP&#x2F;IP线程的优先级。可以根据系统需求进行调整。例如，如果系统中有其他高优先级任务，可以将该值设置为较低的优先级，以确保系统的稳定性。 DEFAULT_THREAD_PRIO: 定义了默认线程的优先级。同样，可以根据系统需求进行调整。 SYS_LIGHTWEIGHT_PROT: 定义了系统是否启用轻量级保护机制。如果启用，将使用更轻量级的保护机制来保护共享资源，以提高系统性能。 NO_SYS: 定义了是否禁用操作系统功能。如果设置为1，将禁用操作系统功能，lwIP将在裸机环境下运行。 MEM_ALIGNMENT: 定义了内存对齐方式。可以根据硬件平台的要求进行调整。 MEM_SIZE: 定义了lwIP协议栈使用的内存大小。可以根据系统需求进行调整。例如，如果系统内存较小，可以减小该值以节省内存空间。 MEMP_NUM_PBUF: 定义了可用的pbuf（数据包缓冲区）数量。可以根据系统的网络负载进行调整。例如，如果系统需要处理大量的网络数据包，可以增加该值以提高性能。 MEMP_NUM_UDP_PCB: 定义了可用的UDP协议控制块（PCB）数量。可以根据系统的UDP连接数进行调整。 MEMP_NUM_TCP_PCB: 定义了可用的TCP协议控制块（PCB）数量。可以根据系统的TCP连接数进行调整。 MEMP_NUM_TCP_PCB_LISTEN: 定义了可用的TCP监听协议控制块（PCB）数量。可以根据系统的TCP监听连接数进行调整。 MEMP_NUM_TCP_SEG: 定义了可用的TCP分段数量。可以根据系统的TCP连接数和数据传输需求进行调整。 MEMP_NUM_SYS_TIMEOUT: 定义了可用的系统超时数量。可以根据系统的需求进行调整。 MEMP_NUM_NETCONN: 定义了可用的网络连接数量。可以根据系统的网络连接需求进行调整。 PBUF_POOL_SIZE: 定义了pbuf（数据包缓冲区）池的大小。可以根据系统的网络负载进行调整。 PBUF_POOL_BUFSIZE: 定义了pbuf（数据包缓冲区）的大小。可以根据系统的网络负载和数据包大小进行调整。 LWIP_SUPPORT_CUSTOM_PBUF: 定义了是否支持自定义pbuf（数据包缓冲区）。如果设置为1，可以使用自定义的pbuf实现，以满足特定的需求。 LWIP_TCP: 定义了是否启用TCP协议。如果设置为1，将启用TCP协议。 TCP_TTL: 定义了TCP数据包的生存时间（TTL）。 TCP_QUEUE_OOSEQ: 定义了是否启用TCP乱序队列。如果设置为1，将启用TCP乱序队列。 TCPIP_MBOX_SIZE: 定义了TCP&#x2F;IP线程的邮箱大小。可以根据系统的需求进行调整。 DEFAULT_TCP_RECVMBOX_SIZE: 定义了TCP接收邮箱的大小。可以根据系统的需求进行调整。 DEFAULT_ACCEPTMBOX_SIZE: 定义了TCP连接接受邮箱的大小。可以根据系统的需求进行调整。 TCP_MSS: 定义了TCP最大段大小（Maximum Segment Size）。可以根据网络环境和带宽进行调整。 TCP_SND_BUF: 定义了TCP发送缓冲区的大小。可以根据系统的需求和网络带宽进行调整。 TCP_SND_QUEUELEN: 定义了TCP发送队列的长度。可以根据系统的需求和网络带宽进行调整。 TCP_WND: 定义了TCP窗口大小。可以根据网络环境和带宽进行调整。 LWIP_ICMP: 定义了是否启用ICMP协议。如果设置为1，将启用ICMP协议。 LWIP_DHCP: 定义了是否启用DHCP协议。如果设置为1，将启用DHCP协议。 LWIP_UDP: 定义了是否启用UDP协议。如果设置为1，将启用UDP协议。 UDP_TTL: 定义了UDP数据包的生存时间（TTL）。 LWIP_STATS: 定义了是否启用lwIP统计功能。如果设置为1，将启用lwIP的统计功能。 LWIP_PROVIDE_ERRNO: 定义了是否提供errno变量。如果设置为1，将提供errno变量。 CHECKSUM_BY_HARDWARE: 定义了是否使用硬件加速计算校验和。如果定义了该宏，将使用硬件加速计算校验和。 CHECKSUM_GEN_IP, CHECKSUM_GEN_UDP, CHECKSUM_GEN_TCP, CHECKSUM_CHECK_IP, CHECKSUM_CHECK_UDP, CHECKSUM_CHECK_TCP, CHECKSUM_GEN_ICMP: 这些宏定义了是否生成和检查IP、UDP、TCP和ICMP数据包的校验和。根据系统的硬件和性能需求进行调整。 LWIP_NETCONN: 定义了是否启用lwIP的netconn API。如果设置为1，将启用lwIP的netconn API。 LWIP_SOCKET: 定义了是否启用lwIP的socket API。如果设置为1，将启用lwIP的socket API。 LWIP_COMPAT_MUTEX: 定义了是否启用lwIP的互斥锁兼容模式。如果设置为1，将启用lwIP的互斥锁兼容模式。 LWIP_SO_RCVTIMEO: 定义了是否启用lwIP的接收超时功能。如果设置为1，将启用lwIP的接收超时功能。 TCPIP_THREAD_STACKSIZE: 定义了TCP&#x2F;IP线程的堆栈大小。可以根据系统的需求进行调整。 DEFAULT_UDP_RECVMBOX_SIZE: 定义了UDP接收邮箱的大小。可以根据系统的需求进行调整。 DEFAULT_THREAD_STACKSIZE: 定义了默认线程的堆栈大小。可以根据系统的需求进行调整。 LWIP_TCP_KEEPALIVE, TCP_KEEPIDLE_DEFAULT, TCP_KEEPINTVL_DEFAULT, TCP_KEEPCNT_DEFAULT, TCP_MAXIDLE: 这些宏定义了TCP保持连接的相关参数。可以根据系统的需求进行调整。 LWIP_DEBUG: 定义了是否启用lwIP的调试功能。如果设置为1，将启用lwIP的调试功能。 ICMP_DEBUG: 定义了ICMP调试的级别。可以根据系统的需求进行调整。 LWIP_NETIF_LOOPBACK: 定义了是否启用lwIP的回环接口。如果设置为1，将启用lwIP的回环接口。 LWIP_LOOPBACK_MAX_PBUFS: 定义了回环接口的最大pbuf（数据包缓冲区）数量。可以根据系统的需求进行调整。 这些宏定义可以根据具体的系统需求进行优化配置。例如，如果系统需要处理大量的TCP连接，可以增加MEMP_NUM_TCP_PCB和MEMP_NUM_TCP_PCB_LISTEN的值。如果系统内存较小，可以减小MEM_SIZE的值。如果系统需要支持更多的UDP连接，可以增加MEMP_NUM_UDP_PCB的值。通过调整这些宏定义的值，可以根据系统的需求和硬件资源进行优化配置，以提高系统性能和资源利用率。 lwIP核心业务逻辑 lwip 文件生成 1234567891011TARGET=makefsdataC_INCLUDES = \\-I../../../include/ \\-I../../../../test/unit/#需要添加contrib下ports\\unix\\port\\include\\arch\\cc.hall: gcc $(C_INCLUDES) -o $(TARGET).exe makefsdata.cclean: -rm $(TARGET).exe","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"lwip","slug":"stm32/lwip","permalink":"http://example.com/categories/stm32/lwip/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"lwip","slug":"lwip","permalink":"http://example.com/tags/lwip/"}]},{"title":"Makefile","slug":"stm32/makefile","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:37:11.083Z","comments":true,"path":"2024/12/24/stm32/makefile/","permalink":"http://example.com/2024/12/24/stm32/makefile/","excerpt":"","text":"Makefilekeil 缺点： 编译较大项目麻烦，添加文件和包含路径不方便，不易理解编译和调试的原理 语法上可以加GNUC规则，但是并不全 对于添加软件包等也较复杂 优点： 编译快 优化好，编译文件体积小 仿真方便 尽量选gcc + makefile方式，如果工程庞大，可选gcc + cmake 语法参考 生成部分建文件夹12345678910OBJECTS += $(addprefix $(BUILD_DIR)/,$(ASM_SOURCES:.s=.o))vpath %.s $(sort $(dir $(ASM_SOURCES)))$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) @mkdir -p $(dir $@) $(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(&lt;:.c=.lst) $&lt; -o $@ @mkdir -p $(dir $(BUILD_DIR)/$&lt;) # $(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(&lt;:.c=.lst) $&lt; -o $(BUILD_DIR)/$(&lt;:.c=.o) 通配符 12C_SOURCES = \\$(wildcard Template/*.c) \\ 排除 1C_SOURCES := $(filter-out APP/glyc.c, $(C_SOURCES)) 反汇编 12$(TARGET_ASM): $(TARGET_AXF) arm-none-eabi-objdump -d $&lt; &gt; $@ 生成库 1ar -rc lib.a 1.o 2.o ... 条件 123456OS = 1ifeq ($(OS),1)###else###endif 关键字 123addprefix加前缀wildcard通配filter-out排除 增加用量显示 1-Wl,--print-memory-usage 命令合并 其他 12345678910111213141516171819202122232425262728all clean ocd_flash ocd_flash_softdevice: make -C $(DIR) $@openocd: openocd -f interface/ADAPTER.cfg -f board/MYBOARD.cfg# makefile添加debug: openocd -f openocd.cfg &amp; &quot;C:\\Program Files (x86)\\GNU Arm Embedded Toolchain\\9 2020-q2-update\\bin/arm-none-eabi-gdb&quot; ./_build/$(TARGETS).out -ex &quot;target remote localhost:3333&quot; exit: @taskkill -f -im openocd.exedownload: @echo &quot;h&quot; &gt; jlink.cfg @echo &quot;loadfile&quot; $(BUILD)/$(TARGET).hex &gt;&gt; jlink.cfg @echo &quot;r&quot; &gt;&gt; jlink.cfg @echo &quot;qc&quot; &gt;&gt; jlink.cfg @$(JLINKEXE) -device $(CHIP) -Speed 4000 -IF SWD -CommanderScript jlink.cfg @$(RM) jlink.cfg#系统判断：ifeq ($(OS),Windows_NT) RM = rmdir /s /qelse RM = rm -rfendif F303discovery123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247########################################################################################################################### File automatically-generated by tool: [projectgenerator] version: [3.11.2] date: [Fri Dec 03 14:33:59 CST 2021]########################################################################################################################### ------------------------------------------------# Generic Makefile (based on gcc)## ChangeLog :# 2017-02-10 - Several enhancements + project update mode# 2015-07-22 - first version# ------------------------------------------------####################################### target######################################TARGET = F303####################################### building variables####################################### debug build?DEBUG = 1# optimizationOPT = -Og######################################## paths######################################## Build pathBUILD_DIR = build####################################### source####################################### C sourcesC_SOURCES = \\startup_stm32.c \\Core/Src/main.c \\Core/Src/gpio.c \\Core/Src/i2c.c \\Core/Src/spi.c \\Core/Src/usb.c \\Core/Src/usart.c \\Core/Src/stm32f3xx_it.c \\Core/Src/stm32f3xx_hal_msp.c \\Core/Src/system_stm32f3xx.c \\STM32F3-Discovery/stm32f3_discovery.c \\STM32F3-Discovery/stm32f3_discovery_gyroscope.c \\STM32F3-Discovery/stm32f3_discovery_accelerometer.c# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_ll_usb.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_i2c.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_i2c_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_rcc.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_rcc_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_gpio.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_dma.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_cortex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pwr.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pwr_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_flash.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_flash_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_exti.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_spi.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_spi_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_tim.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_tim_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_uart.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_uart_ex.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c \\# Drivers/STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd_ex.cC_SOURCES+=$(wildcard components/commmon/*.c) \\$(wildcard components/i3g4250d/*.c) \\$(wildcard components/l3gd20/*.c) \\$(wildcard components/lsm303agr/*.c) \\$(wildcard components/lsm303dlhc/*.c) \\$(wildcard imu/*.c)# ASM sourcesASM_SOURCES = \\# startup_stm32f303xc.s######################################## binaries#######################################PREFIX = arm-none-eabi-# The gcc compiler bin path can be either defined in make command via GCC_PATH variable (&gt; make GCC_PATH=xxx)# either it can be added to the PATH environment variable.GCC_PATH = &quot;C:\\Program Files (x86)\\GNU Arm Embedded Toolchain\\9 2020-q2-update\\bin&quot;ifdef GCC_PATHCC = $(GCC_PATH)/$(PREFIX)gccAS = $(GCC_PATH)/$(PREFIX)gcc -x assembler-with-cppCP = $(GCC_PATH)/$(PREFIX)objcopySZ = $(GCC_PATH)/$(PREFIX)sizeAR = $(GCC_PATH)/$(PREFIX)arMP = $(GCC_PATH)/$(PREFIX)objdumpelseCC = $(PREFIX)gccAS = $(PREFIX)gcc -x assembler-with-cppCP = $(PREFIX)objcopySZ = $(PREFIX)sizeAR = $(PREFIX)arendifHEX = $(CP) -O ihexBIN = $(CP) -O binary -S ######################################## CFLAGS######################################## cpuCPU = -mcpu=cortex-m4# fpuFPU = -mfpu=fpv4-sp-d16# float-abiFLOAT-ABI = -mfloat-abi=hard# mcuMCU = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)# macros for gcc# AS definesAS_DEFS = # C definesC_DEFS = \\-DUSE_HAL_DRIVER \\-DSTM32F303xC# AS includesAS_INCLUDES = # C includesC_INCLUDES = \\-ICore/Inc \\-IDrivers/STM32F3xx_HAL_Driver/Inc \\-IDrivers/STM32F3xx_HAL_Driver/Inc/Legacy \\-IDrivers/CMSIS/Device/ST/STM32F3xx/Include \\-IDrivers/CMSIS/Include \\-ISTM32F3-Discovery \\-Icomponents/l3gd20 \\-Icomponents/lsm303agr \\-Icomponents/lsm303dlhc \\-Icomponents/i3g4250d \\-Iimu# compile gcc flagsASFLAGS = $(MCU) $(AS_DEFS) $(AS_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sectionsCFLAGS = $(MCU) $(C_DEFS) $(C_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sectionsifeq ($(DEBUG), 1)CFLAGS += -g -gdwarf-2endif# Generate dependency informationCFLAGS += -MMD -MP -MF&quot;$(@:%.o=%.d)&quot;######################################## LDFLAGS######################################## link scriptLDSCRIPT = STM32F303VCTx_FLASH.ld# librariesLIBS = -lc -lm -lnosys LIBS += Drivers/STM32F303VCTx.libLIBDIR =LDFLAGS = $(MCU) -specs=nano.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections# default action: build allall: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).binDrivers/STM32F303VCTx.lib: lib######################################## build the application######################################## list of objectsOBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(C_SOURCES:.c=.o)))vpath %.c $(sort $(dir $(C_SOURCES)))# list of ASM program objectsOBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES:.s=.o)))vpath %.s $(sort $(dir $(ASM_SOURCES)))$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) $(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(&lt;:.c=.lst)) $&lt; -o $@$(BUILD_DIR)/%.o: %.s Makefile | $(BUILD_DIR) $(AS) -c $(CFLAGS) $&lt; -o $@$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile $(CC) $(OBJECTS) $(LDFLAGS) -o $@ $(SZ) $@$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR) $(HEX) $&lt; $@ $(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR) $(BIN) $&lt; $@ $(BUILD_DIR): mkdir $@ ######################################## clean up#######################################clean: -rm -fR $(BUILD_DIR) ocd_flash: $(BUILD_DIR)/$(TARGET).hex openocd -f openocd.cfg -c &quot;program $^ verify reset exit&quot;debug: openocd -f openocd.cfg &amp; &quot;C:\\Program Files (x86)\\GNU Arm Embedded Toolchain\\9 2020-q2-update\\bin/arm-none-eabi-gdb&quot; $(BUILD_DIR)/$(TARGET).elf -ex &quot;target remote localhost:3333&quot; exit: @taskkill -f -im openocd.exedump: $(MP) -d $(BUILD_DIR)/$(TARGET).elf &gt; dump.txtexport CFLAGS CC AR BUILD_DIRlib libclean: make -C Drivers $@ ######################################## dependencies#######################################-include $(wildcard $(BUILD_DIR)/*.d)# *** EOF *** Drivers&#x2F;makefile1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#$(wildcard STM32F3xx_HAL_Driver/Src/*.c)LIB_SOURCES+= \\STM32F3xx_HAL_Driver/Src/stm32f3xx_ll_usb.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_i2c.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_i2c_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_rcc.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_rcc_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_gpio.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_dma.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_cortex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pwr.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pwr_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_flash.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_flash_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_exti.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_spi.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_spi_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_tim.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_tim_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_uart.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_uart_ex.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd.c \\STM32F3xx_HAL_Driver/Src/stm32f3xx_hal_pcd_ex.cC_INCLUDES = \\-I../Core/Inc \\-ISTM32F3xx_HAL_Driver/Inc \\-ISTM32F3xx_HAL_Driver/Inc/Legacy \\-ICMSIS/Device/ST/STM32F3xx/Include \\-ICMSIS/Include OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(LIB_SOURCES:.c=.o)))vpath %.c $(sort $(dir $(LIB_SOURCES)))# list of ASM program objects$(BUILD_DIR)/%.o: %.c $(BUILD_DIR) @$(CC) -c $(CFLAGS) $(C_INCLUDES) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(&lt;:.c=.lst)) $&lt; -o $@ @echo &quot;Compiled &quot;$&lt;&quot;\\n&quot;$(BUILD_DIR): mkdir $@ HALLIB = STM32F303VCTx.liblib: $(HALLIB)$(HALLIB):$(BUILD_DIR) $(OBJECTS) $(AR) -r $@ $(OBJECTS) libclean: rm -rf $(BUILD_DIR) rm STM32F303VCTx.lib 其他操作，打印输出输出颜色，显示命令，帮助123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150C_SRCS := C_OBJS := $(patsubst %.c,$(OBJ_FOLDER)%.o,$(notdir $(C_SRCS)))CPP_SRCS := CPP_OBJS := $(patsubst %.cpp,$(OBJ_FOLDER)%.o,$(notdir $(CPP_SRCS)))S_SRCS := S_OBJS = $(patsubst %.s,$(OBJ_FOLDER)%.o,$(filter %.s,$(notdir $(S_SRCS))))S_OBJS += $(patsubst %.S,$(OBJ_FOLDER)%.o,$(filter %.S,$(notdir $(S_SRCS))))#-------------------------------------------------------------------------------# Logging options#-------------------------------------------------------------------------------# Enable color output by default.USE_COLOR ?= 1# Normally, commands in recipes are prefixed with &#x27;@&#x27; so the command itself# is not echoed by make. But if VERBOSE is defined (set to anything non-empty),# then the &#x27;@&#x27; is removed from recipes. The &#x27;at&#x27; variable is used to control# this.ifeq &quot;$(VERBOSE)&quot; &quot;1&quot;at :=elseat := @endif# These colors must be printed with the printf command. echo won&#x27;t handle the# escape sequences.color_default = \\033[00mcolor_bold = \\033[01mcolor_red = \\033[31mcolor_green = \\033[32mcolor_yellow = \\033[33mcolor_blue = \\033[34mcolor_magenta = \\033[35mcolor_cyan = \\033[36mcolor_orange = \\033[38;5;172mcolor_light_blue = \\033[38;5;039mcolor_gray = \\033[38;5;008mcolor_purple = \\033[38;5;097mifeq &quot;$(USE_COLOR)&quot; &quot;1&quot;color_build := $(color_light_blue)color_c := $(color_green)color_cxx := $(color_green)color_cpp := $(color_orange)color_asm := $(color_magenta)color_ar := $(color_yellow)color_link := $(color_cyan)color_convert := $(color_gray)endif# Used in printmessage if the color args are not present.color_ :=# Use in recipes to print color messages if printing to a terminal. If# USE_COLOR is not set to 1, this reverts to a simple uncolorized printf.# A newline is added to the end of the printed message.## Arguments:# 1 - name of the color variable (see above), minus the &quot;color_&quot; prefix# 2 - first colorized part of the message# 3 - first uncolorized part of the message# 4 - color name for second colorized message# 5 - second colorized message# 6 - second uncolorized part of the message# 7 - uncolorized prefix on the whole line; this is last because it is expected to be used rarely## All arguments are optional.## Use like:# $(call printmessage,cyan,Building, remainder of the message...)ifeq &quot;$(USE_COLOR)&quot; &quot;1&quot;define printmessageif [ -t 1 ]; then printf &quot;$(7)$(color_$(1))$(2)$(color_default)$(3)$(color_$(4))$(5)$(color_default)$(6)\\n&quot; ; \\else printf &quot;$(7)$(2)$(3)$(5)$(6)\\n&quot; ; fiendefelsedefine printmessageprintf &quot;$(7)$(2)$(3)$(5)$(6)\\n&quot;endefendif#-------------------------------------------------------------------------------# Recipes#-------------------------------------------------------------------------------# Compile C sources.$(OBJ_FOLDER)%.o : %.c @$(call printmessage,c,Compiling, $&lt;) $(at)$(CC) $(CFLAGS) $(COMMON_FLAGS) $&lt; -o $@# Compile C++ sources.$(OBJ_FOLDER)%.o : %.cpp @$(call printmessage,cxx,Compiling, $&lt;) $(at)$(CXX) $(CXXFLAGS) $(COMMON_FLAGS) $&lt; -o $@# Preprocess and assemble .S sources.$(OBJ_FOLDER)%.o : %.S @$(call printmessage,asm,Assembling, $&lt;) $(at)$(AS) $(ASFLAGS) $(COMMON_FLAGS) $&lt; -o $@# Assemble .s sources.$(OBJ_FOLDER)%.o : %.s @$(call printmessage,asm,Assembling, $&lt;) $(at)$(AS) $(ASFLAGS) $(COMMON_FLAGS) $&lt; -o $@$(OUT_DIR):ifeq ($(OS),Windows_NT) $(at)-mkdir $(OUT_DIR)else $(at)$(shell mkdir $(OBJ_FOLDER) 2&gt;/dev/null)endif# Tool invocations$(LD_SCRIPT): $(LD_SCRIPT_IN) @$(call printmessage,cpp,Preprocessing, $&lt;) $(at)$(CPP) $(CPP_FLAGS) $(LD_CPP_FLAGS) $(INC_DIRS_F) $(CC_SYMBOLS) -MMD $&lt; -o $@$(TARGET_OUT): $(LD_SCRIPT) $(C_OBJS) $(CPP_OBJS) $(S_OBJS) @$(call printmessage,link,Linking, $@) $(at)$(LD) $(LIB_PATHS) -o $@ $(CPP_OBJS) $(C_OBJS) $(S_OBJS) $(O_OBJS) $(LIBS) $(LD_OPTIONS) $(at)$(SIZE) --totals $(TARGET_OUT) $(at)-$(NM) $(NMFLAGS) $(TARGET_OUT) &gt; $(OBJ_FOLDER)$(TARGET)-symbol-table.txt$(TARGET_HEX): $(TARGET_OUT) @$(call printmessage,convert,Converting, $@) $(at)@$(OBJCOPY) -O ihex $(TARGET_OUT) $(TARGET_HEX)$(TARGET_BIN): $(TARGET_OUT) @$(call printmessage,convert,Converting, $@) $(at)@$(OBJCOPY) -O binary $(TARGET_OUT) $(TARGET_BIN)help: @echo &quot;Useful targets:&quot; @echo &quot; - all (default)&quot; @echo &quot; - clean&quot; @echo &quot; - help&quot; @echo @echo &quot;Options:&quot; @echo &quot; - VERBOSE=&#123;0|1&#125; to show full command lines.&quot; @echo &quot; - USE_COLOR=&#123;0|1&#125; to override color output.&quot;","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"Makefile","slug":"stm32/Makefile","permalink":"http://example.com/categories/stm32/Makefile/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"Makefile","slug":"Makefile","permalink":"http://example.com/tags/Makefile/"}]},{"title":"ws2812","slug":"stm32/ws2812","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.330Z","comments":true,"path":"2024/12/24/stm32/ws2812/","permalink":"http://example.com/2024/12/24/stm32/ws2812/","excerpt":"","text":"WS2812驱动时序 码 释义 时间 T0H 0码，高电平时间 400±150ns T0H 1码，高电平时间 850±150ns T0L 0码，低电平时间 850±150ns T0L 1码，低电平时间 400±150ns RES 复位低电平时间 &gt;50us 配置定时器 PWM通道 ARR &#x3D; 时钟频率 * 1.2 其余默认(0分频，向上计数，PWM1…) DMA配置 DMA中断默认开启，时钟中断不需要开 添加DMA，对应定时器和通道，Memory to Peripheral,Very High，Mode Normal,Increment Memory,Data Width Per&#x3D;Half word,Mem &#x3D; Word 控制代码1.简单效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#define LED_NUM 100static uint32_t Led[LED_NUM];LEDFUN Ledfun = STREAM_Y;void Led_Func(LEDFUN sel)&#123; uint32_t G = 0xff&lt;&lt;16; uint32_t R = 0xff&lt;&lt;8; uint32_t B = 0xff; uint8_t i,temp; static uint8_t cnt; static uint8_t timecnt; static uint32_t tick = 0; if (++timecnt &gt; 100) timecnt = 0; if (++cnt &gt;LED_NUM*2) cnt = 0; for(i = 0;i &lt; LED_NUM;i++) &#123; Led[i] = 0; &#125; switch (sel) &#123; //OFF case 0: break; //breath;//---------------------------------------------------------- case BREATH_G: for(i = 0;i &lt; LED_NUM;i++) &#123; if (timecnt&lt;50) Led[i] = (1&lt;&lt;16)*5*timecnt; else Led[i] = (1&lt;&lt;16)*5*(100-timecnt); &#125; break; case BREATH_R: for(i = 0;i &lt; LED_NUM;i++) &#123; if (timecnt&lt;50) Led[i] = (1&lt;&lt;8)*5*timecnt; else Led[i] = (1&lt;&lt;8)*5*(100-timecnt); &#125; break; case BREATH_B: for(i = 0;i &lt; LED_NUM;i++) &#123; if (timecnt&lt;50) Led[i] = 5*timecnt; else Led[i] = 5*(100-timecnt); &#125; break; case BREATH_Y: for(i = 0;i &lt; LED_NUM;i++) &#123; if (timecnt&lt;50) Led[i] = (1&lt;&lt;16|1&lt;&lt;8)*5*timecnt; else Led[i] = (1&lt;&lt;16|1&lt;&lt;8)*5*(100-timecnt); &#125; break; case BREATH_GY: for(i = 0;i &lt; LED_NUM;i++) &#123; if (timecnt&lt;50) Led[i] = (1|1&lt;&lt;8)*5*timecnt; else Led[i] = (1|1&lt;&lt;8)*5*(100-timecnt); &#125; break; case BREATH_D: for(i = 0;i &lt; LED_NUM;i++) &#123; if (timecnt&lt;50) Led[i] = (5|3&lt;&lt;8)*timecnt; else Led[i] = (5|3&lt;&lt;8)*(100-timecnt); &#125; break; //flicker//---------------------------------------------------------- case FLICKER_G: for(i = 0;i &lt; LED_NUM;i++) &#123; if (timecnt%50 &gt; 25) Led[i] = G; else Led[i] = 0; &#125; break; case FLICKER_R: for(i = 0;i &lt; LED_NUM;i++) &#123; if (timecnt%50 &gt; 25) Led[i] = R; else Led[i] = 0; &#125; break; case FLICKER_B: for(i = 0;i &lt; LED_NUM;i++) &#123; if (timecnt%50 &gt; 25) Led[i] = B; else Led[i] = 0; &#125; break; case FLICKER_Y: for(i = 0;i &lt; LED_NUM;i++) &#123; if (timecnt%50 &gt; 25) Led[i] = 0xffff00; else Led[i] = 0; &#125; break; case FLICKER_GY: for(i = 0;i &lt; LED_NUM;i++) &#123; if (timecnt%50 &gt; 25) Led[i] = 0xffff; else Led[i] = 0; &#125; break; //stream//---------------------------------------------------------- case STREAM_G: for (i = 0;i &lt; 16;i++) &#123; Led[(i + cnt/2)%LED_NUM] = (i&lt;&lt;16)*16; &#125; break; case STREAM_R: for (i = 0;i &lt; 16;i++) &#123; Led[(i + cnt/2)%LED_NUM] = (i&lt;&lt;8)*16; &#125; break; case STREAM_B: for (i = 0;i &lt; 16;i++) &#123; Led[(i + cnt/2)%LED_NUM] = i*16; &#125; break; case STREAM_Y: for (i = 0;i &lt; 16;i++) &#123; Led[(i + cnt/2)%LED_NUM] = (i|i&lt;&lt;8 )*16; &#125; break;//---------------------------------------------------------- case RAINBOW: temp = LED_NUM/7; for (i = 0; i &lt; temp;i++) &#123; Led[i+temp*0] = R; Led[i+temp*1] = 0x85ff00; Led[i+temp*2] = 0xffff00; Led[i+temp*3] = G; Led[i+temp*4] = 0xfc5c00; Led[i+temp*5] = B; Led[i+temp*6] = 0x0094d3; &#125; break; &#125;&#125; 2.驱动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;tim.h&quot;typedef struct&#123; const uint32_t head[2]; uint32_t data[LED_NUM*24]; const uint32_t tail;&#125;DMA_Buffer;DMA_Buffer P_Buffer=&#123; .head[0] = 0, .head[1] = 0, .tail = 0,&#125;;void Led_Show(void)&#123; uint16_t i,j; static uint32_t tick = 0; static uint32_t test_cnt = 0; if (HAL_GetTick() - tick &gt; 40)//调用频率 &#123; tick = HAL_GetTick(); &#125; else &#123; return; &#125; //---------------------------------------- //测试 if (++test_cnt &gt; 200) &#123; test_cnt = 0; Ledfun++; if (Ledfun == RAINBOW+1) &#123; Ledfun =BREATH_G; &#125; &#125; //---------------------------------------- Led_Func(Ledfun); for (i = 0; i &lt; LED_NUM;i++) &#123; for (j = 0;j &lt; 24;j++) P_Buffer.data[24*i+j] = (Led[i] &amp; (1 &lt;&lt; (23-j)))? 40:20;//71:34;//根据实际修改 &#125; HAL_TIM_PWM_Start_DMA(&amp;htim4, TIM_CHANNEL_1, (uint32_t *)&amp;P_Buffer, 2 + LED_NUM * 24 + 1);&#125;//中断回调void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)&#123; HAL_TIM_PWM_Stop(&amp;htim4,TIM_CHANNEL_1);&#125;","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"ws2812","slug":"stm32/ws2812","permalink":"http://example.com/categories/stm32/ws2812/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"}]},{"title":"vscode doxygen","slug":"vscode/setting.json","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.332Z","comments":true,"path":"2024/12/24/vscode/setting.json/","permalink":"http://example.com/2024/12/24/vscode/setting.json/","excerpt":"","text":"1. ctrl+shift+p2. 输入setting3. 选择 首选项：打开设置（json）即可.4、将以下文件复制到json中&#123; &quot;tabnine.experimentalAutoImports&quot;: true, &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;, // Doxygen documentation generator set &quot;doxdocgen.file.copyrightTag&quot;: [ &quot;@copyright Copyright (c) &#123;year&#125; 武汉木仓科技股份有限公司&quot; ], &quot;doxdocgen.file.customTag&quot;: [ &quot;@par 修改日志:&quot;, &quot;&lt;table&gt;&quot;, &quot;&lt;tr&gt;&lt;th&gt;Date &lt;th&gt;Version &lt;th&gt;Author &lt;th&gt;Description&quot;, &quot;&lt;tr&gt;&lt;td&gt;&#123;date&#125; &lt;td&gt;1.0 &lt;td&gt;chengxingjun &lt;td&gt;内容&quot;, &quot;&lt;/table&gt;&quot;, ], &quot;doxdocgen.file.fileOrder&quot;: [ &quot;file&quot;, &quot;brief&quot;, &quot;author&quot;, &quot;version&quot;, &quot;date&quot;, &quot;empty&quot;, &quot;copyright&quot;, &quot;empty&quot;, &quot;custom&quot; ], &quot;doxdocgen.file.fileTemplate&quot;: &quot;@file &#123;name&#125;&quot;, &quot;doxdocgen.file.versionTag&quot;: &quot;@version 1.0&quot;, &quot;doxdocgen.generic.authorEmail&quot;: &quot;chengxingjun@mucang.cn&quot;, &quot;doxdocgen.generic.authorName&quot;: &quot;chengxingjun&quot;, &quot;doxdocgen.generic.authorTag&quot;: &quot;@author &#123;author&#125; (&#123;email&#125;)&quot;, &quot;doxdocgen.generic.order&quot;: [ &quot;brief&quot;, &quot;tparam&quot;, &quot;param&quot;, &quot;return&quot; ], &quot;doxdocgen.generic.paramTemplate&quot;: &quot;@param&#123;indent:8&#125;&#123;param&#125;&#123;indent:25&#125; [in/out]&quot;, &quot;doxdocgen.generic.returnTemplate&quot;: &quot;@return &#123;type&#125; &quot;, &quot;doxdocgen.generic.splitCasingSmartText&quot;: true, &quot;C_Cpp.updateChannel&quot;: &quot;Insiders&quot;, &quot;vsicons.dontShowNewVersionMessage&quot;: true, &quot;security.workspace.trust.untrustedFiles&quot;: &quot;open&quot;, &quot;cmake.configureOnOpen&quot;: true, &quot;http.proxySupport&quot;: &quot;off&quot;, &quot;cSpell.userWords&quot;: [], &#125;","categories":[{"name":"vscode","slug":"vscode","permalink":"http://example.com/categories/vscode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"}]},{"title":"stm32启动","slug":"stm32/start","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.328Z","comments":true,"path":"2024/12/24/stm32/start/","permalink":"http://example.com/2024/12/24/stm32/start/","excerpt":"","text":"stm32启动启动方式 boot0 boot1 启动方式 0 x FLASH 主闪存存储器 1 1 SRAM 内置SRAM 1 0 ISP 系统存储器 启动文件 声明栈顶地址(链接文件中描述) 声明中断向量表 写Reset_Handler中断服务函数逻辑 清空.bss段FLASH中.data段加载入RAMSystemInit,main函数跳转 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438 .syntax unified .cpu cortex-m4 .fpu softvfp .thumb.global g_pfnVectors.global Default_Handler/* start address for the initialization values of the .data section.defined in linker script */.word _sidata/* start address for the .data section. defined in linker script */.word _sdata/* end address for the .data section. defined in linker script */.word _edata/* start address for the .bss section. defined in linker script */.word _sbss/* end address for the .bss section. defined in linker script */.word _ebss.equ BootRAM, 0xF1E0F85F/** * @brief This is the code that gets called when the processor first * starts execution following a reset event. Only the absolutely * necessary set is performed, after which the application * supplied main() routine is called. * @param None * @retval : None*/ .section .text.Reset_Handler .weak Reset_Handler .type Reset_Handler, %functionReset_Handler: ldr sp, =_estack /* Atollic update: set stack pointer *//* Copy the data segment initializers from flash to SRAM */ ldr r0, =_sdata/*start data*/ ldr r1, =_edata/*end data */ ldr r2, =_sidata/*start .data */ movs r3, #0 b LoopCopyDataInitCopyDataInit: ldr r4, [r2, r3] str r4, [r0, r3] adds r3, r3, #4LoopCopyDataInit: adds r4, r0, r3 cmp r4, r1 bcc CopyDataInit /* Zero fill the bss segment. */ ldr r2, =_sbss ldr r4, =_ebss movs r3, #0 b LoopFillZerobssFillZerobss: str r3, [r2] adds r2, r2, #4LoopFillZerobss: cmp r2, r4 bcc FillZerobss/* Call the clock system intitialization function.*/ bl SystemInit/* Call static constructors */ bl __libc_init_array/* Call the application&#x27;s entry point.*/ bl mainLoopForever: b LoopForever .size Reset_Handler, .-Reset_Handler/** * @brief This is the code that gets called when the processor receives an * unexpected interrupt. This simply enters an infinite loop, preserving * the system state for examination by a debugger. * * @param None * @retval : None*/ .section .text.Default_Handler,&quot;ax&quot;,%progbitsDefault_Handler:Infinite_Loop: b Infinite_Loop .size Default_Handler, .-Default_Handler/******************************************************************************** The minimal vector table for a Cortex-M4. Note that the proper constructs* must be placed on this to ensure that it ends up at physical address* 0x0000.0000.*******************************************************************************/ .section .isr_vector,&quot;a&quot;,%progbits .type g_pfnVectors, %object .size g_pfnVectors, .-g_pfnVectorsg_pfnVectors: .word _estack .word Reset_Handler .word NMI_Handler .word HardFault_Handler .word MemManage_Handler .word BusFault_Handler .word UsageFault_Handler .word 0 .word 0 .word 0 .word 0 .word SVC_Handler .word DebugMon_Handler .word 0 .word PendSV_Handler .word SysTick_Handler .word WWDG_IRQHandler .word PVD_IRQHandler .word TAMP_STAMP_IRQHandler .word RTC_WKUP_IRQHandler .word FLASH_IRQHandler .word RCC_IRQHandler .word EXTI0_IRQHandler .word EXTI1_IRQHandler .word EXTI2_TSC_IRQHandler .word EXTI3_IRQHandler .word EXTI4_IRQHandler .word DMA1_Channel1_IRQHandler .word DMA1_Channel2_IRQHandler .word DMA1_Channel3_IRQHandler .word DMA1_Channel4_IRQHandler .word DMA1_Channel5_IRQHandler .word DMA1_Channel6_IRQHandler .word DMA1_Channel7_IRQHandler .word ADC1_2_IRQHandler .word USB_HP_CAN_TX_IRQHandler .word USB_LP_CAN_RX0_IRQHandler .word CAN_RX1_IRQHandler .word CAN_SCE_IRQHandler .word EXTI9_5_IRQHandler .word TIM1_BRK_TIM15_IRQHandler .word TIM1_UP_TIM16_IRQHandler .word TIM1_TRG_COM_TIM17_IRQHandler .word TIM1_CC_IRQHandler .word TIM2_IRQHandler .word TIM3_IRQHandler .word TIM4_IRQHandler .word I2C1_EV_IRQHandler .word I2C1_ER_IRQHandler .word I2C2_EV_IRQHandler .word I2C2_ER_IRQHandler .word SPI1_IRQHandler .word SPI2_IRQHandler .word USART1_IRQHandler .word USART2_IRQHandler .word USART3_IRQHandler .word EXTI15_10_IRQHandler .word RTC_Alarm_IRQHandler .word USBWakeUp_IRQHandler .word TIM8_BRK_IRQHandler .word TIM8_UP_IRQHandler .word TIM8_TRG_COM_IRQHandler .word TIM8_CC_IRQHandler .word ADC3_IRQHandler .word 0 .word 0 .word 0 .word SPI3_IRQHandler .word UART4_IRQHandler .word UART5_IRQHandler .word TIM6_DAC_IRQHandler .word TIM7_IRQHandler .word DMA2_Channel1_IRQHandler .word DMA2_Channel2_IRQHandler .word DMA2_Channel3_IRQHandler .word DMA2_Channel4_IRQHandler .word DMA2_Channel5_IRQHandler .word ADC4_IRQHandler .word 0 .word 0 .word COMP1_2_3_IRQHandler .word COMP4_5_6_IRQHandler .word COMP7_IRQHandler .word 0 .word 0 .word 0 .word 0 .word 0 .word 0 .word 0 .word USB_HP_IRQHandler .word USB_LP_IRQHandler .word USBWakeUp_RMP_IRQHandler .word 0 .word 0 .word 0 .word 0 .word FPU_IRQHandler/********************************************************************************* Provide weak aliases for each Exception handler to the Default_Handler.* As they are weak aliases, any function with the same name will override* this definition.********************************************************************************/ .weak NMI_Handler .thumb_set NMI_Handler,Default_Handler .weak HardFault_Handler .thumb_set HardFault_Handler,Default_Handler .weak MemManage_Handler .thumb_set MemManage_Handler,Default_Handler .weak BusFault_Handler .thumb_set BusFault_Handler,Default_Handler .weak UsageFault_Handler .thumb_set UsageFault_Handler,Default_Handler .weak SVC_Handler .thumb_set SVC_Handler,Default_Handler .weak DebugMon_Handler .thumb_set DebugMon_Handler,Default_Handler .weak PendSV_Handler .thumb_set PendSV_Handler,Default_Handler .weak SysTick_Handler .thumb_set SysTick_Handler,Default_Handler .weak WWDG_IRQHandler .thumb_set WWDG_IRQHandler,Default_Handler .weak PVD_IRQHandler .thumb_set PVD_IRQHandler,Default_Handler .weak TAMP_STAMP_IRQHandler .thumb_set TAMP_STAMP_IRQHandler,Default_Handler .weak RTC_WKUP_IRQHandler .thumb_set RTC_WKUP_IRQHandler,Default_Handler .weak FLASH_IRQHandler .thumb_set FLASH_IRQHandler,Default_Handler .weak RCC_IRQHandler .thumb_set RCC_IRQHandler,Default_Handler .weak EXTI0_IRQHandler .thumb_set EXTI0_IRQHandler,Default_Handler .weak EXTI1_IRQHandler .thumb_set EXTI1_IRQHandler,Default_Handler .weak EXTI2_TSC_IRQHandler .thumb_set EXTI2_TSC_IRQHandler,Default_Handler .weak EXTI3_IRQHandler .thumb_set EXTI3_IRQHandler,Default_Handler .weak EXTI4_IRQHandler .thumb_set EXTI4_IRQHandler,Default_Handler .weak DMA1_Channel1_IRQHandler .thumb_set DMA1_Channel1_IRQHandler,Default_Handler .weak DMA1_Channel2_IRQHandler .thumb_set DMA1_Channel2_IRQHandler,Default_Handler .weak DMA1_Channel3_IRQHandler .thumb_set DMA1_Channel3_IRQHandler,Default_Handler .weak DMA1_Channel4_IRQHandler .thumb_set DMA1_Channel4_IRQHandler,Default_Handler .weak DMA1_Channel5_IRQHandler .thumb_set DMA1_Channel5_IRQHandler,Default_Handler .weak DMA1_Channel6_IRQHandler .thumb_set DMA1_Channel6_IRQHandler,Default_Handler .weak DMA1_Channel7_IRQHandler .thumb_set DMA1_Channel7_IRQHandler,Default_Handler .weak ADC1_2_IRQHandler .thumb_set ADC1_2_IRQHandler,Default_Handler .weak USB_HP_CAN_TX_IRQHandler .thumb_set USB_HP_CAN_TX_IRQHandler,Default_Handler .weak USB_LP_CAN_RX0_IRQHandler .thumb_set USB_LP_CAN_RX0_IRQHandler,Default_Handler .weak CAN_RX1_IRQHandler .thumb_set CAN_RX1_IRQHandler,Default_Handler .weak CAN_SCE_IRQHandler .thumb_set CAN_SCE_IRQHandler,Default_Handler .weak EXTI9_5_IRQHandler .thumb_set EXTI9_5_IRQHandler,Default_Handler .weak TIM1_BRK_TIM15_IRQHandler .thumb_set TIM1_BRK_TIM15_IRQHandler,Default_Handler .weak TIM1_UP_TIM16_IRQHandler .thumb_set TIM1_UP_TIM16_IRQHandler,Default_Handler .weak TIM1_TRG_COM_TIM17_IRQHandler .thumb_set TIM1_TRG_COM_TIM17_IRQHandler,Default_Handler .weak TIM1_CC_IRQHandler .thumb_set TIM1_CC_IRQHandler,Default_Handler .weak TIM2_IRQHandler .thumb_set TIM2_IRQHandler,Default_Handler .weak TIM3_IRQHandler .thumb_set TIM3_IRQHandler,Default_Handler .weak TIM4_IRQHandler .thumb_set TIM4_IRQHandler,Default_Handler .weak I2C1_EV_IRQHandler .thumb_set I2C1_EV_IRQHandler,Default_Handler .weak I2C1_ER_IRQHandler .thumb_set I2C1_ER_IRQHandler,Default_Handler .weak I2C2_EV_IRQHandler .thumb_set I2C2_EV_IRQHandler,Default_Handler .weak I2C2_ER_IRQHandler .thumb_set I2C2_ER_IRQHandler,Default_Handler .weak SPI1_IRQHandler .thumb_set SPI1_IRQHandler,Default_Handler .weak SPI2_IRQHandler .thumb_set SPI2_IRQHandler,Default_Handler .weak USART1_IRQHandler .thumb_set USART1_IRQHandler,Default_Handler .weak USART2_IRQHandler .thumb_set USART2_IRQHandler,Default_Handler .weak USART3_IRQHandler .thumb_set USART3_IRQHandler,Default_Handler .weak EXTI15_10_IRQHandler .thumb_set EXTI15_10_IRQHandler,Default_Handler .weak RTC_Alarm_IRQHandler .thumb_set RTC_Alarm_IRQHandler,Default_Handler .weak USBWakeUp_IRQHandler .thumb_set USBWakeUp_IRQHandler,Default_Handler .weak TIM8_BRK_IRQHandler .thumb_set TIM8_BRK_IRQHandler,Default_Handler .weak TIM8_UP_IRQHandler .thumb_set TIM8_UP_IRQHandler,Default_Handler .weak TIM8_TRG_COM_IRQHandler .thumb_set TIM8_TRG_COM_IRQHandler,Default_Handler .weak TIM8_CC_IRQHandler .thumb_set TIM8_CC_IRQHandler,Default_Handler .weak ADC3_IRQHandler .thumb_set ADC3_IRQHandler,Default_Handler .weak SPI3_IRQHandler .thumb_set SPI3_IRQHandler,Default_Handler .weak UART4_IRQHandler .thumb_set UART4_IRQHandler,Default_Handler .weak UART5_IRQHandler .thumb_set UART5_IRQHandler,Default_Handler .weak TIM6_DAC_IRQHandler .thumb_set TIM6_DAC_IRQHandler,Default_Handler .weak TIM7_IRQHandler .thumb_set TIM7_IRQHandler,Default_Handler .weak DMA2_Channel1_IRQHandler .thumb_set DMA2_Channel1_IRQHandler,Default_Handler .weak DMA2_Channel2_IRQHandler .thumb_set DMA2_Channel2_IRQHandler,Default_Handler .weak DMA2_Channel3_IRQHandler .thumb_set DMA2_Channel3_IRQHandler,Default_Handler .weak DMA2_Channel4_IRQHandler .thumb_set DMA2_Channel4_IRQHandler,Default_Handler .weak DMA2_Channel5_IRQHandler .thumb_set DMA2_Channel5_IRQHandler,Default_Handler .weak ADC4_IRQHandler .thumb_set ADC4_IRQHandler,Default_Handler .weak COMP1_2_3_IRQHandler .thumb_set COMP1_2_3_IRQHandler,Default_Handler .weak COMP4_5_6_IRQHandler .thumb_set COMP4_5_6_IRQHandler,Default_Handler .weak COMP7_IRQHandler .thumb_set COMP7_IRQHandler,Default_Handler .weak USB_HP_IRQHandler .thumb_set USB_HP_IRQHandler,Default_Handler .weak USB_LP_IRQHandler .thumb_set USB_LP_IRQHandler,Default_Handler .weak USBWakeUp_RMP_IRQHandler .thumb_set USBWakeUp_RMP_IRQHandler,Default_Handler .weak FPU_IRQHandler .thumb_set FPU_IRQHandler,Default_Handler/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236//*****************************************************************************//startup.c//*****************************************************************************#define WEAK __attribute__ ((weak))#define ALIAS(f) __attribute__ ((weak, alias (#f)))WEAK void Reset_Handler(void);WEAK void Default_Handler(void);void WDT_IRQHandler(void) ALIAS(Default_Handler);void NMI_Handler(void) ALIAS(Default_Handler);void HardFault_Handler(void) ALIAS(Default_Handler);void MemManage_Handler(void) ALIAS(Default_Handler);void BusFault_Handler(void) ALIAS(Default_Handler);void UsageFault_Handler(void) ALIAS(Default_Handler);void SVC_Handler(void) ALIAS(Default_Handler);void DebugMon_Handler(void) ALIAS(Default_Handler);void PendSV_Handler(void) ALIAS(Default_Handler);void SysTick_Handler(void) ALIAS(Default_Handler);void WWDG_IRQHandler(void) ALIAS(Default_Handler);void PVD_IRQHandler(void) ALIAS(Default_Handler);void TAMP_STAMP_IRQHandler(void) ALIAS(Default_Handler);void RTC_WKUP_IRQHandler(void) ALIAS(Default_Handler);void FLASH_IRQHandler(void) ALIAS(Default_Handler);void RCC_IRQHandler(void) ALIAS(Default_Handler);void EXTI0_IRQHandler(void) ALIAS(Default_Handler);void EXTI1_IRQHandler(void) ALIAS(Default_Handler);void EXTI2_TSC_IRQHandler(void) ALIAS(Default_Handler);void EXTI3_IRQHandler(void) ALIAS(Default_Handler);void EXTI4_IRQHandler(void) ALIAS(Default_Handler);void DMA1_Channel1_IRQHandler(void) ALIAS(Default_Handler);void DMA1_Channel2_IRQHandler(void) ALIAS(Default_Handler);void DMA1_Channel3_IRQHandler(void) ALIAS(Default_Handler);void DMA1_Channel4_IRQHandler(void) ALIAS(Default_Handler);void DMA1_Channel5_IRQHandler(void) ALIAS(Default_Handler);void DMA1_Channel6_IRQHandler(void) ALIAS(Default_Handler);void DMA1_Channel7_IRQHandler(void) ALIAS(Default_Handler);void ADC1_2_IRQHandler(void) ALIAS(Default_Handler);void USB_HP_CAN_TX_IRQHandler(void) ALIAS(Default_Handler);void USB_LP_CAN_RX0_IRQHandler(void) ALIAS(Default_Handler);void CAN_RX1_IRQHandler(void) ALIAS(Default_Handler);void CAN_SCE_IRQHandler(void) ALIAS(Default_Handler);void EXTI9_5_IRQHandler(void) ALIAS(Default_Handler);void TIM1_BRK_TIM15_IRQHandler(void) ALIAS(Default_Handler);void TIM1_UP_TIM16_IRQHandler(void) ALIAS(Default_Handler);void TIM1_TRG_COM_TIM17_IRQHandler(void) ALIAS(Default_Handler);void TIM1_CC_IRQHandler(void) ALIAS(Default_Handler);void TIM2_IRQHandler(void) ALIAS(Default_Handler);void TIM3_IRQHandler(void) ALIAS(Default_Handler);void TIM4_IRQHandler(void) ALIAS(Default_Handler);void I2C1_EV_IRQHandler(void) ALIAS(Default_Handler);void I2C1_ER_IRQHandler(void) ALIAS(Default_Handler);void I2C2_EV_IRQHandler(void) ALIAS(Default_Handler);void I2C2_ER_IRQHandler(void) ALIAS(Default_Handler);void SPI1_IRQHandler(void) ALIAS(Default_Handler);void SPI2_IRQHandler(void) ALIAS(Default_Handler);void USART1_IRQHandler(void) ALIAS(Default_Handler);void USART2_IRQHandler(void) ALIAS(Default_Handler);void USART3_IRQHandler(void) ALIAS(Default_Handler);void EXTI15_10_IRQHandler(void) ALIAS(Default_Handler);void RTC_Alarm_IRQHandler(void) ALIAS(Default_Handler);void USBWakeUp_IRQHandler(void) ALIAS(Default_Handler);void TIM8_BRK_IRQHandler(void) ALIAS(Default_Handler);void TIM8_UP_IRQHandler(void) ALIAS(Default_Handler);void TIM8_TRG_COM_IRQHandler(void) ALIAS(Default_Handler);void TIM8_CC_IRQHandler(void) ALIAS(Default_Handler);void ADC3_IRQHandler(void) ALIAS(Default_Handler);void SPI3_IRQHandler(void) ALIAS(Default_Handler);void UART4_IRQHandler(void) ALIAS(Default_Handler);void UART5_IRQHandler(void) ALIAS(Default_Handler);void TIM6_DAC_IRQHandler(void) ALIAS(Default_Handler);void TIM7_IRQHandler(void) ALIAS(Default_Handler);void DMA2_Channel1_IRQHandler(void) ALIAS(Default_Handler);void DMA2_Channel2_IRQHandler(void) ALIAS(Default_Handler);void DMA2_Channel3_IRQHandler(void) ALIAS(Default_Handler);void DMA2_Channel4_IRQHandler(void) ALIAS(Default_Handler);void DMA2_Channel5_IRQHandler(void) ALIAS(Default_Handler);void ADC4_IRQHandler(void) ALIAS(Default_Handler); void COMP1_2_3_IRQHandler(void) ALIAS(Default_Handler);void COMP4_5_6_IRQHandler(void) ALIAS(Default_Handler);void COMP7_IRQHandler(void) ALIAS(Default_Handler);void USB_HP_IRQHandler(void) ALIAS(Default_Handler);void USB_LP_IRQHandler(void) ALIAS(Default_Handler);void USBWakeUp_RMP_IRQHandler(void) ALIAS(Default_Handler);void FPU_IRQHandler(void) ALIAS(Default_Handler);//*****************************************************************************// The vector table.//*****************************************************************************extern unsigned long _estack;void (* const g_pfnVectors[])(void)__attribute__ ((section(&quot;.isr_vector&quot;)));void (* const g_pfnVectors[])(void) =&#123; (void *)&amp;_estack, Reset_Handler, NMI_Handler, HardFault_Handler, MemManage_Handler, BusFault_Handler, UsageFault_Handler, 0, 0, 0, 0, SVC_Handler, DebugMon_Handler, 0, PendSV_Handler, SysTick_Handler, WWDG_IRQHandler, PVD_IRQHandler, TAMP_STAMP_IRQHandler, RTC_WKUP_IRQHandler, FLASH_IRQHandler, RCC_IRQHandler, EXTI0_IRQHandler, EXTI1_IRQHandler, EXTI2_TSC_IRQHandler, EXTI3_IRQHandler, EXTI4_IRQHandler, DMA1_Channel1_IRQHandler, DMA1_Channel2_IRQHandler, DMA1_Channel3_IRQHandler, DMA1_Channel4_IRQHandler, DMA1_Channel5_IRQHandler, DMA1_Channel6_IRQHandler, DMA1_Channel7_IRQHandler, ADC1_2_IRQHandler, USB_HP_CAN_TX_IRQHandler, USB_LP_CAN_RX0_IRQHandler, CAN_RX1_IRQHandler, CAN_SCE_IRQHandler, EXTI9_5_IRQHandler, TIM1_BRK_TIM15_IRQHandler, TIM1_UP_TIM16_IRQHandler, TIM1_TRG_COM_TIM17_IRQHandler, TIM1_CC_IRQHandler, TIM2_IRQHandler, TIM3_IRQHandler, TIM4_IRQHandler, I2C1_EV_IRQHandler, I2C1_ER_IRQHandler, I2C2_EV_IRQHandler, I2C2_ER_IRQHandler, SPI1_IRQHandler, SPI2_IRQHandler, USART1_IRQHandler, USART2_IRQHandler, USART3_IRQHandler, EXTI15_10_IRQHandler, RTC_Alarm_IRQHandler, USBWakeUp_IRQHandler, TIM8_BRK_IRQHandler, TIM8_UP_IRQHandler, TIM8_TRG_COM_IRQHandler, TIM8_CC_IRQHandler, ADC3_IRQHandler, 0, 0, 0, SPI3_IRQHandler, UART4_IRQHandler, UART5_IRQHandler, TIM6_DAC_IRQHandler, TIM7_IRQHandler, DMA2_Channel1_IRQHandler, DMA2_Channel2_IRQHandler, DMA2_Channel3_IRQHandler, DMA2_Channel4_IRQHandler, DMA2_Channel5_IRQHandler, ADC4_IRQHandler, 0, 0, COMP1_2_3_IRQHandler, COMP4_5_6_IRQHandler, COMP7_IRQHandler, 0, 0, 0, 0, 0, 0, 0, USB_HP_IRQHandler, USB_LP_IRQHandler, USBWakeUp_RMP_IRQHandler, 0, 0, 0, 0, FPU_IRQHandler,&#125;;extern unsigned long _sidata;extern unsigned long _sdata;extern unsigned long _edata;extern unsigned long _sbss;extern unsigned long _ebss;extern int main(void);extern void SystemInit();extern void __libc_init_array();void Reset_Handler(void) &#123; unsigned long *pulSrc, *pulDest; pulSrc = &amp;_sidata; pulDest = &amp;_sdata; while( pulDest &lt; &amp;_edata) &#123; *pulDest++ = *pulSrc++; &#125; pulDest = &amp;_sbss; while(pulDest &lt; &amp;_ebss) &#123; *pulDest++ = 0; &#125; SystemInit(); __libc_init_array(); main(); while (1) &#123; &#125;&#125;void Default_Handler(void)&#123; while(1) &#123; &#125;&#125;","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"}]},{"title":"windows 常用操作","slug":"windows/windows","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-30T00:54:49.449Z","comments":true,"path":"2024/12/24/windows/windows/","permalink":"http://example.com/2024/12/24/windows/windows/","excerpt":"","text":"网页禁止复制解除win: 在控制台F12页面Sources 快捷键 ctrl+shift+p 然后输入 javascript 找到 disabled javaScript. 切换到旧版右键菜单：1reg add &quot;HKCU\\Software\\Classes\\CLSID\\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\\InprocServer32&quot; /f /ve 恢复回Win11右键菜单:1reg delete &quot;HKCU\\Software\\Classes\\CLSID\\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;&quot; /f 重启Windows资源管理器生效:1taskkill /f /im explorer.exe &amp; start explorer.exe","categories":[{"name":"windows","slug":"windows","permalink":"http://example.com/categories/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"}]},{"title":"stm32 cmake","slug":"stm32/stm32cmake","date":"2024-12-24T01:43:25.000Z","updated":"2024-12-27T07:14:50.330Z","comments":true,"path":"2024/12/24/stm32/stm32cmake/","permalink":"http://example.com/2024/12/24/stm32/stm32cmake/","excerpt":"","text":"STM32 CMAKEFILE123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199cmake_minimum_required(VERSION 3.22)## This file is generated only once,# and is not re-generated if converter is called multiple times.## User is free to modify the file as much as necessary## Setup compiler settingsset(CMAKE_C_STANDARD 11)set(CMAKE_C_STANDARD_REQUIRED ON)set(CMAKE_C_EXTENSIONS ON)# Define the build typeif(NOT CMAKE_BUILD_TYPE) set(CMAKE_BUILD_TYPE &quot;Debug&quot;)endif()# Set the project nameset(CMAKE_PROJECT_NAME test2)# Include toolchain fileset(CMAKE_SYSTEM_NAME Generic)set(CMAKE_SYSTEM_PROCESSOR arm)set(CMAKE_C_COMPILER_FORCED TRUE)set(CMAKE_CXX_COMPILER_FORCED TRUE)set(CMAKE_C_COMPILER_ID GNU)set(CMAKE_CXX_COMPILER_ID GNU)# Some default GCC settings# arm-none-eabi- must be part of path environmentset(TOOLCHAIN_PREFIX arm-none-eabi-)set(CMAKE_C_COMPILER $&#123;TOOLCHAIN_PREFIX&#125;gcc)set(CMAKE_ASM_COMPILER $&#123;CMAKE_C_COMPILER&#125;)set(CMAKE_CXX_COMPILER $&#123;TOOLCHAIN_PREFIX&#125;g++)set(CMAKE_LINKER $&#123;TOOLCHAIN_PREFIX&#125;g++)set(CMAKE_OBJCOPY $&#123;TOOLCHAIN_PREFIX&#125;objcopy)set(CMAKE_SIZE $&#123;TOOLCHAIN_PREFIX&#125;size)set(CMAKE_EXECUTABLE_SUFFIX_ASM &quot;.elf&quot;)set(CMAKE_EXECUTABLE_SUFFIX_C &quot;.elf&quot;)set(CMAKE_EXECUTABLE_SUFFIX_CXX &quot;.elf&quot;)set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)set(LDSCRIPT STM32F103RCTx_FLASH.ld)# MCU specific flagsset(TARGET_FLAGS &quot;-mcpu=cortex-m3 &quot;)set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; $&#123;TARGET_FLAGS&#125;&quot;)set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wall -Wextra -Wpedantic -fdata-sections -ffunction-sections&quot;)if(CMAKE_BUILD_TYPE MATCHES Debug) set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -O0 -g3&quot;)endif()if(CMAKE_BUILD_TYPE MATCHES Release) set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Os -g0&quot;)endif()set(CMAKE_ASM_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -x assembler-with-cpp -MMD -MP&quot;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -fno-rtti -fno-exceptions -fno-threadsafe-statics&quot;)set(CMAKE_C_LINK_FLAGS &quot;$&#123;TARGET_FLAGS&#125;&quot;)set(CMAKE_C_LINK_FLAGS &quot;$&#123;CMAKE_C_LINK_FLAGS&#125; -T $&#123;CMAKE_SOURCE_DIR&#125;/$&#123;LDSCRIPT&#125;&quot;)set(CMAKE_C_LINK_FLAGS &quot;$&#123;CMAKE_C_LINK_FLAGS&#125; --specs=nano.specs&quot;)set(CMAKE_C_LINK_FLAGS &quot;$&#123;CMAKE_C_LINK_FLAGS&#125; -Wl,-Map=$&#123;CMAKE_PROJECT_NAME&#125;.map -Wl,--gc-sections&quot;)set(CMAKE_C_LINK_FLAGS &quot;$&#123;CMAKE_C_LINK_FLAGS&#125; -Wl,--start-group -lc -lm -Wl,--end-group&quot;)set(CMAKE_C_LINK_FLAGS &quot;$&#123;CMAKE_C_LINK_FLAGS&#125; -Wl,--print-memory-usage&quot;)set(CMAKE_CXX_LINK_FLAGS &quot;$&#123;CMAKE_C_LINK_FLAGS&#125; -Wl,--start-group -lstdc++ -lsupc++ -Wl,--end-group&quot;)# Enable compile command to ease indexing with e.g. clangdset(CMAKE_EXPORT_COMPILE_COMMANDS TRUE)# Core project settingsproject($&#123;CMAKE_PROJECT_NAME&#125;)message(&quot;Build type: &quot; $&#123;CMAKE_BUILD_TYPE&#125;)# Enable CMake support for ASM and C languagesenable_language(C ASM)# Create an executable object typeadd_executable($&#123;CMAKE_PROJECT_NAME&#125;)# Add STM32CubeMX generated sources# add_subdirectory(cmake/stm32cubemx)add_custom_command( TARGET $&#123;CMAKE_PROJECT_NAME&#125; COMMAND $&#123;CMAKE_OBJCOPY&#125; -O binary -S $&#123;CMAKE_PROJECT_NAME&#125;.elf $&#123;CMAKE_PROJECT_NAME&#125;.bin COMMAND $&#123;CMAKE_OBJCOPY&#125; -O ihex $&#123;CMAKE_PROJECT_NAME&#125;.elf $&#123;CMAKE_PROJECT_NAME&#125;.hex )# Link directories setuptarget_link_directories($&#123;CMAKE_PROJECT_NAME&#125; PRIVATE # Add user defined library search paths)# Add sources to executabletarget_sources($&#123;CMAKE_PROJECT_NAME&#125; PRIVATE # Add user sources here)# Add include pathstarget_include_directories($&#123;CMAKE_PROJECT_NAME&#125; PRIVATE # Add user defined include paths)# Add project symbols (macros)target_compile_definitions($&#123;CMAKE_PROJECT_NAME&#125; PRIVATE # Add user defined symbols)# Add linked librariestarget_link_libraries($&#123;CMAKE_PROJECT_NAME&#125; stm32cubemx # Add user defined libraries)# --------------------------------------------------------------------------# 创建接口库# project(stm32cubemx)add_library(stm32cubemx INTERFACE)target_compile_definitions(stm32cubemx INTERFACE USE_HAL_DRIVER STM32F103xE $&lt;$&lt;CONFIG:Debug&gt;:DEBUG&gt;)target_include_directories(stm32cubemx INTERFACE Core/Inc Drivers/STM32F1xx_HAL_Driver/Inc Drivers/STM32F1xx_HAL_Driver/Inc/Legacy Drivers/CMSIS/Device/ST/STM32F1xx/Include Drivers/CMSIS/Include)target_sources(stm32cubemx INTERFACE Core/Src/main.c Core/Src/stm32f1xx_it.c Core/Src/stm32f1xx_hal_msp.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio_ex.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim_ex.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_dma.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_cortex.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_flash.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_flash_ex.c Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_exti.c Core/Src/system_stm32f1xx.c Core/Src/sysmem.c Core/Src/syscalls.c startup_stm32f103xe.s)# enable_language(C ASM)# project(lib)# ----------------------------------------------------------------# 生成静态库set(GENLIB 0)if(GENLIB MATCHES 1)add_library(lib STATIC Core/Src/main.cCore/Src/stm32f1xx_it.cCore/Src/stm32f1xx_hal_msp.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio_ex.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim_ex.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_dma.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_cortex.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_flash.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_flash_ex.cDrivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_exti.cCore/Src/system_stm32f1xx.cCore/Src/sysmem.cCore/Src/syscalls.cstartup_stm32f103xe.s)target_include_directories(lib PUBLIC Core/IncDrivers/STM32F1xx_HAL_Driver/IncDrivers/STM32F1xx_HAL_Driver/Inc/LegacyDrivers/CMSIS/Device/ST/STM32F1xx/IncludeDrivers/CMSIS/Include)target_compile_definitions(lib PUBLIC USE_HAL_DRIVER STM32F103xE)endif()# ---------------------------------------------------------------- CMD构建 编译 1234cmake -B build -G &#x27;Ninja&#x27;cmake -B build -G &#x27;Unix Makefiles&#x27;cmake --build build task.json 1234567891011121314151617181920212223242526272829303132333435&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;ninja&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;cmake -B build -G &#x27;Ninja&#x27;;cmake --build build&quot;, &quot;problemMatcher&quot;: [], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125; &#125;, &#123; &quot;label&quot;: &quot;build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;cmake -B build -G &#x27;Unix Makefiles&#x27;;cmake --build build&quot;, &quot;problemMatcher&quot;: [], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125; &#125;, &#123; &quot;label&quot;: &quot;clean&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;rm -r build&quot;, &quot;problemMatcher&quot;: [], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125; &#125; ] &#125; 提取commit到文件12345678910111213141516171819@echo offsetlocal enabledelayedexpansion :: 获取当前路径set CURRENT_DIR=%cd% :: 进入源代码目录cd /d %CURRENT_DIR%\\path\\to\\your\\source\\code :: 获取最新的commit号for /f &quot;delims=#&quot; %%a in (&#x27;git rev-parse --short HEAD&#x27;) do @set commit=%%a :: 将commit号写入version.h文件echo #define COMMIT_HASH &quot;%commit%&quot; &gt; version.h :: 退出源代码目录cd /d %CURRENT_DIR% endlocal 完整的commit号（40位SHA-1）写入文件，可以使用以下命令替换 1git rev-parse HEAD &gt; version.h","categories":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"CMake","slug":"stm32/CMake","permalink":"http://example.com/categories/stm32/CMake/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"CMake","slug":"CMake","permalink":"http://example.com/tags/CMake/"}]},{"title":"markdown语法","slug":"blog/grammer","date":"2023-12-26T01:43:25.000Z","updated":"2024-12-27T03:41:42.638Z","comments":true,"path":"2023/12/26/blog/grammer/","permalink":"http://example.com/2023/12/26/blog/grammer/","excerpt":"","text":"markdown语法返回主页 标题标题2标题3标题4标题5标题6# 标题1 ## 标题2 ### 标题3 #### 标题4 ##### 标题5 ###### 标题6 标题标题2标题 === 标题2 --- 文本斜体文本斜体文本 粗体文本粗体文本 粗斜体文本粗斜体文本 删除线 *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ ~~删除线~~ 列表 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 - 第一项 - 第二项 - 第三项 - *+相同 区块 最外层 第一层嵌套 第二层嵌套 &gt; 最外层 &gt; &gt; 第一层嵌套 &gt; &gt; &gt; 第二层嵌套 链接这是一个链接 主页 这是一个链接 [主页](main.md) 我经常去的几个网站Google、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3] [Leanote 笔记][2]是一个不错的[网站][]。 [1]:http://www.google.com &quot;Google&quot; [2]:http://www.leanote.com &quot;Leanote&quot; [3]: &quot;会显示转换后的&quot; [网站]:http://www.baidu.com &quot;百度&quot; 图片这是一张图片 12![alt text](29E3BA89.png)![RUNOOB 图标](markdown.jpg &quot;RUNOOB&quot;) 表格 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 锚点锚点位置 跳转到锚点 123&lt;a id=&quot;index&quot;&gt;锚点位置&lt;/a&gt;跳转到[锚点](#index) 注释 哈哈我是注释，不会在浏览器中显示。 我也是注释。 1234&lt;div style=&#x27;display: none&#x27;&gt;哈哈我是注释，不会在浏览器中显示。我也是注释。&lt;/div&gt; &lt;!-- 多段 注释， 不会在浏览器中显示。 --&gt; 标记标记1 标记2 标记3 标记4 `标记1` ``标记2`` ```标记3``` ````标记4```` 代码12345678/*注释*///注释int main(void)&#123; return 1;&#125; 其他使用 Ctrl+Alt+Del 重启电脑 目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;center&gt; 支持反斜杠添加特殊符号\\ tab标记段","categories":[{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"markdown","slug":"博客/markdown","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/markdown/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]}],"categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"Doxygen","slug":"博客/Doxygen","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/Doxygen/"},{"name":"stm32","slug":"stm32","permalink":"http://example.com/categories/stm32/"},{"name":"nrf","slug":"nrf","permalink":"http://example.com/categories/nrf/"},{"name":"DFU","slug":"nrf/DFU","permalink":"http://example.com/categories/nrf/DFU/"},{"name":"思考","slug":"思考","permalink":"http://example.com/categories/%E6%80%9D%E8%80%83/"},{"name":"hexo","slug":"博客/hexo","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/hexo/"},{"name":"esp","slug":"esp","permalink":"http://example.com/categories/esp/"},{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"ffmpeg","slug":"linux/ffmpeg","permalink":"http://example.com/categories/linux/ffmpeg/"},{"name":"gcc","slug":"linux/gcc","permalink":"http://example.com/categories/linux/gcc/"},{"name":"lib","slug":"linux/gcc/lib","permalink":"http://example.com/categories/linux/gcc/lib/"},{"name":"树莓派","slug":"linux/树莓派","permalink":"http://example.com/categories/linux/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"nginx","slug":"linux/nginx","permalink":"http://example.com/categories/linux/nginx/"},{"name":"数据库","slug":"linux/数据库","permalink":"http://example.com/categories/linux/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"ssh","slug":"linux/ssh","permalink":"http://example.com/categories/linux/ssh/"},{"name":"vim","slug":"linux/vim","permalink":"http://example.com/categories/linux/vim/"},{"name":"开发板","slug":"linux/开发板","permalink":"http://example.com/categories/linux/%E5%BC%80%E5%8F%91%E6%9D%BF/"},{"name":"压缩","slug":"linux/压缩","permalink":"http://example.com/categories/linux/%E5%8E%8B%E7%BC%A9/"},{"name":"lvgl","slug":"lvgl","permalink":"http://example.com/categories/lvgl/"},{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/categories/nodejs/"},{"name":"OCD","slug":"OCD","permalink":"http://example.com/categories/OCD/"},{"name":"pyocd","slug":"OCD/pyocd","permalink":"http://example.com/categories/OCD/pyocd/"},{"name":"gdb","slug":"OCD/gdb","permalink":"http://example.com/categories/OCD/gdb/"},{"name":"OpenOCD","slug":"OCD/OpenOCD","permalink":"http://example.com/categories/OCD/OpenOCD/"},{"name":"vscode","slug":"vscode","permalink":"http://example.com/categories/vscode/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"爬虫","slug":"python/爬虫","permalink":"http://example.com/categories/python/%E7%88%AC%E8%99%AB/"},{"name":"qt","slug":"python/qt","permalink":"http://example.com/categories/python/qt/"},{"name":"crc","slug":"stm32/crc","permalink":"http://example.com/categories/stm32/crc/"},{"name":"usb","slug":"stm32/usb","permalink":"http://example.com/categories/stm32/usb/"},{"name":"DAPLink","slug":"stm32/DAPLink","permalink":"http://example.com/categories/stm32/DAPLink/"},{"name":"objdump","slug":"stm32/objdump","permalink":"http://example.com/categories/stm32/objdump/"},{"name":"HardFault","slug":"stm32/HardFault","permalink":"http://example.com/categories/stm32/HardFault/"},{"name":"hex","slug":"stm32/hex","permalink":"http://example.com/categories/stm32/hex/"},{"name":"mqtt","slug":"stm32/mqtt","permalink":"http://example.com/categories/stm32/mqtt/"},{"name":"lwip","slug":"stm32/lwip","permalink":"http://example.com/categories/stm32/lwip/"},{"name":"Makefile","slug":"stm32/Makefile","permalink":"http://example.com/categories/stm32/Makefile/"},{"name":"ws2812","slug":"stm32/ws2812","permalink":"http://example.com/categories/stm32/ws2812/"},{"name":"windows","slug":"windows","permalink":"http://example.com/categories/windows/"},{"name":"CMake","slug":"stm32/CMake","permalink":"http://example.com/categories/stm32/CMake/"},{"name":"markdown","slug":"博客/markdown","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/markdown/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Doxygen","slug":"Doxygen","permalink":"http://example.com/tags/Doxygen/"},{"name":"stm32","slug":"stm32","permalink":"http://example.com/tags/stm32/"},{"name":"CMake","slug":"CMake","permalink":"http://example.com/tags/CMake/"},{"name":"nrf","slug":"nrf","permalink":"http://example.com/tags/nrf/"},{"name":"DFU","slug":"DFU","permalink":"http://example.com/tags/DFU/"},{"name":"思考","slug":"思考","permalink":"http://example.com/tags/%E6%80%9D%E8%80%83/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"esp","slug":"esp","permalink":"http://example.com/tags/esp/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://example.com/tags/ffmpeg/"},{"name":"录屏","slug":"录屏","permalink":"http://example.com/tags/%E5%BD%95%E5%B1%8F/"},{"name":"makefile","slug":"makefile","permalink":"http://example.com/tags/makefile/"},{"name":"gcc","slug":"gcc","permalink":"http://example.com/tags/gcc/"},{"name":"lvgl","slug":"lvgl","permalink":"http://example.com/tags/lvgl/"},{"name":"树莓派","slug":"树莓派","permalink":"http://example.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"nginx","slug":"nginx","permalink":"http://example.com/tags/nginx/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"ssh","slug":"ssh","permalink":"http://example.com/tags/ssh/"},{"name":"TFTP","slug":"TFTP","permalink":"http://example.com/tags/TFTP/"},{"name":"NFS","slug":"NFS","permalink":"http://example.com/tags/NFS/"},{"name":"vim","slug":"vim","permalink":"http://example.com/tags/vim/"},{"name":"开发板","slug":"开发板","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"},{"name":"压缩","slug":"压缩","permalink":"http://example.com/tags/%E5%8E%8B%E7%BC%A9/"},{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/tags/nodejs/"},{"name":"express","slug":"express","permalink":"http://example.com/tags/express/"},{"name":"OCD","slug":"OCD","permalink":"http://example.com/tags/OCD/"},{"name":"pyocd","slug":"pyocd","permalink":"http://example.com/tags/pyocd/"},{"name":"OpenOCD","slug":"OpenOCD","permalink":"http://example.com/tags/OpenOCD/"},{"name":"gdb","slug":"gdb","permalink":"http://example.com/tags/gdb/"},{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"qt","slug":"qt","permalink":"http://example.com/tags/qt/"},{"name":"crc","slug":"crc","permalink":"http://example.com/tags/crc/"},{"name":"usb","slug":"usb","permalink":"http://example.com/tags/usb/"},{"name":"DAPLink","slug":"DAPLink","permalink":"http://example.com/tags/DAPLink/"},{"name":"objdump","slug":"objdump","permalink":"http://example.com/tags/objdump/"},{"name":"HardFault","slug":"HardFault","permalink":"http://example.com/tags/HardFault/"},{"name":"hex","slug":"hex","permalink":"http://example.com/tags/hex/"},{"name":"lwip","slug":"lwip","permalink":"http://example.com/tags/lwip/"},{"name":"mqtt","slug":"mqtt","permalink":"http://example.com/tags/mqtt/"},{"name":"Makefile","slug":"Makefile","permalink":"http://example.com/tags/Makefile/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]}