{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"test","slug":"test","date":"2024-12-26T01:43:25.000Z","updated":"2024-12-26T03:26:49.922Z","comments":true,"path":"2024/12/26/test/","permalink":"http://example.com/2024/12/26/test/","excerpt":"","text":"","categories":[],"tags":[{"name":"123","slug":"123","permalink":"http://example.com/tags/123/"}]},{"title":"sqlite","slug":"sqlite/readme","date":"2024-12-25T12:13:45.794Z","updated":"2024-12-26T01:45:37.530Z","comments":true,"path":"2024/12/25/sqlite/readme/","permalink":"http://example.com/2024/12/25/sqlite/readme/","excerpt":"","text":"下载链接SQLite3 C&#x2F;C++ 接口 API1sqlite3_open(const char *filename, sqlite3 **ppDb) 该例程打开一个指向 SQLite 数据库文件的连接，返回一个用于其他 SQLite 程序的数据库连接对象。如果 filename 参数是 NULL 或 ‘:memory:’，那么 sqlite3_open() 将会在 RAM 中创建一个内存数据库，这只会在 session 的有效时间内持续。如果文件名 filename 不为 NULL，那么 sqlite3_open() 将使用这个参数值尝试打开数据库文件。如果该名称的文件不存在，sqlite3_open() 将创建一个新的命名为该名称的数据库文件并打开。 1sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void *data, char **errmsg) 该例程提供了一个执行 SQL 命令的快捷方式，SQL 命令由 sql 参数提供，可以由多个 SQL 命令组成。在这里，第一个参数 sqlite3 是打开的数据库对象，sqlite_callback 是一个回调，data 作为其第一个参数，errmsg 将被返回用来获取程序生成的任何错误。sqlite3_exec() 程序解析并执行由 sql 参数所给的每个命令，直到字符串结束或者遇到错误为止。 1sqlite3_close(sqlite3*) 该例程关闭之前调用 sqlite3_open() 打开的数据库连接。所有与连接相关的语句都应在连接关闭之前完成。如果还有查询没有完成，sqlite3_close() 将返回 SQLITE_BUSY 禁止关闭的错误消息。 连接数据库下面的 C 代码段显示了如何连接到一个现有的数据库。如果数据库不存在，那么它就会被创建，最后将返回一个数据库对象。 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;sqlite3.h&gt;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; sqlite3_close(db);&#125; 现在，让我们来编译和运行上面的程序，在当前目录中创建我们的数据库 test.db。您可以根据需要改变路径。 $gcc test.c -l sqlite3 $./a.out Opened database successfully 如果要使用 C++ 源代码，可以按照下列所示编译代码： $g++ test.c -l sqlite3 在这里，把我们的程序链接上 sqlite3 库，以便向 C 程序提供必要的函数。这将在您的目录下创建一个数据库文件 test.db，您将得到如下结果： -rwxr-xr-x. 1 root root 7383 May 8 02:06 a.out -rw-r--r--. 1 root root 323 May 8 02:05 test.c -rw-r--r--. 1 root root 0 May 8 02:06 test.db 创建表下面的 C 代码段将用于在先前创建的数据库中创建一个表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt; static int callback(void *NotUsed, int argc, char **argv, char **azColName)&#123; int i; for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stdout, &quot;Opened database successfully\\n&quot;); &#125; /* Create SQL statement */ sql = &quot;CREATE TABLE COMPANY(&quot; \\ &quot;ID INT PRIMARY KEY NOT NULL,&quot; \\ &quot;NAME TEXT NOT NULL,&quot; \\ &quot;AGE INT NOT NULL,&quot; \\ &quot;ADDRESS CHAR(50),&quot; \\ &quot;SALARY REAL );&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, 0, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Table created successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会在 test.db 文件中创建 COMPANY 表，最终文件列表如下所示： -rwxr-xr-x. 1 root root 9567 May 8 02:31 a.out -rw-r--r--. 1 root root 1207 May 8 02:31 test.c -rw-r--r--. 1 root root 3072 May 8 02:31 test.db INSERT 操作下面的 C 代码段显示了如何在上面创建的 COMPANY 表中创建记录： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt;static int callback(void *NotUsed, int argc, char **argv, char **azColName)&#123; int i; for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create SQL statement */ sql = &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot; \\ &quot;VALUES (1, &#x27;Paul&#x27;, 32, &#x27;California&#x27;, 20000.00 ); &quot; \\ &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot; \\ &quot;VALUES (2, &#x27;Allen&#x27;, 25, &#x27;Texas&#x27;, 15000.00 ); &quot; \\ &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)&quot; \\ &quot;VALUES (3, &#x27;Teddy&#x27;, 23, &#x27;Norway&#x27;, 20000.00 );&quot; \\ &quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)&quot; \\ &quot;VALUES (4, &#x27;Mark&#x27;, 25, &#x27;Rich-Mond &#x27;, 65000.00 );&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, 0, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Records created successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会在 COMPANY 表中创建给定记录，并会显示以下两行： Opened database successfully Records created successfully SELECT 操作在我们开始讲解获取记录的实例之前，让我们先了解下回调函数的一些细节，这将在我们的实例使用到。这个回调提供了一个从 SELECT 语句获得结果的方式。它声明如下： 123456typedef int (*sqlite3_callback)(void*, /* Data provided in the 4th argument of sqlite3_exec() */int, /* The number of columns in row */char**, /* An array of strings representing fields in the row */char** /* An array of strings representing column names */); 如果上面的回调在 sqlite_exec() 程序中作为第三个参数，那么 SQLite 将为 SQL 参数内执行的每个 SELECT 语句中处理的每个记录调用这个回调函数。 下面的 C 代码段显示了如何从前面创建的 COMPANY 表中获取并显示记录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt;static int callback(void *data, int argc, char **argv, char **azColName)&#123; int i; fprintf(stderr, &quot;%s: &quot;, (const char*)data); for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; const char* data = &quot;Callback function called&quot;; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create SQL statement */ sql = &quot;SELECT * from COMPANY&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, (void*)data, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Operation done successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会产生以下结果： Opened database successfully Callback function called: ID = 1 NAME = Paul AGE = 32 ADDRESS = California SALARY = 20000.0 Callback function called: ID = 2 NAME = Allen AGE = 25 ADDRESS = Texas SALARY = 15000.0 Callback function called: ID = 3 NAME = Teddy AGE = 23 ADDRESS = Norway SALARY = 20000.0 Callback function called: ID = 4 NAME = Mark AGE = 25 ADDRESS = Rich-Mond SALARY = 65000.0 Operation done successfully UPDATE 操作下面的 C 代码段显示了如何使用 UPDATE 语句来更新任何记录，然后从 COMPANY 表中获取并显示更新的记录： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt; static int callback(void *data, int argc, char **argv, char **azColName)&#123; int i; fprintf(stderr, &quot;%s: &quot;, (const char*)data); for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; const char* data = &quot;Callback function called&quot;; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create merged SQL statement */ sql = &quot;UPDATE COMPANY set SALARY = 25000.00 where ID=1; &quot; \\ &quot;SELECT * from COMPANY&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, (void*)data, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Operation done successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会产生以下结果： Opened database successfully Callback function called: ID = 1 NAME = Paul AGE = 32 ADDRESS = California SALARY = 25000.0 Callback function called: ID = 2 NAME = Allen AGE = 25 ADDRESS = Texas SALARY = 15000.0 Callback function called: ID = 3 NAME = Teddy AGE = 23 ADDRESS = Norway SALARY = 20000.0 Callback function called: ID = 4 NAME = Mark AGE = 25 ADDRESS = Rich-Mond SALARY = 65000.0 Operation done successfully DELETE 操作下面的 C 代码段显示了如何使用 DELETE 语句删除任何记录，然后从 COMPANY 表中获取并显示剩余的记录： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sqlite3.h&gt; static int callback(void *data, int argc, char **argv, char **azColName)&#123; int i; fprintf(stderr, &quot;%s: &quot;, (const char*)data); for(i=0; i&lt;argc; i++)&#123; printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main(int argc, char* argv[])&#123; sqlite3 *db; char *zErrMsg = 0; int rc; char *sql; const char* data = &quot;Callback function called&quot;; /* Open database */ rc = sqlite3_open(&quot;test.db&quot;, &amp;db); if( rc )&#123; fprintf(stderr, &quot;Can&#x27;t open database: %s\\n&quot;, sqlite3_errmsg(db)); exit(0); &#125;else&#123; fprintf(stderr, &quot;Opened database successfully\\n&quot;); &#125; /* Create merged SQL statement */ sql = &quot;DELETE from COMPANY where ID=2; &quot; \\ &quot;SELECT * from COMPANY&quot;; /* Execute SQL statement */ rc = sqlite3_exec(db, sql, callback, (void*)data, &amp;zErrMsg); if( rc != SQLITE_OK )&#123; fprintf(stderr, &quot;SQL error: %s\\n&quot;, zErrMsg); sqlite3_free(zErrMsg); &#125;else&#123; fprintf(stdout, &quot;Operation done successfully\\n&quot;); &#125; sqlite3_close(db); return 0;&#125; 上述程序编译和执行时，它会产生以下结果： Opened database successfully Callback function called: ID = 1 NAME = Paul AGE = 32 ADDRESS = California SALARY = 20000.0 Callback function called: ID = 3 NAME = Teddy AGE = 23 ADDRESS = Norway SALARY = 20000.0 Callback function called: ID = 4 NAME = Mark AGE = 25 ADDRESS = Rich-Mond SALARY = 65000.0 Operation done successfully 使用sqlite3指令SELECT * FROM COMPANY;可以查看数据列表 Select 语句SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。 语法SQLite 的 SELECT 语句的基本语法如下： SELECT column1, column2, columnN FROM table_name; SELECT * FROM table_name; Schema 信息因为所有的点命令只在 SQLite 提示符中可用，所以当您进行带有 SQLite 的编程时，您要使用下面的带有 sqlite_master 表的 SELECT 语句来列出所有在数据库中创建的表： 1sqlite&gt; SELECT tbl_name FROM sqlite_master WHERE type = &#x27;table&#x27;; 您可以列出关于 COMPANY 表的完整信息，如下所示： 1sqlite&gt; SELECT sql FROM sqlite_master WHERE type = &#x27;table&#x27; AND tbl_name = &#x27;COMPANY&#x27;; Like 子句SQLite 的 LIKE 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用： 百分号 （%） 下划线 （_） 百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。 Glob 子句SQLite 的 GLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。 星号 （*） 问号 （?） 星号（*）代表零个、一个或多个数字或字符。问号（?）代表一个单一的数字或字符。这些符号可以被组合使用。 Where 子句SQLite的 WHERE 子句用于指定从一个表或多个表中获取数据的条件。 如果满足给定的条件，即为真（true）时，则从表中返回特定的值。您可以使用 WHERE 子句来过滤记录，只获取需要的记录。 WHERE 子句不仅可用在 SELECT 语句中，它也可用在 UPDATE、DELETE 语句中，等等 Update 语句SQLite 的 UPDATE 查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。 Distinct 关键字SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。 有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。 事务控制使用下面的命令来控制事务： BEGIN ：开始事务处理。 COMMIT：保存更改，或者可以使用 END TRANSACTION 命令。 ROLLBACK：回滚所做的更改。 事务控制命令只与 DML 命令 INSERT、UPDATE 和 DELETE 一起使用。他们不能在创建表或删除表时使用，因为这些操作在数据库中是自动提交的。 BEGIN 命令事务（Transaction）可以使用BEGIN 命令来启动。此类事务通常会持续执行下去，直到遇到下一个 COMMIT 或 ROLLBACK 命令。不过在数据库关闭或发生错误时，事务处理也会回滚。 COMMIT 命令COMMIT 命令是用于把事务调用的更改保存到数据库中的事务命令。自上次 COMMIT 或 ROLLBACK 命令以外的所有事务保存到数据库。 ROLLBACK 命令ROLLBACK 命令是用于撤消尚未保存到数据库的事务的事务命令。 ROLLBACK 命令只能用于撤销自上次发出 COMMIT 或 ROLLBACK 命令以外的事务。 实例开始一个事务，并从表中删除 age &#x3D; 25 的记录，最后，我们使用 ROLLBACK 命令撤消所有的更改。 123sqlite&gt; BEGIN;sqlite&gt; DELETE FROM COMPANY WHERE AGE = 25;sqlite&gt; ROLLBACK; 检查 COMPANY 表，仍然有记录 开始另一个事务，从表中删除 age &#x3D; 25 的记录，最后我们使用 COMMIT 命令提交所有的更改。 123sqlite&gt; BEGIN;sqlite&gt; DELETE FROM COMPANY WHERE AGE = 25;sqlite&gt; COMMIT; 基础操做 显示表1.tables 显示概要1.schema sqlite_master 格式化显示123456789显示头sqlite&gt;.header on按列显示sqlite&gt;.mode column显示运行时间sqlite&gt;.timer on设置输出列的宽度sqlite&gt;.width 10, 20, 10sqlite&gt;SELECT * FROM COMPANY; 主键自动增加&#x2F;&#x2F;历史最大值增加1ID INTEGER PRIMARY KEY AUTOINCREMENT 删除表1drop table company; 增加列12alter table company add column DATE char(20);alter table company add column TIME char(10); 删除列1alter table company drop column test; 添加时间日期1insert into company values(6,&#x27;huang&#x27;,31,&#x27;guangzhou&#x27;,8999,date(&#x27;now&#x27;,&#x27;localtime&#x27;),time(&#x27;now&#x27;,&#x27;localtime&#x27;)); 自动时间123...DATE TIMESTAMP NOT NULL DEFAULT(date(&#x27;now&#x27;,&#x27;localtime&#x27;)),TIME TIMESTAMP NOT NULL DEFAULT(time(&#x27;now&#x27;,&#x27;localtime&#x27;)) 筛选时间1select * from company where time &gt;time(&#x27;12:00:00&#x27;); 修改内容1update company set name=&#x27;gcc&#x27; where id=18; 去重1SELECT DISTINCT name FROM COMPANY; 筛选计数1SELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2; 排序1SELECT * FROM COMPANY ORDER BY SALARY ASC; 字符加前缀1update work set date=&#x27;2024-&#x27;||date; 列求和1select sum(time) from work;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-12-25T12:12:02.436Z","updated":"2024-12-25T12:22:50.452Z","comments":true,"path":"2024/12/25/hello-world/","permalink":"http://example.com/2024/12/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment markdown","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"123","slug":"123","permalink":"http://example.com/tags/123/"}]}